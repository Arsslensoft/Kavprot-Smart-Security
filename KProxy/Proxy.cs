namespace KProxy
{
    using Microsoft.Win32;
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Configuration;
    using System.Diagnostics;
    using System.Net;
    using System.Net.NetworkInformation;
    using System.Net.Sockets;
    using System.Security.Cryptography.X509Certificates;
    using System.Text;
    using System.Threading;
    using System.Windows.Forms;

    public class Proxy : IDisposable
    {
        private bool _bIsAttached;
        internal IPEndPoint _DefaultEgressEndPoint;
        private IPEndPoint _ipepFtpGateway;
        private IPEndPoint _ipepHttpGateway;
        private IPEndPoint _ipepHttpsGateway;
        private X509Certificate2 _oHTTPSCertificate;
        private string _sHTTPSHostname;
        internal static PipePool htServerPipePool = new PipePool();
        private Socket oAcceptor;
        internal WinINETConnectoids oAllConnectoids;
        internal WinHTTPAutoProxy oAutoProxy;
        private ProxyBypassList oBypassList;
        internal WinINETProxyInfo piPrior;
        private PreferenceBag.PrefWatcher? watcherPrefNotify = null;

        internal Proxy(bool bIsPrimary)
        {
            if (bIsPrimary)
            {
                try
                {
                    NetworkChange.NetworkAvailabilityChanged += new NetworkAvailabilityChangedEventHandler(this.NetworkChange_NetworkAvailabilityChanged);
                    NetworkChange.NetworkAddressChanged += new NetworkAddressChangedEventHandler(this.NetworkChange_NetworkAddressChanged);
                }
                catch
                {
                }
                try
                {
                    this.watcherPrefNotify = new PreferenceBag.PrefWatcher?(KProxyApplication.Prefs.AddWatcher("KProxy.network", new EventHandler<PrefChangeEventArgs>(this.onNetworkPrefsChange)));
                    this.SetDefaultEgressEndPoint(KProxyApplication.Prefs["KProxy.network.egress.ip"]);
                    KPCONFIG.SetNoDecryptList(KProxyApplication.Prefs["KProxy.network.https.NoDecryptionHosts"]);
                    KPCONFIG.sKProxyListenHostPort = KProxyApplication.Prefs.GetStringPref("KProxy.network.proxy.RegistrationHostName", "127.0.0.1") + ":" + KPCONFIG.ListenPort.ToString();
                    ClientChatter._cbClientReadBuffer = KProxyApplication.Prefs.GetInt32Pref("KProxy.network.sockets.ClientReadBufferSize", 0x2000);
                    ServerChatter._cbServerReadBuffer = KProxyApplication.Prefs.GetInt32Pref("KProxy.network.sockets.ServerReadBufferSize", 0x8000);
                }
                catch
                {
                }
            }
        }

        private void _DetermineGatewayIPEndPoints()
        {
            this._ipepHttpGateway = GetFirstRespondingEndpoint(this.piPrior.sHttpProxy);
            if (this.piPrior.sHttpsProxy == this.piPrior.sHttpProxy)
            {
                this._ipepHttpsGateway = this._ipepHttpGateway;
            }
            else
            {
                this._ipepHttpsGateway = GetFirstRespondingEndpoint(this.piPrior.sHttpsProxy);
            }
            if (this.piPrior.sFtpProxy == this.piPrior.sHttpProxy)
            {
                this._ipepFtpGateway = this._ipepHttpGateway;
            }
            else
            {
                this._ipepFtpGateway = GetFirstRespondingEndpoint(this.piPrior.sFtpProxy);
            }
        }

        internal string _GetPACScriptText(bool bUseKProxy)
        {
            string stringPref;
            if (bUseKProxy)
            {
                stringPref = KProxyApplication.Prefs.GetStringPref("KProxy.proxy.pacfile.text", "return 'PROXY " + KPCONFIG.sKProxyListenHostPort + "';");
            }
            else
            {
                stringPref = "return 'DIRECT';";
            }
            return ("//Autogenerated file; do not edit. Rewritten on attach and detach of Kavprot Proxy.\n//This Automatic Proxy Configuration script can be used by non-WinINET browsers.\nfunction FindProxyForURL(url, host){\n  " + stringPref + "\n}");
        }

        private static void _setDynamicRegistryKey(bool bAttached)
        {
            if (!KPCONFIG.bIsViewOnly)
            {
                try
                {
                    RegistryKey key = Registry.CurrentUser.CreateSubKey(KPCONFIG.GetRegPath("Dynamic"));
                    if (key != null)
                    {
                        key.SetValue("Attached", bAttached ? 1 : 0, RegistryValueKind.DWord);
                        key.Close();
                    }
                }
                catch (Exception exception)
                {
                    //KProxyApplication.Log.LogFormat("KProxy.network.KProxyHook> Unable to set Dynamic registry key; registry permissions likely corrupt. Exception: {0}", new object[] { exception.Message });
                }
            }
        }

        private void AcceptConnection(IAsyncResult ar)
        {
            try
            {
                ProxyExecuteParams state = new ProxyExecuteParams(this.oAcceptor.EndAccept(ar), this._oHTTPSCertificate);
                ThreadPool.UnsafeQueueUserWorkItem(new WaitCallback(Session.CreateAndExecute), state);
            }
            catch (ObjectDisposedException)
            {
                return;
            }
            catch
            {
            }
            try
            {
                this.oAcceptor.BeginAccept(new AsyncCallback(this.AcceptConnection), null);
            }
            catch
            {
            }
        }

        internal bool ActAsHTTPSEndpointForHostname(string sHTTPSHostname)
        {
            try
            {
                if (string.IsNullOrEmpty(sHTTPSHostname))
                {
                    throw new ArgumentException();
                }
                this._oHTTPSCertificate = CertMaker.FindCert(sHTTPSHostname, true);
                this._sHTTPSHostname = this._oHTTPSCertificate.Subject;
                return true;
            }
            catch
            {
                this._oHTTPSCertificate = null;
                this._sHTTPSHostname = null;
            }
            return false;
        }

        internal void AssignEndpointCertificate(X509Certificate2 certHTTPS)
        {
            this._oHTTPSCertificate = certHTTPS;
            if (certHTTPS != null)
            {
                this._sHTTPSHostname = certHTTPS.Subject;
            }
            else
            {
                this._sHTTPSHostname = null;
            }
        }

        public bool Attach()
        {
            return this.Attach(false);
        }

        internal bool Attach(bool bCollectGWInfo)
        {
            if (!this._bIsAttached)
            {
                if (bCollectGWInfo)
                {
                    this.CollectConnectoidAndGatewayInfo();
                }
                WinINETProxyInfo oNewInfo = new WinINETProxyInfo();
                oNewInfo.bUseManualProxies = true;
                oNewInfo.bAllowDirect = true;
                oNewInfo.sHttpProxy = KPCONFIG.sKProxyListenHostPort;
                if (KPCONFIG.bCaptureCONNECT)
                {
                    oNewInfo.sHttpsProxy = KPCONFIG.sKProxyListenHostPort;
                }
                else if (this.piPrior != null)
                {
                    oNewInfo.sHttpsProxy = this.piPrior.sHttpsProxy;
                }
                if ((this.piPrior != null) && this.piPrior.bUseManualProxies)
                {
                    oNewInfo.sFtpProxy = this.piPrior.sFtpProxy;
                    oNewInfo.sSocksProxy = this.piPrior.sSocksProxy;
                }
                if (KPCONFIG.bCaptureFTP)
                {
                    oNewInfo.sFtpProxy = KPCONFIG.sKProxyListenHostPort;
                }
                oNewInfo.sHostsThatBypass = KPCONFIG.sHostsThatBypassKProxy;
                if (KPCONFIG.bHookWithPAC)
                {
                    if (KProxyApplication.Prefs.GetBoolPref("KProxy.proxy.pacfile.usefileprotocol", true))
                    {
                        oNewInfo.sPACScriptLocation = "file://" + KPCONFIG.GetPath("Pac");
                    }
                    else
                    {
                        oNewInfo.sPACScriptLocation = "http://" + KPCONFIG.sKProxyListenHostPort + "/proxy.pac";
                    }
                }
                if (!KPCONFIG.bIsViewOnly)
                {
                    if (this.oAllConnectoids.HookConnections(oNewInfo))
                    {
                        this._bIsAttached = true;
                        KProxyApplication.OnKProxyAttach();
                        this.WriteAutoProxyPACFile(true);
                    }
                    else
                    {
                        KProxyApplication.DoNotifyUser("Failed to register KProxy as the system proxy.", "Error");
                        _setDynamicRegistryKey(false);
                        return false;
                    }
                    _setDynamicRegistryKey(true);
                }
            }
            return true;
        }

        internal void CollectConnectoidAndGatewayInfo()
        {
            this.oAllConnectoids = new WinINETConnectoids();
            this.piPrior = this.oAllConnectoids.GetDefaultConnectionGatewayInfo();
            if (KPCONFIG.bForwardToGateway && ((this.piPrior.sPACScriptLocation != null) || this.piPrior.bAutoDetect))
            {
                this.oAutoProxy = new WinHTTPAutoProxy(this.piPrior.bAutoDetect, this.piPrior.sPACScriptLocation);
            }
            else if (this.oAutoProxy != null)
            {
                this.oAutoProxy.Dispose();
                this.oAutoProxy = null;
            }
            if (KPCONFIG.bForwardToGateway && this.piPrior.bUseManualProxies)
            {
                this._DetermineGatewayIPEndPoints();
                if (string.IsNullOrEmpty(this.piPrior.sHostsThatBypass))
                {
                    this.oBypassList = null;
                }
                else
                {
                    this.oBypassList = new ProxyBypassList(this.piPrior.sHostsThatBypass);
                    if (!this.oBypassList.HasEntries)
                    {
                        this.oBypassList = null;
                    }
                }
            }
            else
            {
                this._ipepFtpGateway = this._ipepHttpGateway = (IPEndPoint) (this._ipepHttpsGateway = null);
                this.oBypassList = null;
            }
        }

        public bool Detach()
        {
            if (!this._bIsAttached)
            {
                return true;
            }
            if (KPCONFIG.bIsViewOnly)
            {
                return true;
            }
            _setDynamicRegistryKey(false);
            if (this.oAllConnectoids.UnhookAllConnections())
            {
                this._bIsAttached = false;
                KProxyApplication.OnKProxyDetach();
                this.WriteAutoProxyPACFile(false);
                return true;
            }
            return false;
        }

        public void Dispose()
        {
            if (this.watcherPrefNotify.HasValue)
            {
                KProxyApplication.Prefs.RemoveWatcher(this.watcherPrefNotify.Value);
            }
            if (this.oAutoProxy != null)
            {
                this.oAutoProxy.Dispose();
                this.oAutoProxy = null;
            }
            this.Stop();
        }

        public IPEndPoint FindGatewayForOrigin(string sURIScheme, string sHostAndPort)
        {
            if (!Utilities.isLocalhost(sHostAndPort))
            {
                if (sURIScheme.Equals("http", StringComparison.OrdinalIgnoreCase))
                {
                    if (sHostAndPort.EndsWith(":80", StringComparison.Ordinal))
                    {
                        sHostAndPort = sHostAndPort.Substring(0, sHostAndPort.Length - 3);
                    }
                }
                else if (sURIScheme.Equals("https", StringComparison.OrdinalIgnoreCase))
                {
                    if (sHostAndPort.EndsWith(":443", StringComparison.Ordinal))
                    {
                        sHostAndPort = sHostAndPort.Substring(0, sHostAndPort.Length - 4);
                    }
                }
                else if (sURIScheme.Equals("ftp", StringComparison.OrdinalIgnoreCase) && sHostAndPort.EndsWith(":21", StringComparison.Ordinal))
                {
                    sHostAndPort = sHostAndPort.Substring(0, sHostAndPort.Length - 3);
                }
                if ((this.oAutoProxy != null) && (this.oAutoProxy.iAutoProxySuccessCount > -1))
                {
                    IPEndPoint point;
                    if (this.oAutoProxy.GetAutoProxyForUrl(sURIScheme + "://" + sHostAndPort, out point))
                    {
                        this.oAutoProxy.iAutoProxySuccessCount = 1;
                        return point;
                    }
                    if ((this.oAutoProxy.iAutoProxySuccessCount == 0) && !KProxyApplication.Prefs.GetBoolPref("KProxy.network.gateway.UseFailedAutoProxy", false))
                    {
                        //KProxyApplication.Log.LogString("AutoProxy failed. Disabling for this network.");
                        this.oAutoProxy.iAutoProxySuccessCount = -1;
                    }
                }
                if (((this.piPrior == null) || !this.piPrior.bBypassIntranetHosts) || !Utilities.isPlainHostName(sHostAndPort))
                {
                    if ((this.oBypassList != null) && this.oBypassList.IsBypass(sURIScheme + "://" + sHostAndPort))
                    {
                        return null;
                    }
                    if (sURIScheme.Equals("http", StringComparison.OrdinalIgnoreCase))
                    {
                        return this._ipepHttpGateway;
                    }
                    if (sURIScheme.Equals("https", StringComparison.OrdinalIgnoreCase))
                    {
                        return this._ipepHttpsGateway;
                    }
                    if (sURIScheme.Equals("ftp", StringComparison.OrdinalIgnoreCase))
                    {
                        return this._ipepFtpGateway;
                    }
                }
            }
            return null;
        }

        private static IPEndPoint GetFirstRespondingEndpoint(string sHostPortList)
        {
            string str;
            IPAddress[] addressArray;
            if ((sHostPortList == null) || sHostPortList.Trim().Equals(string.Empty))
            {
                return null;
            }
            sHostPortList = Utilities.TrimAfter(sHostPortList, ';');
            IPEndPoint point = null;
            int iPort = 80;
            Utilities.CrackHostAndPort(sHostPortList, out str, ref iPort);
            try
            {
                addressArray = DNSResolver.GetIPAddressList(str, true, null);
            }
            catch
            {
                //KProxyApplication.Log.LogFormat("KProxy.network.gateway> Unable to resolve upstream proxy '{0}'... ignoring.", new object[] { sHostPortList });
                return null;
            }
            try
            {
                foreach (IPAddress address in addressArray)
                {
                    try
                    {
                        Socket socket = new Socket(address.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
                        socket.NoDelay = true;
                        if (KProxyApplication.oProxy._DefaultEgressEndPoint != null)
                        {
                            socket.Bind(KProxyApplication.oProxy._DefaultEgressEndPoint);
                        }
                        socket.Connect(address, iPort);
                        point = new IPEndPoint(address, iPort);
                        socket.Close();
                        break;
                    }
                    catch (Exception exception)
                    {
                        if (!KProxyApplication.Prefs.GetBoolPref("KProxy.network.dns.fallback", true))
                        {
                            break;
                        }
                        //KProxyApplication.Log.LogFormat("KProxy.network.gateway.connect>Connection to {0} failed. {1}. Will try DNS Failover if available.", new object[] { address.ToString(), exception.Message });
                    }
                }
                return point;
            }
            catch
            {
                return null;
            }
        }

        public void InjectCustomRequest(string sRequest)
        {
            Socket socket = new Socket(IPAddress.Loopback.AddressFamily, SocketType.Stream, ProtocolType.Tcp);
            socket.Connect(new IPEndPoint(IPAddress.Loopback, KPCONFIG.ListenPort));
            socket.Send(Encoding.UTF8.GetBytes(sRequest));
            socket.Shutdown(SocketShutdown.Both);
            socket.Close();
        }

        public void InjectCustomRequest(string sRequest, StringDictionary oNewFlags)
        {
            this.SendRequest(sRequest, oNewFlags);
        }

        public void InjectCustomRequest(HTTPRequestHeaders oHeaders, byte[] arrRequestBodyBytes, StringDictionary oNewFlags)
        {
            this.SendRequest(oHeaders, arrRequestBodyBytes, oNewFlags);
        }

        [Obsolete("This overload of InjectCustomRequest is obsolete. Use a different version.", true)]
        public void InjectCustomRequest(HTTPRequestHeaders oHeaders, byte[] arrRequestBodyBytes, bool bRunRequestRules, bool bViewResult)
        {
            StringDictionary oNewFlags = new StringDictionary();
            oNewFlags["x-From-Builder"] = "true";
            if (bViewResult)
            {
                oNewFlags["x-Builder-Inspect"] = "1";
            }
            this.InjectCustomRequest(oHeaders, arrRequestBodyBytes, oNewFlags);
        }

        private void NetworkChange_NetworkAddressChanged(object sender, EventArgs e)
        {
            try
            {
                DNSResolver.ClearCache();
                //KProxyApplication.Log.LogString("NetworkAddressChanged.");
                if (this.oAutoProxy != null)
                {
                    this.oAutoProxy.iAutoProxySuccessCount = 0;
                }
                if ((KPCONFIG.bForwardToGateway && (this.piPrior != null)) && this.piPrior.bUseManualProxies)
                {
                    this._DetermineGatewayIPEndPoints();
                }
            }
            catch (Exception exception)
            {
                KProxyApplication.ReportException(exception);
            }
        }

        private void NetworkChange_NetworkAvailabilityChanged(object sender, NetworkAvailabilityEventArgs e)
        {
            try
            {
                htServerPipePool.Clear();
                //KProxyApplication.Log.LogFormat("KProxy.network.availability.change> Network Available: {0}", new object[] { e.IsAvailable });
            }
            catch
            {
            }
        }

        private void onNetworkPrefsChange(object sender, PrefChangeEventArgs oPCE)
        {
            if (oPCE.PrefName == "KProxy.network.sockets.ClientReadBufferSize")
            {
                ClientChatter._cbClientReadBuffer = KProxyApplication.Prefs.GetInt32Pref("KProxy.network.sockets.ClientReadBufferSize", 0x2000);
            }
            if (oPCE.PrefName == "KProxy.network.sockets.ServerReadBufferSize")
            {
                ServerChatter._cbServerReadBuffer = KProxyApplication.Prefs.GetInt32Pref("KProxy.network.sockets.ServerReadBufferSize", 0x8000);
            }
            if (oPCE.PrefName == "KProxy.network.egress.ip")
            {
                this.SetDefaultEgressEndPoint(oPCE.ValueString);
            }
            else if (oPCE.PrefName == "KProxy.network.https.NoDecryptionHosts")
            {
                KPCONFIG.SetNoDecryptList(oPCE.ValueString);
            }
            else if (oPCE.PrefName == "KProxy.network.proxy.RegistrationHostName")
            {
                KPCONFIG.sKProxyListenHostPort = KProxyApplication.Prefs.GetStringPref("KProxy.network.proxy.RegistrationHostName", "127.0.0.1") + ":" + KPCONFIG.ListenPort.ToString();
            }
        }

        public void PurgeServerPipePool()
        {
            htServerPipePool.Clear();
        }

        public Session SendRequest(string sRequest, StringDictionary oNewFlags)
        {
            int num;
            int num2;
            HTTPHeaderParseWarnings warnings;
            byte[] buffer2;
            byte[] bytes = KPCONFIG.oHeaderEncoding.GetBytes(sRequest);
            if (!Parser.FindEntityBodyOffsetFromArray(bytes, out num, out num2, out warnings))
            {
                throw new ArgumentException("sRequest did not represent a valid HTTP request", "sRequest");
            }
            string sHeaders = KPCONFIG.oHeaderEncoding.GetString(bytes, 0, num) + "\r\n\r\n";
            HTTPRequestHeaders oHeaders = new HTTPRequestHeaders();
            if (!oHeaders.AssignFromString(sHeaders))
            {
                throw new ArgumentException("sRequest did not contain valid HTTP headers", "sRequest");
            }
            if (1 > (bytes.Length - num2))
            {
                buffer2 = new byte[0];
            }
            else
            {
                buffer2 = new byte[bytes.Length - num2];
                Buffer.BlockCopy(bytes, num2, buffer2, 0, buffer2.Length);
            }
            return this.SendRequest(oHeaders, buffer2, oNewFlags);
        }

        public Session SendRequest(HTTPRequestHeaders oHeaders, byte[] arrRequestBodyBytes, StringDictionary oNewFlags)
        {
            Session session = new Session((HTTPRequestHeaders) oHeaders.Clone(), arrRequestBodyBytes);
            session.SetBitFlag(SessionFlags.RequestGeneratedByKProxy, true);
            if ((oNewFlags != null) && (oNewFlags.Count > 0))
            {
                foreach (DictionaryEntry entry in oNewFlags)
                {
                    session.oFlags[(string) entry.Key] = oNewFlags[(string) entry.Key];
                }
            }
            ThreadPool.UnsafeQueueUserWorkItem(new WaitCallback(session.Execute), null);
            return session;
        }

        private void SetDefaultEgressEndPoint(string sEgressIP)
        {
            if (string.IsNullOrEmpty(sEgressIP))
            {
                this._DefaultEgressEndPoint = null;
            }
            else
            {
                IPAddress address;
                if (IPAddress.TryParse(sEgressIP, out address))
                {
                    this._DefaultEgressEndPoint = new IPEndPoint(address, 0);
                }
                else
                {
                    this._DefaultEgressEndPoint = null;
                }
            }
        }

        internal bool Start(int iPort, bool bAllowRemote)
        {
            if (KPCONFIG.bIsViewOnly)
            {
                return false;
            }
            bool flag = false;
            try
            {
                flag = (bAllowRemote && KPCONFIG.bEnableIPv6) && Socket.OSSupportsIPv6;
            }
            catch (Exception exception)
            {
              
                    KProxyApplication.DoNotifyUser(string.Concat(new object[] { "A Microsoft .NET configuration file (listed below) is corrupt and contains invalid data. You can often correct this error by installing updates from WindowsUpdate and/or reinstalling the .NET Framework.\n\n", exception.Message, "\nSource: ", exception.Source, "\n", exception.StackTrace, "\n\n", exception.InnerException, "\nKProxy v", Application.ProductVersion, (8 == IntPtr.Size) ? " (x64) " : " (x86) ", " [.NET ", Environment.Version, " on ", Environment.OSVersion.VersionString, "] " }), ".NET Configuration Error", MessageBoxIcon.Hand);
                    this.oAcceptor = null;
                    return false;
               
            }
            try
            {
                if (flag)
                {
                    this.oAcceptor = new Socket(AddressFamily.InterNetworkV6, SocketType.Stream, ProtocolType.Tcp);
                    if (Environment.OSVersion.Version.Major > 5)
                    {
                        this.oAcceptor.SetSocketOption(SocketOptionLevel.IPv6, SocketOptionName.PacketInformation | SocketOptionName.KeepAlive, 0);
                    }
                }
                else
                {
                    this.oAcceptor = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                }
                if (KPCONFIG.ForceExclusivePort)
                {
                    this.oAcceptor.ExclusiveAddressUse = true;
                }
                if (bAllowRemote)
                {
                    if (flag)
                    {
                        this.oAcceptor.Bind(new IPEndPoint(IPAddress.IPv6Any, iPort));
                    }
                    else
                    {
                        this.oAcceptor.Bind(new IPEndPoint(IPAddress.Any, iPort));
                    }
                }
                else
                {
                    this.oAcceptor.Bind(new IPEndPoint(IPAddress.Loopback, iPort));
                }
                this.oAcceptor.Listen(50);
            }
            catch (SocketException exception2)
            {
                string str = string.Empty;
                string sTitle = "KProxy Cannot Listen";
                switch (exception2.ErrorCode)
                {
                    case 0x273f:
                    case 0x2741:
                        if (flag)
                        {
                            str = "\nThis often means that you've enabled IPv6 support inside Tools > Kavprot Proxy Options, but your computer has IPv6 disabled.";
                        }
                        break;

                    case 0x2740:
                    case 0x271d:
                        str = "\nThis is usually due to another service running on this port. Run NETSTAT -A at a command prompt.\nIf you don't want to stop using the other program, simply change the port used by KProxy.\nClick Tools > KProxy Options > Connections, select a new port, and restart KProxy.";
                        sTitle = "Kavprot Proxy Port in Use";
                        break;
                }
                this.oAcceptor = null;
                KProxyApplication.DoNotifyUser(string.Format("Unable to bind to port [Localhost:{0}]. ErrorCode: {1}.\n{2}\n\n{3}\n\n{4}", new object[] { KPCONFIG.ListenPort, exception2.ErrorCode, str, exception2.ToString(), string.Concat(new object[] { "KProxy v", Application.ProductVersion, " [.NET ", Environment.Version, " on ", Environment.OSVersion.VersionString, "]" }) }), sTitle, MessageBoxIcon.Hand);
                return false;
            }
            catch (Exception exception3)
            {
                this.oAcceptor = null;
                KProxyApplication.ReportException(exception3);
                return false;
            }
            try
            {
                this.oAcceptor.BeginAccept(new AsyncCallback(this.AcceptConnection), null);
            }
            catch (Exception exception4)
            {
                this.oAcceptor = null;
                //KProxyApplication.Log.LogFormat("Kavprot Proxy BeginAccept() Exception: {0}", new object[] { exception4.Message });
                return false;
            }
            return true;
        }

        internal void Stop()
        {
            if (this.oAcceptor != null)
            {
                try
                {
                    this.oAcceptor.LingerState = new LingerOption(true, 0);
                    this.oAcceptor.Close();
                }
                catch (Exception exception)
                {
                    Trace.WriteLine("oProxy.Dispose threw an exception: " + exception.Message);
                }
            }
        }

        public override string ToString()
        {
            return string.Format("Proxy instance is listening for requests on Port #{0}\n\n{1}", this.ListenPort, htServerPipePool.InspectPool());
        }

        private void WriteAutoProxyPACFile(bool bUseKProxy)
        {
            bool bIsViewOnly = KPCONFIG.bIsViewOnly;
        }

        public bool IsAttached
        {
            get
            {
                return this._bIsAttached;
            }
            set
            {
                if (value)
                {
                    this.Attach();
                }
                else
                {
                    this.Detach();
                }
            }
        }

        public int ListenPort
        {
            get
            {
                if (this.oAcceptor != null)
                {
                    return (this.oAcceptor.LocalEndPoint as IPEndPoint).Port;
                }
                return 0;
            }
        }
    }
}

