<?xml version="1.0"?>
<doc>
    <assembly>
        <name>KPCAP</name>
    </assembly>
    <members>
        <member name="T:KPCAP.DeviceNotReadyException">
            <summary>
            A PcapDevice or dumpfile is not ready for capture operations.
            </summary>
        </member>
        <member name="T:KPCAP.PcapException">
            <summary>
            General Pcap Exception.
            </summary>
        </member>
        <member name="T:KPCAP.AirPcap.AirPcapChannelInfoFlags">
            <summary>
            Channel info flags
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapChannelInfoFlags.None">
            <summary>
            No flags set
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapChannelInfoFlags.TxEnable">
             <summary>
             Channel info flag: the channel is enabled for transmission, too.
            
             To comply with the electomagnetic emission regulations of the different countries, the AirPcap hardware can be programmed
             to block transmission on specific channels. This flag is set by AirpcapGetDeviceSupportedChannels() to indicate that a 
             channel in the list supports transmission.
             </summary>
        </member>
        <member name="T:KPCAP.ARP">
            <summary>
            Resolves MAC addresses from IP addresses using the Address Resolution Protocol (ARP)
            </summary>
        </member>
        <member name="M:KPCAP.ARP.#ctor">
            <summary>
            Constructs a new ARP Resolver
            </summary>
        </member>
        <member name="M:KPCAP.ARP.#ctor(System.String)">
            <summary>
            Constructs a new ARP Resolver
            </summary>
            <param name="deviceName">The name of the network device on which this resolver sends its ARP packets</param>
        </member>
        <member name="M:KPCAP.ARP.Resolve(System.Net.IPAddress)">
            <summary>
            Resolves the MAC address of the specified IP address. The 'DeviceName' propery must be set
            prior to using this method.
            </summary>
            <param name="destIP">The IP address to resolve</param>
            <returns>The MAC address that matches to the given IP address</returns>
        </member>
        <member name="M:KPCAP.ARP.Resolve(System.Net.IPAddress,System.String,System.Net.IPAddress)">
            <summary>
            Resolves the MAC address of the specified IP address.
            </summary>
            <param name="destIP">The IP address to resolve</param>
            <param name="deviceName">The local network device name on which to send the ARP request</param>
            <param name="srcIP">The local IP address from which to send the ARP request</param>
            <returns>The MAC address that matches to the given IP address or
            null if there was a timeout</returns>
        </member>
        <member name="M:KPCAP.ARP.Resolve(System.Net.IPAddress,System.String)">
            <summary>
            Resolves the MAC address of the specified IP address
            </summary>
            <param name="destIP">The IP address to resolve</param>
            <param name="deviceName">The local network device name on which to send the ARP request</param>
            <returns>The MAC address that matches to the given IP address or
            null if there was a timeout</returns>
        </member>
        <member name="P:KPCAP.ARP.LocalMAC">
            <summary>
            The source MAC address to be used for ARP requests.
            If null, the local device MAC address is used
            </summary>
        </member>
        <member name="P:KPCAP.ARP.LocalIP">
            <summary>
            The source IP address to be used for ARP requests.
            If null, the local device IP address is used
            </summary>
        </member>
        <member name="P:KPCAP.ARP.DeviceName">
            <summary>
            The default device name on which to send ARP requests
            </summary>
        </member>
        <member name="P:KPCAP.ARP.Timeout">
            <summary>
            Timeout for a given call to Resolve()
            </summary>
        </member>
        <member name="T:KPCAP.NotSupportedOnOfflineDeviceException">
            <summary>
            Thrown when a method not supported on an offline device is called
            </summary>
        </member>
        <member name="M:KPCAP.NotSupportedOnOfflineDeviceException.#ctor(System.String)">
            <summary>
            string constructor
            </summary>
            <param name="msg">
            A <see cref="T:System.String"/>
            </param>
        </member>
        <member name="T:KPCAP.LibPcap.PcapUnmanagedStructures.pcap_if">
            <summary>
            Item in a list of interfaces.
            </summary>
        </member>
        <member name="T:KPCAP.LibPcap.PcapUnmanagedStructures.pcap_addr">
            <summary>
            Representation of an interface address.
            </summary>
        </member>
        <member name="T:KPCAP.LibPcap.PcapUnmanagedStructures.sockaddr">
            <summary>
            Structure used by kernel to store a generic address
            Look at the sa_family value to determine which specific structure to use
            'struct sockaddr'
            </summary>
        </member>
        <member name="T:KPCAP.LibPcap.PcapUnmanagedStructures.in_addr">
            <summary>
            Structure that holds an ipv4 address
            </summary>
        </member>
        <member name="T:KPCAP.LibPcap.PcapUnmanagedStructures.sockaddr_in">
            <summary>
            Structure that holds an ipv4 address
            'struct sockaddr'
            </summary>
        </member>
        <member name="T:KPCAP.LibPcap.PcapUnmanagedStructures.sockaddr_in6">
            <summary>
            Structure that holds an ipv6 address
            NOTE: we cast the 'struct sockaddr*' to this structure based on the sa_family type
            'struct sockaddr_in6'
            </summary>
        </member>
        <member name="T:KPCAP.LibPcap.PcapUnmanagedStructures.sockaddr_ll">
            <summary>
            Structure to represent a low level address, like a hardware address
            </summary>
        </member>
        <member name="T:KPCAP.LibPcap.PcapUnmanagedStructures.timeval_unix">
             <summary>
             Windows and Unix differ in their memory models and make it difficult to
             support struct timeval in a single library, like this one, across
             multiple platforms.
            
             See http://en.wikipedia.org/wiki/64bit#Specific_data_models
            
             The issue is that struct timeval { long tv_sec; long tv_usec; }
             has different sizes on Linux 32 and 64bit but the same size on
             Windows 32 and 64 bit
            
             Thanks to Jon Pryor for his help in figuring out both the issue with Linux
             32/64bit and the issue between Windows and Unix
             </summary>
        </member>
        <member name="T:KPCAP.LibPcap.PcapUnmanagedStructures.timeval_windows">
            <summary>
            Windows version of struct timeval, the longs are 32bit even on 64-bit versions of Windows
            </summary>
        </member>
        <member name="T:KPCAP.LibPcap.PcapUnmanagedStructures.pcap_pkthdr_unix">
            <summary>
            Each packet in the dump file is prepended with this generic header.
            This gets around the problem of different headers for different
            packet interfaces.
            </summary>
        </member>
        <member name="T:KPCAP.LibPcap.PcapUnmanagedStructures.pcap_pkthdr_windows">
            <summary>
            Each packet in the dump file is prepended with this generic header.
            This gets around the problem of different headers for different
            packet interfaces.
            </summary>
        </member>
        <member name="T:KPCAP.LibPcap.PcapUnmanagedStructures.PCAP_PKTDATA">
            <summary>
            Packet data bytes
            NOTE: This struct doesn't exist in header files, it is a construct to map to an
                   unmanaged byte array
            </summary>
        </member>
        <member name="T:KPCAP.LibPcap.PcapUnmanagedStructures.bpf_program">
            <summary>
            A BPF pseudo-assembly program for packet filtering
            </summary>
        </member>
        <member name="T:KPCAP.LibPcap.PcapUnmanagedStructures.pcap_send_queue">
            <summary>
            A queue of raw packets that will be sent to the network with pcap_sendqueue_transmit()
            </summary>
        </member>
        <member name="T:KPCAP.LibPcap.PcapUnmanagedStructures.PcapStatReturnValue">
            <summary>
            Define the return values from int pcap_stats()
            </summary>
        </member>
        <member name="T:KPCAP.LibPcap.PcapUnmanagedStructures.pcap_stat_unix">
            <summary>
            Unix version of 'struct pcap_stat'
            Uses the same trick as timeval_unix
            </summary>
        </member>
        <member name="F:KPCAP.LibPcap.PcapUnmanagedStructures.pcap_stat_unix.ps_recv">
            <summary>
            Packets received
            </summary>
        </member>
        <member name="F:KPCAP.LibPcap.PcapUnmanagedStructures.pcap_stat_unix.ps_drop">
            <summary>
            Packets dropped
            </summary>
        </member>
        <member name="F:KPCAP.LibPcap.PcapUnmanagedStructures.pcap_stat_unix.ps_ifdrop">
            <summary>
            Drops by interface (maybe not yet supported)
            </summary>
        </member>
        <member name="T:KPCAP.LibPcap.PcapUnmanagedStructures.pcap_stat_windows">
            <summary>
            Windows version of 'struct pcap_stat'
            </summary>
        </member>
        <member name="F:KPCAP.LibPcap.PcapUnmanagedStructures.pcap_stat_windows.ps_recv">
            <summary>
            Packets received
            </summary>
        </member>
        <member name="F:KPCAP.LibPcap.PcapUnmanagedStructures.pcap_stat_windows.ps_drop">
            <summary>
            Packets dropped
            </summary>
        </member>
        <member name="F:KPCAP.LibPcap.PcapUnmanagedStructures.pcap_stat_windows.ps_ifdrop">
            <summary>
            Drops by interface (maybe not yet supported)
            </summary>
        </member>
        <member name="F:KPCAP.LibPcap.PcapUnmanagedStructures.pcap_stat_windows.bs_capt">
            <summary>
            Packets that reach the application
            WIN32 only, based on struct pcap_stat in pcap.h
            </summary>
        </member>
        <member name="T:KPCAP.WinPcap.AuthenticationTypes">
            <summary>
            Types of authentication
            </summary>
        </member>
        <member name="F:KPCAP.WinPcap.AuthenticationTypes.Null">
            <summary>
            Null authentication
            </summary>
        </member>
        <member name="F:KPCAP.WinPcap.AuthenticationTypes.Password">
            <summary>
            Username/password authentication
            </summary>
        </member>
        <member name="T:KPCAP.WinPcapRequiredException">
            <summary>
            Exception thrown when a WinPcap extension method is called from
            a non-Windows platform
            </summary>
        </member>
        <member name="M:KPCAP.WinPcapRequiredException.#ctor(System.String)">
            <summary>
            string constructor
            </summary>
            <param name="msg">
            A <see cref="T:System.String"/>
            </param>
        </member>
        <member name="T:KPCAP.ICaptureStatistics">
            <summary>
            Adapter statistics, received, dropped packet counts etc
            </summary>
        </member>
        <member name="P:KPCAP.ICaptureStatistics.ReceivedPackets">
            <value>
            Number of packets received
            </value>
        </member>
        <member name="P:KPCAP.ICaptureStatistics.DroppedPackets">
            <value>
            Number of packets dropped
            </value>
        </member>
        <member name="P:KPCAP.ICaptureStatistics.InterfaceDroppedPackets">
            <value>
            Number of interface dropped packets
            </value>
        </member>
        <member name="T:KPCAP.ICaptureDevice">
            <summary>
            Interfaces for capture devices
            </summary>
        </member>
        <member name="M:KPCAP.ICaptureDevice.Dump(Kavprot.Packets.RawPacket)">
            <summary>
            Writes a packet to the pcap dump file associated with this device.
            </summary>
            <param name="p">The packet to write</param>
        </member>
        <member name="M:KPCAP.ICaptureDevice.DumpOpen(System.String)">
            <summary>
            Opens a file for packet writings
            </summary>
            <param name="fileName"></param>
        </member>
        <member name="M:KPCAP.ICaptureDevice.DumpClose">
            <summary>
            Closes the opened dump file
            </summary>
        </member>
        <member name="M:KPCAP.ICaptureDevice.DumpFlush">
            <summary>
            Flushes all write buffers of the opened dump file
            </summary>
        </member>
        <member name="M:KPCAP.ICaptureDevice.Open">
            <summary>
            Opens the adapter
            </summary>
        </member>
        <member name="M:KPCAP.ICaptureDevice.Open(KPCAP.DeviceMode)">
            <summary>
            Open the device. To start capturing call the 'StartCapture' function
            </summary>
            <param name="mode">
            A <see cref="T:KPCAP.DeviceMode"/>
            </param>
        </member>
        <member name="M:KPCAP.ICaptureDevice.Open(KPCAP.DeviceMode,System.Int32)">
            <summary>
            Open the device. To start capturing call the 'StartCapture' function
            </summary>
            <param name="mode">
            A <see cref="T:KPCAP.DeviceMode"/>
            </param>
            <param name="read_timeout">
            A <see cref="T:System.Int32"/>
            </param>
        </member>
        <member name="M:KPCAP.ICaptureDevice.Close">
            <summary>
            Closes this adapter
            </summary>
        </member>
        <member name="M:KPCAP.ICaptureDevice.StartCapture">
            <summary>
            Start the capture
            </summary>
        </member>
        <member name="M:KPCAP.ICaptureDevice.StopCapture">
            <summary>
            Stop the capture
            </summary>
        </member>
        <member name="M:KPCAP.ICaptureDevice.Capture">
            <summary>
            Synchronously capture packets on this device. Method blocks forever.
            </summary>
        </member>
        <member name="M:KPCAP.ICaptureDevice.GetNextPacket">
            <summary>
            Retrieves the next packet from a device
            </summary>
            <returns></returns>
        </member>
        <member name="M:KPCAP.ICaptureDevice.SendPacket(Kavprot.Packets.Packet)">
            <summary>
            Sends a raw packet throgh this device
            </summary>
            <param name="p">The packet to send</param>
        </member>
        <member name="M:KPCAP.ICaptureDevice.SendPacket(Kavprot.Packets.Packet,System.Int32)">
            <summary>
            Sends a raw packet throgh this device
            </summary>
            <param name="p">The packet to send</param>
            <param name="size">The number of bytes to send</param>
        </member>
        <member name="M:KPCAP.ICaptureDevice.SendPacket(System.Byte[])">
            <summary>
            Sends a raw packet throgh this device
            </summary>
            <param name="p">The packet bytes to send</param>
        </member>
        <member name="M:KPCAP.ICaptureDevice.SendPacket(System.Byte[],System.Int32)">
            <summary>
            Sends a raw packet throgh this device
            </summary>
            <param name="p">The packet bytes to send</param>
            <param name="size">The number of bytes to send</param>
        </member>
        <member name="P:KPCAP.ICaptureDevice.Name">
            <summary>
            Gets the name of the device
            </summary>
        </member>
        <member name="P:KPCAP.ICaptureDevice.Description">
            <value>
            Description of the device
            </value>
        </member>
        <member name="P:KPCAP.ICaptureDevice.LastError">
            <summary>
            The last pcap error associated with this pcap device
            </summary>
        </member>
        <member name="P:KPCAP.ICaptureDevice.Filter">
            <summary>
            Kernel level filtering expression associated with this device.
            For more info on filter expression syntax, see:
            http://www.winpcap.org/docs/docs31/html/group__language.html
            </summary>
        </member>
        <member name="P:KPCAP.ICaptureDevice.Statistics">
            <summary>
            Retrieves pcap statistics
            </summary>
        </member>
        <member name="P:KPCAP.ICaptureDevice.DumpOpened">
            <summary>
            Gets a value indicating whether a dump file is already associated with this device
            </summary>
        </member>
        <member name="E:KPCAP.ICaptureDevice.OnPacketArrival">
            <summary>
            Fires whenever a new packet is processed, either when the packet arrives
            from the network device or when the packet is read from the on-disk file.<br/>
            For network captured packets this event is invoked only when working in "PcapMode.Capture" mode.
            </summary>
        </member>
        <member name="E:KPCAP.ICaptureDevice.OnCaptureStopped">
            <summary>
            Fired when the capture process of this pcap device is stopped
            </summary>
        </member>
        <member name="P:KPCAP.ICaptureDevice.Started">
            <summary>
            Return a value indicating if the capturing process of this adapter is started
            </summary>
        </member>
        <member name="P:KPCAP.ICaptureDevice.StopCaptureTimeout">
            <summary>
            Maximum time within which the capture thread must join the main thread (on
            <see cref="M:KPCAP.ICaptureDevice.StopCapture"/>) or else the thread is aborted and an exception thrown.
            </summary>
        </member>
        <member name="P:KPCAP.ICaptureDevice.LinkType">
            <summary>
            Return the pcap link layer value of an adapter. 
            </summary>
        </member>
        <member name="T:KPCAP.Pcap">
            <summary>
            Constants and static helper methods
            </summary>
        </member>
        <member name="F:KPCAP.Pcap.InfinitePacketCount">
            <summary>Represents the infinite number for packet captures </summary>
        </member>
        <member name="P:KPCAP.Pcap.Version">
            <summary>
            Returns the pcap version string retrieved via a call to pcap_lib_version()
            </summary>
        </member>
        <member name="T:KPCAP.AirPcap.AirPcapSafeNativeMethods">
            <summary>
            Per http://msdn.microsoft.com/en-us/ms182161.aspx 
            </summary>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapGetVersion(System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">
            <summary>
            Sets variables to the particular version being used
            </summary>
            <param name="VersionMajor">Pointer to a variable that will be filled with the major version number</param>
            <param name="VersionMinor">Pointer to a variable that will be filled with the minor version number</param>
            <param name="VersionRev">Pointer to a variable that will be filled with the revision number</param>
            <param name="VersionBuild">Pointer to a variable that will be filled with the build number</param>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapGetLastError(System.IntPtr)">
            <summary>
            Returns the last error related to the specified handle
            </summary>
            <param name="AdapterHandle">Handle to an open adapter</param>
            <returns>String with the last error, a PCHAR</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapGetDeviceList(System.IntPtr@,System.Text.StringBuilder)">
            <summary>
            Returns the list of available devices 
            </summary>
            <param name="PPAllDevs">Address to a caller allocated pointer. On success this pointer will receive the head of a list of available devices.</param>
            <param name="Ebuf">String that will contain error information if FALSE is returned. The size of the string must be AIRPCAP_ERRBUF_SIZE bytes.</param>
            <returns>TRUE on success. FALSE is returned on failure, in which case Ebuf is filled in with an appropriate error message.</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapFreeDeviceList(System.IntPtr)">
            <summary>
            Frees a list of devices returned by AirpcapGetDeviceList()
            </summary>
            <param name="PAllDevs">Head of the list of devices returned by AirpcapGetDeviceList()</param>
            <returns></returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapOpen(System.String,System.Text.StringBuilder)">
            <summary>
            Opens an adapter
            </summary>
            <param name="DeviceName">Name of the device to open. Use AirpcapGetDeviceList() to get the list of devices.</param>
            <param name="Ebuf">String that will contain error information in case of failure. The size of the string must be AIRPCAP_ERRBUF_SIZE bytes.</param>
            <returns>A PAirpcapHandle handle on success. NULL is returned on failure, in which case Ebuf is filled in with an appropriate error message.</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapClose(System.IntPtr)">
            <summary>
            Closes an adapter
            </summary>
            <param name="AdapterHandle">Handle to the adapter to close.</param>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapGetDeviceCapabilities(System.IntPtr,System.IntPtr@)">
            <summary>
            Get the capabilities of a device
            NOTE: The PCapabilities structure returned by AirpcapGetDeviceCapabilities() must be considered invalid 
            after the adapter has been closed. 
            </summary>
            <param name="AdapterHandle">Handle to the adapter</param>
            <param name="PCapabilities">Pointer to a library-allocated AirpcapDeviceCapabilities structure that contains
            the capabilities of the adapter</param>
            <returns>True on success</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapSetDeviceMacFlags(System.IntPtr,KPCAP.AirPcap.AirPcapMacFlags)">
             <summary>
             Sets the device's monitor mode and acknowledgment settings.
            
             When an adapter is plugged into the system, it's always configured with monitor mode ON and acknowledgment settings OFF.
             These values are not stored persistently, so if you want to turn monitor mode off, you will need to do it 
             every time you attach the adapter.
            
             \note currently, the AirPcap adapter supports frames acknowleging when the adapter is NOT in monitor mode. This means that
             the combinations in which the two flags have the same value will cause AirpcapSetDeviceMacFlags() to fail.
             </summary>
             <param name="AdapterHandle">Handle to the adapter</param>
             <param name="AirpcapMacFlags">Flags word, that contains a bitwise-OR combination of the following flags: \ref AIRPCAP_MF_MONITOR_MODE_ON and \ref AIRPCAP_MF_ACK_FRAMES_ON .</param>
             <returns>TRUE on success</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapGetDeviceMacFlags(System.IntPtr,KPCAP.AirPcap.AirPcapMacFlags@)">
             <summary>
             Gets the device's monitor mode and acknowledgement settings
            
             When an adapter is plugged into the system, it's always configured with monitor mode ON and acknowledgment settings OFF.
             These values are not stored persistently, so if you want to turn monitor mode off, you will need to do it 
             every time you attach the adapter.
             </summary>
             <param name="AdapterHandle">Handle to the adapter</param>
             <param name="PAirpcapMacFlags">User-provided flags word, that will be filled by the function with an OR combination of the 
             following flags: \ref AIRPCAP_MF_MONITOR_MODE_ON and \ref AIRPCAP_MF_ACK_FRAMES_ON.</param>
             <returns>TRUE on success</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapSetLinkType(System.IntPtr,KPCAP.AirPcap.AirPcapLinkTypes)">
             <summary>
             Sets the link type of an adapter
            
             the "link type" determines how the driver will encode the packets captured from the network.
              Aircap supports two link types:
              - \ref AIRPCAP_LT_802_11, to capture 802.11 frames (including control frames) without any
               power information. Look at the "Capture_no_radio" example application in the developer's pack 
               for a reference on how to decode 802.11 frames with this link type.
              - \ref AIRPCAP_LT_802_11_PLUS_RADIO, to capture 802.11 frames (including control frames) with a radiotap header
              that contains power and channel information. More information about the radiotap header can be found in the
              \ref radiotap section. Moreover, the "Capture_radio" example application in 
              the developer's pack can be used as a reference on how to decode 802.11 frames with radiotap headers.
              - \ref AIRPCAP_LT_802_11_PLUS_PPI, to capture 802.11 frames (including control frames) with a Per Packet Information (PPI)
                header that contains per-packet meta information like channel and power information. More details on the PPI header can
                be found in the PPI online documentation (TODO).
             </summary>
             <param name="AdapterHandle"></param>
             <param name="NewLinkType">the "link type", i.e. the format of the frames that will be received from the adapter.</param>
             <returns>TRUE on success</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapGetLinkType(System.IntPtr,KPCAP.AirPcap.AirPcapLinkTypes@)">
             <summary>
             Gets the link type of the specified adapter
                       the "link type" determines how the driver will encode the packets captured from the network.
            
              Aircap supports two link types:
              - \ref AIRPCAP_LT_802_11, to capture 802.11 frames (including control frames) without any
               power information. Look at the "Capture_no_radio" example application in the developer's pack 
               for a reference on how to decode 802.11 frames with this link type.
              - \ref AIRPCAP_LT_802_11_PLUS_RADIO, to capture 802.11 frames (including control frames) with a radiotap header
              that contains power and channel information. More information about the radiotap header can be found int the
              \ref radiotap section. Moreover, the "Capture_radio" example application in 
              the developer's pack can be used as a reference on how to decode 802.11 frames with radiotap headers.
              - \ref AIRPCAP_LT_802_11_PLUS_PPI, to capture 802.11 frames (including control frames) with a Per Packet Information (PPI)
                header that contains per-packet meta information like channel and power information. More details on the PPI header can
                be found in the PPI online documentation (TODO).
             </summary>
             <param name="AdapterHandle">Handle to the adapter</param>
             <param name="PLinkType">Pointer to a caller allocated AirpcapLinkType variable that will contain
             the link type of the adapter</param>
             <returns>TRUE on success</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapSetFcsPresence(System.IntPtr,System.Boolean)">
             <summary>
             Configures the adapter on whether to include the MAC Frame Check Sequence in the captured packets.
            
             In the default configuration, the adapter includes the FCS in the captured packets. The MAC Frame Check Sequence 
              is 4 bytes and is located at the end of the 802.11 packet, with \ref AIRPCAP_LT_802_11, \ref AIRPCAP_LT_802_11_PLUS_RADIO and
              \ref AIRPCAP_LT_802_11_PLUS_PPI link types.
              When the FCS inclusion is turned on, and if the link type is \ref AIRPCAP_LT_802_11_PLUS_RADIO, the radiotap header 
              that precedes each frame has two additional fields at the end: Padding and FCS. These two fields are not present 
              when FCS inclusion is off.
             </summary>
             <param name="AdapterHandle">Handle to the adapter</param>
             <param name="IsFcsPresent">TRUE if the packets should include the FCS, FALSE otherwise</param>
             <returns>TRUE on success</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapGetFcsPresence(System.IntPtr,System.Boolean@)">
             <summary>
             PIsFcsPresent is tue if the specified adapter includes the MAC Frame Check Sequence in the captured packets
            
             In the default configuration, the adapter includes the FCS in the captured packets. The MAC Frame Check Sequence 
             is 4 bytes and is located at the end of the 802.11 packet, with \ref AIRPCAP_LT_802_11, \ref AIRPCAP_LT_802_11_PLUS_RADIO and
             \ref AIRPCAP_LT_802_11_PLUS_PPI link types.
             When the FCS inclusion is turned on, and if the link type is \ref AIRPCAP_LT_802_11_PLUS_RADIO, the radiotap header 
             that precedes each frame has two additional fields at the end: Padding and FCS. These two fields are not present 
             when FCS inclusion is off.
             </summary>
             <param name="AdapterHandle">Handle to the adapter</param>
             <param name="PIsFcsPresent">User-provided variable that will be set to true if the adapter is including the FCS</param>
             <returns>TRUE if the operation is successful. FALSE otherwise.</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapSetFcsValidation(System.IntPtr,KPCAP.AirPcap.AirPcapValidationType)">
             <summary>
             Configures the adapter to accept or drop frames with an incorrect Frame Check sequence (FCS)
            
             NOTE: By default the driver is configured in \ref AIRPCAP_VT_ACCEPT_EVERYTHING mode
             </summary>
             <param name="AdapterHandle">Handle to the adapter</param>
             <param name="ValidationType">The type of validation the driver will perform. See the documentation of \ref AirpcapValidationType for details.</param>
             <returns>TRUE on success</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapGetFcsValidation(System.IntPtr,KPCAP.AirPcap.AirPcapValidationType@)">
             <summary>
             Checks if the specified adapter is configured to capture frames with incorrect an incorrect Frame Check Sequence (FCS). 
            
             \note By default, the driver is configured in \ref AIRPCAP_VT_ACCEPT_EVERYTHING mode.
             </summary>
             <param name="AdapterHandle">Handle to the adapter</param>
             <param name="ValidationType">Pointer to a user supplied variable that will contain the type of validation the driver will perform. See the documentation of \ref AirpcapValidationType for details.</param>
             <returns>TRUE if the operation is successful, FALSE otherwise</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapSetDeviceKeys(System.IntPtr,System.IntPtr)">
             <summary>
             Sets the list of decryption keys that AirPcap is going to use with the specified device.
            
             AirPcap is able to use a set of decryption keys to decrypt the traffic transmitted on a specific SSID. If one of the
             keys corresponds to the one the frame has been encrypted with, the driver will perform decryption and return the cleartext frames
             to the application.
            
             This function allows to set the <b>device-specific</b> set of keys. These keys will be used by the specified device only,
             and will not be used by other airpcap devices besides the specified one. 
            
             At this time, the only supported decryption method is WEP.
            
             The keys are applied to the packets in the same order they appear in the KeysCollection structure until the packet is 
             correctly decrypted, therefore putting frequently used keys at the beginning of the structure improves performance.
            
             \note When you change the set of keys from an open capture instance, the change will be
                     immediately reflected on all the other capture instances on the same device.
             </summary>
             <param name="AdapterHandle">Handle to the adapter</param>
             <param name="KeysCollection">Pointer to a \ref PAirpcapKeysCollection structure that contains the keys to be set in the device.</param>
             <returns>TRUE if the operation is successful. FALSE otherwise.</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapGetDeviceKeys(System.IntPtr,System.IntPtr,System.UInt32@)">
             <summary>
             Returns the list of decryption keys that are currently associated with the specified device
            
             This function returns the <b>device-specific</b> set of keys. These keys are used by the specified device only,
             and not by other airpcap devices besides the specified one. 
            
             AirPcap is able to use a set of decryption keys to decrypt the traffic transmitted on a specific SSID. If one of the
             keys corresponds to the one the frame has been encrypted with, the driver will perform decryption and return the cleartext frames
             to the application. 
             AirPcap supports, for every device, multiple keys at the same time.
            
             The configured decryption keys are device-specific, therefore AirpcapGetDeviceKeys() will return a different set of keys
             when called on different devices.
            
            At this time, the only supported decryption method is WEP.
             </summary>
             <param name="AdapterHandle">Handle to an open adapter</param>
             <param name="KeysCollection">User-allocated PAirpcapKeysCollection structure that will be filled with the keys.</param>
             <param name="PKeysCollectionSize">- \b IN: pointer to a user-allocated variable that contains the length of the KeysCollection structure, in bytes.
                                               - \b OUT: amount of data moved by AirPcap in the buffer pointed by KeysBuffer, in bytes.</param>
             <returns>TRUE if the operation is successful. If an error occurs, the return value is FALSE and KeysCollectionSize is zero. 
             If the provided buffer is too small to contain the keys, the return value is FALSE and KeysCollectionSize contains the
             needed KeysCollection length, in bytes. If the device doesn't have any decryption key configured, the return value is TRUE, and 
             KeysCollectionSize will be zero.</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapSetDriverKeys(System.IntPtr,System.IntPtr)">
             <summary>
             Set the global list of decryption keys that AirPcap is going to use with all the devices.
            
             The AirPcap driver is able to use a set of decryption keys to decrypt the traffic transmitted on a specific SSID. If one of the
             keys corresponds to the one the frame has been encrypted with, the driver will perform decryption and return the cleartext frames
             to the application.
            
             This function allows to set the <b>global</b> set of keys. These keys will be used by all the devices plugged in
             the machine. 
            
             At this time, the only supported decryption method is WEP.
            
             The keys are applied to the packets in the same order they appear in the KeysCollection structure until the packet is 
             correctly decrypted, therefore putting frequently used keys at the beginning of the structure improves performance.
            
             \note When you change the set of keys from an open capture instance, the change will be
             immediately reflected on all the other capture instances.
             </summary>
             <param name="AdapterHandle">Handle to an open adapter</param>
             <param name="KeysCollection">Pointer to a \ref PAirpcapKeysCollection structure that contains the keys to be set globally.</param>
             <returns>TRUE if the operation is successful. FALSE otherwise.</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapGetDriverKeys(System.IntPtr,System.IntPtr,System.UInt32@)">
             <summary>
             Returns the global list of decryption keys that AirPcap is using with all the devices.
            
             This function returns the <b>global</b> set of keys. These keys will be used by all the devices plugged in
             the machine. 
            
             The AirPcap driver is able to use a set of decryption keys to decrypt the traffic transmitted on a specific SSID. If one of the
             keys corresponds to the one the frame has been encrypted with, the driver will perform decryption and return the cleartext frames
             to the application.
            
             At this time, the only supported decryption method is WEP.
             </summary>
             <param name="AdapterHandle">Handle to an adapter</param>
             <param name="KeysCollection">User-allocated PAirpcapKeysCollection structure that will be filled with the keys.</param>
             <param name="PKeysCollectionSize">- \b IN: pointer to a user-allocated variable that contains the length of the KeysCollection structure, in bytes.
                                               - \b OUT: amount of data moved by AirPcap in the buffer pointed by KeysBuffer, in bytes.</param>
             <returns>TRUE if the operation is successful. If an error occurs, the return value is FALSE and KeysCollectionSize is zero. 
             If the provided buffer is too small to contain the keys, the return value is FALSE and KeysCollectionSize contains the
             needed KeysCollection length, in bytes. If no global decryption keys are configured, the return value is TRUE, and 
             KeysCollectionSize will be zero.</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapSetDecryptionState(System.IntPtr,KPCAP.AirPcap.AirPcapDecryptionState)">
             <summary>
             Turns on or off the decryption of the incoming frames with the <b>device-specific</b> keys.
            
             The device-specific decryption keys can be configured with the \ref AirpcapSetDeviceKeys() function.
             \note By default, the driver is configured with \ref AIRPCAP_DECRYPTION_ON.
             </summary>
             <param name="AdapterHandle">Handle to the adapter</param>
             <param name="Enable">Either AIRPCAP_DECRYPTION_ON or AIRPCAP_DECRYPTION_OFF</param>
             <returns>TRUE on success</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapGetDecryptionState(System.IntPtr,KPCAP.AirPcap.AirPcapDecryptionState@)">
             <summary>
             Tells if this open instance is configured to perform the decryption of the incoming frames with the <b>device-specific</b> keys.
            
             The device-specific decryption keys can be configured with the \ref AirpcapSetDeviceKeys() function.
             \note By default, the driver is configured with \ref AIRPCAP_DECRYPTION_ON.
             </summary>
             <param name="AdapterHandle">Handle to the adapter</param>
             <param name="PEnable">Pointer to a user supplied variable that will contain the decryption configuration. See \ref PAirpcapDecryptionState for details.</param>
             <returns>TRUE if the operation is successful, FALSE otherwise</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapSetDriverDecryptionState(System.IntPtr,KPCAP.AirPcap.AirPcapDecryptionState)">
             <summary>
             Turns on or off the decryption of the incoming frames with the <b>global</b> set of keys.
            
             The global decryption keys can be configured with the \ref AirpcapSetDriverKeys() function.
             \note By default, the driver is configured with \ref AIRPCAP_DECRYPTION_ON.
             </summary>
             <param name="AdapterHandle">Handle to the adapter</param>
             <param name="Enable">Either \ref AIRPCAP_DECRYPTION_ON or \ref AIRPCAP_DECRYPTION_OFF</param>
             <returns>TRUE on success</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapGetDriverDecryptionState(System.IntPtr,KPCAP.AirPcap.AirPcapDecryptionState@)">
             <summary>
             Tells if this open instance is configured to perform the decryption of the incoming frames with the <b>global</b> set of keys.
            
             The global decryption keys can be configured with the \ref AirpcapSetDriverKeys() function.
             \note By default, the driver is configured with \ref AIRPCAP_DECRYPTION_ON.
             </summary>
             <param name="AdapterHandle">Handle to the adapter</param>
             <param name="PEnable">Pointer to a user supplied variable that will contain the decryption configuration. See \ref PAirpcapDecryptionState for details.</param>
             <returns>TRUE if the operation is successful. FALSE otherwise.</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapSetDeviceChannel(System.IntPtr,System.UInt32)">
             <summary>
             Sets the radio channel of a device
            
              The list of available channels can be retrieved with \ref AirpcapGetDeviceSupportedChannels(). The default channel setting is 6.
            
             \note This is a device-related function: when you change the channel from an open capture instance, the change will be
             immediately reflected on all the other capture instances.
             </summary>
             <param name="AdapterHandle">Handle to the adapter</param>
             <param name="Channel">The new channel to set</param>
             <returns>TRUE on success</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapGetDeviceChannel(System.IntPtr,System.UInt32@)">
             <summary>
             Gets the radio channel of a device
            
             The list of available channels can be retrieved with \ref AirpcapGetDeviceSupportedChannels(). The default channel setting is 6.
            
             \note This is a device-related function: when you change the channel from an open capture instance, the change will be
             immediately reflected on all the other capture instances.
             </summary>
             <param name="AdapterHandle">Handle to the adapter</param>
             <param name="PChannel">Pointer to a user-supplied variable into which the function will copy the currently configured radio channel.</param>
             <returns>TRUE on success</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapSetDeviceChannelEx(System.IntPtr,KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapChannelInfo)">
             <summary>
             Sets the channel of a device through its radio frequency. In case of 802.11n enabled devices, it sets the extension channel, if used.
            
             \note This is a device-related function: when you change the channel from an open capture instance, the change will be
             immediately reflected on all the other capture instances.
             </summary>
             <param name="AdapterHandle">Handle to the adapter</param>
             <param name="ChannelInfo">The new channel information to set</param>
             <returns>TRUE on success</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapGetDeviceChannelEx(System.IntPtr,KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapChannelInfo@)">
             <summary>
             Gets the channel of a device through its radio frequency. In case of 802.11n enabled devices, it gets the extension channel, if in use.
            
             \note This is a device-related function: when you change the channel from an open capture instance, the change will be
             immediately reflected on all the other capture instances.
             </summary>
             <param name="AdapterHandle">Handle to the adapter</param>
             <param name="PChannelInfo">Pointer to a user-supplied variable into which the function will copy the currently configured channel information.</param>
             <returns>TRUE on success</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapGetDeviceSupportedChannels(System.IntPtr,System.IntPtr@,System.UInt32@)">
             <summary>
             Gets the list of supported channels for a given device. In case of a 802.11n capable device, information related to supported extension channels is also reported. 
            
             Every control channel is listed multiple times, one for each different supported extension channel. For example channel 6 (2437MHz)  is usually listed three times:
              - <b>Frequency 2437 Extension +1</b>. Control channel is 6, extension channel is 10.
              - <b>Frequency 2437 Extension 0</b>. Control channel is 6, no extension channel is used (20MHz channel and legacy mode).
              - <b>Frequency 2437 Extension -1</b>. Control channel is 6, extension channel is 2.
            
             \note The supported channels are not listed in any specific order.
             </summary>
             <param name="AdapterHandle">Handle to the adapter</param>
             <param name="ppChannelInfo">Pointer to a user-supplied variable that will point to an array of supported channel. Such list must not be freed by the caller</param>
             <param name="pNumChannelInfo">Number of channels returned in the array</param>
             <returns>TRUE on success</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapConvertFrequencyToChannel(System.UInt32,System.UInt32@,System.UInt32@)">
            <summary>
            Converts a frequency to the corresponding channel
            </summary>
            <param name="Frequency">Frequency of the channel in MHz</param>
            <param name="PChannel">Pointer to a user-supplied variable that will contain the channel number on success</param>
            <param name="PBand">Pointer to a user-supplied variable that will contain the band (a orb/g) of the given channel</param>
            <returns>TRUE on success, i.e. the frequency corresponds to a valid a or b/g channel</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapConvertChannelToFrequency(System.UInt32,System.UInt32@)">
            <summary>
            Converts a given channel to the corresponding frequency
             Because of the overlap of channels with respect to 1-14BG and 1-14A, this function will give precidence to BG.
             Thus, the channels are returned as follows:
               - <b>Channel 0:</b> 5000MHz
               - <b>Channels 1-14:</b> 2412MHz - 2484MHz
               - <b>Channels 15-239:</b> 5005MHz - 6195MHz
               - <b>Channels 240-255:</b> 4920MHz - 4995MHz
            </summary>
            <param name="Channel">Channel number to be converted</param>
            <param name="PFrequency">Pointer to a user-supplied variable that will contain the channel frequency in MHz on success></param>
            <returns></returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapSetKernelBuffer(System.IntPtr,System.UInt32)">
             <summary>
             Sets the size of the kernel packet buffer for this adapter
            
             Every AirPcap open instance has an associated kernel buffer, whose default size is 1 Mbyte.
             This function can be used to change the size of this buffer, and can be called at any time.
             A bigger kernel buffer size decreases the risk of dropping packets during network bursts or when the
             application is busy, at the cost of higher kernel memory usage.
            
             \note Don't use this function unless you know what you are doing. Due to caching issues and bigger non-paged
             memory consumption, bigger buffer sizes can decrease the capture performace instead of improving it.
             </summary>
             <param name="AdapterHandle">Handle to the adapter</param>
             <param name="BufferSize">New size in bytes</param>
             <returns>TRUE on success</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapGetKernelBufferSize(System.IntPtr,System.UInt32@)">
             <summary>
             Gets the size of the kernel packet buffer for this adapter
            
             Every AirPcap open instance has an associated kernel buffer, whose default size is 1 Mbyte.
             This function can be used to get the size of this buffer.
             </summary>
             <param name="AdapterHandle">Handle to the adapter</param>
             <param name="PSizeBytes">User-allocated variable that will be filled with the size of the kernel buffer.</param>
             <returns>TRUE on success</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapSetTxPower(System.IntPtr,System.UInt32)">
             <summary>
             Sets the power of the frames transmitted by adapter
            
             The transmit power value is monotonically increasing with higher power levels. 1 is the minimum allowed transmit power.
            
             \note The maximum transmit power on each channel is limited by FCC regulations. Therefore, the maximum transmit power
             changes from channel to channel. When the channel is changed with \ref AirpcapSetDeviceChannel() or 
             \ref AirpcapSetDeviceChannelEx() the power is set to the maximum allowd value for that channel. You can read this
             value with \ref AirpcapGetTxPower(). Not all the AirPcap adapters support setting the transmit power; you can use
              \ref AirpcapGetDeviceCapabilities() to find if the current adapter supports this feature.
             </summary>
             <param name="AdapterHandle">Handle to the adapter</param>
             <param name="Power">The transmit power. Setting a zero power makes the adapter select the
             highest possible power for the current channel.</param>
             <returns>TRUE on success. False on failure or if the adapter doesn't support setting the transmit power.</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapGetTxPower(System.IntPtr,System.UInt32@)">
             <summary>
             Returns the current transmit power level of the adapter
            
             The transmit power value is monotonically increasing with higher power levels. 0 is the minimum allowed power.
             \note The maximum transmit power on each channel is limited by FCC regulations. Therefore, the maximum transmit power
             changes from channel to channel. When the channel is changed with \ref AirpcapSetDeviceChannel() or 
             \ref AirpcapSetDeviceChannelEx() the power is set to the maximum allowd value for that channel. Not all the AirPcap 
             adapters support setting the transmit power; you can use \ref AirpcapGetDeviceCapabilities() to find if the current 
            adapter supports this feature.
            
             </summary>
             <param name="AdapterHandle">Handle to the adapter</param>
             <param name="PPower">User-allocated variable that will be filled with the size of the transmit power</param>
             <returns>TRUE on success, false on failure or if the adapter doesn't support getting the transmit power</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapStoreCurConfigAsAdapterDefault(System.IntPtr)">
             <summary>
             Saves the configuration of the specified adapter in the registry, so that it becomes the default for this adapter.
            
             Almost all the AirPcap calls that modify the configuration (\ref AirpcapSetLinkType(), \ref AirpcapSetFcsPresence(), 
             \ref AirpcapSetFcsValidation(), \ref AirpcapSetKernelBuffer(), \ref AirpcapSetMinToCopy())
             affect only the referenced AirPcap open instance. This means that if you do another \ref AirpcapOpen() on the same
             adapter, the configuration changes will not be remembered, and the new adapter handle will have default configuration
             settings.
            
             Exceptions to this rule are the \ref AirpcapSetDeviceChannel() and \ref AirpcapSetDeviceKeys() functions: a channel change is 
             reflected on all the open instances, and remembered until the next call to \ref AirpcapSetDeviceChannel(), until the adapter 
             is unplugged, or until the machine is powered off. Same thing for the configuration of the WEP keys.
            
             AirpcapStoreCurConfigAsAdapterDefault() stores the configuration of the give open instance as the default for the adapter: 
             all the instances opened in the future will have the same configuration that this adapter currently has.
             The configuration is stored in the registry, therefore it is remembered even when the adapter is unplugged or the
             machine is turned off. However, an adapter doesn't bring its configuration with it from machine to machine.
            
             the configuration information saved in the registry includes the following parameters:
              - channel
              - kernel buffer size
              - mintocopy
              - link type
              - CRC presence
              - Encryption keys
              - Encryption Enabled/Disabled state
            
             The configuration is device-specific. This means that changing the configuration of a device
             doesn't modify the one of the other devices that are currently used or that will be used in the future.
            
             \note AirpcapStoreCurConfigAsAdapterDefault() must have exclusive access to the adapter -- it 
             will fail if more than one AirPcap handle is opened at the same time for this device. 
             AirpcapStoreCurConfigAsAdapterDefault() needs administrator privileges. It will fail if the calling user
             is not a local machine administrator.
             </summary>
             <param name="AdapterHandle">Handle to an adapter</param>
             <returns>TRUE on success. FALSE on failure.</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapSetFilter(System.IntPtr,System.IntPtr,System.UInt32)">
             <summary>
             Sets the BPF kernel filter for an adapter
            
             The AirPcap driver is able to perform kernel-level filtering using the standard BPF pseudo-machine format. You can read
             the WinPcap documentation at http://www.winpcap.org/devel.htm for more details on the BPF filtering mechaism.
            
             A filter can be automatically created by using the pcap_compile() function of the WinPcap API. This function 
             converts a human readable text expression with the tcpdump/libpcap syntax into a BPF program. 
             If your program doesn't link wpcap, but you need to generate the code for a particular filter, you can run WinDump 
             with the -d or -dd or -ddd flags to obtain the pseudocode.
             </summary>
             <param name="AdapterHandle">Handle to the adapter</param>
             <param name="Instructions"> pointer to the first BPF instruction in the array. Corresponds to the  bf_insns 
             in a bpf_program structure (see the WinPcap documentation at http://www.winpcap.org/devel.htm).
             \param Len Number of instructions in the array pointed by the previous field. Corresponds to the bf_len in
             a a bpf_program structure (see the WinPcap documentation at http://www.winpcap.org/devel.htm).</param>
             <param name="Len"></param>
             <returns>TRUE on success</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapGetMacAddress(System.IntPtr,System.IntPtr)">
            <summary>
            Returns the MAC address of a device
            </summary>
            <param name="AdapterHandle">Handle to the adapter</param>
            <param name="PMacAddress">Pointer to a user allocated \ref AirpcapMacAddress structure that will receive the MAC address on success. </param>
            <returns>TRUE on success</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapSetMacAddress(System.IntPtr,System.IntPtr)">
             <summary>
             Sets the MAC address of a device
            
             Using this function, the programmer can change the MAC address of the device. This is useful when disabling monitor
             mode with \ref AirpcapSetDeviceMacFlags(), because the device will acknowledge the data frames sent to its MAC address.
            
             \note The address change is temporary: when the device is unplugged or when the host PC is turned off, the address is reset to the original
             value.
             </summary>
             <param name="AdapterHandle">Handle to the adapter</param>
             <param name="PMacAddress">Pointer to a user-initialized structure containing the MAC address</param>
             <returns>TRUE on success. FALSE on failure, or if the adapter doesn't support changing the address.</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapSetMinToCopy(System.IntPtr,System.UInt32)">
             <summary>
             Sets the mintocopy parameter for an open adapter
            
             When the number of bytes in the kernel buffer changes from less than mintocopy bytes to greater than or equal to mintocopy bytes, 
             the read event is signalled (see \ref AirpcapGetReadEvent()). A high value for mintocopy results in poor responsiveness since the
             driver may signal the application "long" after the arrival of the packet. And a high value results in low CPU loading
             by minimizing the number of user/kernel context switches. 
             A low MinToCopy results in good responsiveness since the driver will signal the application close to the arrival time of
              the packet. This has higher CPU loading over the first approach.
             </summary>
             <param name="AdapterHandle">Handle to the adapter</param>
             <param name="MinToCopy">is the mintocopy size in bytes</param>
             <returns>TRUE on success</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapGetReadEvent(System.IntPtr,System.IntPtr@)">
            <summary>
            Gets an event that is signalled when packets are available in the kernel buffer (see \ref AirpcapSetMinToCopy()).
             \note The event is signalled when at least mintocopy bytes are present in the kernel buffer (see \ref AirpcapSetMinToCopy()). 
             This event can be used by WaitForSingleObject() and WaitForMultipleObjects() to create blocking behavior when reading 
             packets from one or more adapters (see \ref AirpcapRead()).
            </summary>
            <param name="AdapterHandle">Handle to the adapter</param>
            <param name="PReadEvent">Pointer to a user-supplied handle in which the read event will be copied.</param>
            <returns>TRUE on success</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapRead(System.IntPtr,System.IntPtr,System.UInt32,System.UInt32@)">
             <summary>
             Fills a user-provided buffer with zero or more packets that have been captured on the referenced adapter.
            
             802.11 frames are returned by the driver in buffers. Every 802.11 frame in the buffer is preceded by a \ref AirpcapBpfHeader structure.
             The suggested way to use an AirPcap adapter is through the pcap API exported by wpcap.dll. If this is not
             possible, the Capture_radio and Capture_no_radio examples in the AirPcap developer's pack show how to properly decode the 
             packets in the read buffer returned by AirpcapRead().
            
             \note This function is NOT blocking. Blocking behavior can be obtained using the event returned
             by \ref AirpcapGetReadEvent(). See also \ref AirpcapSetMinToCopy().
             </summary>
             <param name="AdapterHandle">Handle to the adapter</param>
             <param name="Buffer">pointer to the buffer that will be filled with captured packets.</param>
             <param name="BufSize">size of the input buffer that will contain the packets, in bytes.</param>
             <param name="PReceievedBytes">Pointer to a user supplied variable that will receive the number of bytes copied by AirpcapRead. 
             Can be smaller than BufSize.</param>
             <returns>TRUE on success</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapWrite(System.IntPtr,System.IntPtr,System.UInt32)">
             <summary>
             Transmits a packet
            
             The packet will be transmitted on the channel the device is currently set. To change the device adapter, use the 
             \ref AirpcapSetDeviceChannel() function.
            
             If the link type of the adapter is AIRPCAP_LT_802_11, the buffer pointed by TxPacket should contain just the 802.11
             packet, without additional information. The packet will be transmitted at 1Mbps.
            
             If the link type of the adapter is AIRPCAP_LT_802_11_PLUS_RADIO, the buffer pointed by TxPacket should contain a radiotap
             header followed by the 802.11 packet. AirpcapWrite will use the rate information in the radiotap header when
             transmitting the packet.
            
             If the link type of the adapter is AIRPCAP_LT_802_11_PLUS_PPI, the buffer pointed by TxPacket should contain a PPI header 
             followed by the 802.11 packet. AirpcapWrite will use the rate information in the PPI header when transmitting the packet.
             If the packet should be transmitted at a 802.11n rate, the packet must include a PPI 802.11n MAC+PHY Extension header, containing
             the rate expressed in terms of MCS, short/long guard interval (SGI/LGI) and 20MHz or 40MHz channel. When the MAC+PHY Extension header is present,
             the rate field in the PPI 802.11-Common header is ignored.
             By default on 802.11n-capable AirPcap adapters, packets are transmitted with no A-MPDU aggregation. A-MPDU aggregation is controlled by the
             adapter, but it's possible to give a hint to the hardware to aggregate some packets by setting the "Aggregate" and "More aggregates" flags in 
             the PPI 802.11n MAC+PHY extension header.
            
             </summary>
             <param name="AdapterHandle">Handle to the adapter</param>
             <param name="TxPacket">Pointer to a buffer that contains the packet to be transmitted.</param>
             <param name="PacketLen">Length of the buffer pointed by the TxPacket argument, in bytes</param>
             <returns>TRUE on success</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapGetStats(System.IntPtr,System.IntPtr)">
            <summary>
            Gets per-adapter WinPcap-compatible capture statistics.
            </summary>
            <param name="AdapterHandle">Handle to the adapter</param>
            <param name="PStats">Pointer to a user-allocated AirpcapStats structure that will be filled with statistical information.</param>
            <returns>TRUE on success</returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapGetLedsNumber(System.IntPtr,System.UInt32@)">
            <summary>
            Gets the number of LEDs the referenced adapter has available
            </summary>
            <param name="AdapterHandle">Handle to the adapter</param>
            <param name="NumberOfLeds">Number of LEDs available on this adapter</param>
            <returns></returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapTurnLedOn(System.IntPtr,System.UInt32)">
            <summary>
            Turns on one of the adapter's LEDs.
            </summary>
            <param name="AdapterHandle">Handle to the adapter</param>
            <param name="LedNumber">Zero-based identifier of the LED to turn on</param>
            <returns></returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapTurnLedOff(System.IntPtr,System.UInt32)">
            <summary>
            Turns off one of the adapter's LEDs.
            </summary>
            <param name="AdapterHandle">Handle to the adapter</param>
            <param name="LedNumber">Zero-based identifier of the LED to turn off.</param>
            <returns></returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapSafeNativeMethods.AirpcapGetDeviceTimestamp(System.IntPtr,System.IntPtr)">
            <summary>
            Gets the current value of the device counter used to timestamp packets.
            </summary>
            <param name="AdapterHandle">Handle to the adapter</param>
            <param name="PTimestamp">Pointer to a caller allocated 64bit integer that will receive the device
            timestamp, in microseconds.</param>
            <returns>TRUE on success</returns>
        </member>
        <member name="T:KPCAP.AirPcap.AirPcapDecryptionState">
            <summary>
            Type of decryption the adapter performs.
            An adapter can be instructed to turn decryption (based on the device-configured keys configured 
            with \ref AirpcapSetDeviceKeys()) on or off.
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapDecryptionState.DecryptionOn">
            <summary>This adapter performs decryption</summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapDecryptionState.DecryptionOff">
            <summary>This adapter does not perform decryption</summary>
        </member>
        <member name="T:KPCAP.AirPcap.AirPcapBands">
            <summary>
            Frequency bands
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapBands._2GHZ">
            <summary>2.4 GHz band</summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapBands._5GHZ">
            <summary>5 GHz band</summary>
        </member>
        <member name="T:KPCAP.PacketArrivalEventHandler">
            <summary>A delegate for Packet Arrival events</summary>
        </member>
        <member name="T:KPCAP.LibPcap.PcapDevice">
            <summary>
            Base class for all pcap devices
            </summary>
        </member>
        <member name="F:KPCAP.LibPcap.PcapDevice.captureThread">
            <summary>
            Thread that is performing the background packet capture
            </summary>
        </member>
        <member name="F:KPCAP.LibPcap.PcapDevice.shouldCaptureThreadStop">
            <summary>
            Flag that indicates that a capture thread should stop
            </summary>
        </member>
        <member name="F:KPCAP.LibPcap.PcapDevice.MonoUnixFound">
            <summary>
            If Environment.OSVersion.Platform is unix and MonoUnixFound is true
            then we can support proper termination of the capture loop
            </summary>
            <returns>
            A <see cref="T:System.Boolean"/>
            </returns>
        </member>
        <member name="M:KPCAP.LibPcap.PcapDevice.UnixSetupMonoUnixNative">
            <summary>
            Setup the reflection type and methodinfo for invocation of
            Mono.Unix.Native.Syscall.poll() to avoid timeouts when
            stopping the capture thread
            </summary>
        </member>
        <member name="M:KPCAP.LibPcap.PcapDevice.StartCapture">
            <summary>
            Starts the capturing process via a background thread
            OnPacketArrival() will be called for each captured packet
            </summary>
        </member>
        <member name="M:KPCAP.LibPcap.PcapDevice.StopCapture">
             <summary>
             Stops the capture process
            
             Throws an exception if the stop capture timeout is exceeded and the
             capture thread was aborted
             </summary>
        </member>
        <member name="M:KPCAP.LibPcap.PcapDevice.Capture">
            <summary>
            Synchronously capture packets on this device. Method blocks forever.
            </summary>
        </member>
        <member name="M:KPCAP.LibPcap.PcapDevice.Capture(System.Int32)">
            <summary>
            Synchronously captures packets on this network device. This method will block
            until capturing is finished.
            </summary>
            <param name="packetCount">The number of packets to be captured.
            -1 means capture indefiniately</param>
        </member>
        <member name="M:KPCAP.LibPcap.PcapDevice.CaptureThread">
            <summary>
            The capture thread
            </summary>
        </member>
        <member name="F:KPCAP.LibPcap.PcapDevice.m_pcapIf">
            <summary>
            Low level interface object that contains device specific information
            </summary>
        </member>
        <member name="F:KPCAP.LibPcap.PcapDevice.m_pcapDumpHandle">
            <summary>
            Handle to an open dump file, not equal to IntPtr.Zero if a dump file is open
            </summary>
        </member>
        <member name="F:KPCAP.LibPcap.PcapDevice.m_pcapAdapterHandle">
            <summary>
            Handle to a pcap adapter, not equal to IntPtr.Zero if an adapter is open
            </summary>
        </member>
        <member name="F:KPCAP.LibPcap.PcapDevice.m_pcapPacketCount">
            <summary>
            Number of packets that this adapter should capture
            </summary>
        </member>
        <member name="M:KPCAP.LibPcap.PcapDevice.GetLastError(System.IntPtr)">
            <summary>
            Retrieve the last error string for a given pcap_t* device
            </summary>
            <param name="deviceHandle">
            A <see cref="T:System.IntPtr"/>
            </param>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="M:KPCAP.LibPcap.PcapDevice.Open">
            <summary>
            Open the device with class specific options
            </summary>
        </member>
        <member name="M:KPCAP.LibPcap.PcapDevice.Open(KPCAP.DeviceMode)">
            <summary>
            Open the device. To start capturing call the 'StartCapture' function
            </summary>
            <param name="mode">
            A <see cref="T:KPCAP.DeviceMode"/>
            </param>
        </member>
        <member name="M:KPCAP.LibPcap.PcapDevice.Open(KPCAP.DeviceMode,System.Int32)">
            <summary>
            Open the device. To start capturing call the 'StartCapture' function
            </summary>
            <param name="mode">
            A <see cref="T:KPCAP.DeviceMode"/>
            </param>
            <param name="read_timeout">
            A <see cref="T:System.Int32"/>
            </param>
        </member>
        <member name="M:KPCAP.LibPcap.PcapDevice.Close">
            <summary>
            Closes this adapter
            </summary>
        </member>
        <member name="M:KPCAP.LibPcap.PcapDevice.SendPacketArrivalEvent(Kavprot.Packets.RawPacket)">
            <summary>
            Notify the OnPacketArrival delegates about a newly captured packet
            </summary>
            <param name="p">
            A <see cref="T:Kavprot.Packets.RawPacket"/>
            </param>
        </member>
        <member name="M:KPCAP.LibPcap.PcapDevice.SendCaptureStoppedEvent(KPCAP.CaptureStoppedEventStatus)">
            <summary>
            Notify the delegates that are subscribed to the capture stopped event
            </summary>
            <param name="status">
            A <see cref="T:KPCAP.CaptureStoppedEventStatus"/>
            </param>
        </member>
        <member name="M:KPCAP.LibPcap.PcapDevice.GetNextPacket">
            <summary>
            Gets the next packet captured on this device
            </summary>
            <returns>The next packet captured on this device</returns>
        </member>
        <member name="M:KPCAP.LibPcap.PcapDevice.GetNextPacket(Kavprot.Packets.RawPacket@)">
            <summary>
            Gets the next packet captured on this device
            </summary>
            <param name="p">
            A <see cref="T:Kavprot.Packets.RawPacket"/>
            </param>
            <returns>
            A <see cref="T:System.Int32"/> that contains the result code
            </returns>
        </member>
        <member name="M:KPCAP.LibPcap.PcapDevice.PacketHandler(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Pcap_loop callback method.
            </summary>
        </member>
        <member name="M:KPCAP.LibPcap.PcapDevice.MarshalRawPacket(System.IntPtr,System.IntPtr)">
            <summary>
            Convert an unmanaged packet into a managed Kavprot.Packets.RawPacket
            </summary>
            <param name="header">
            A <see cref="T:System.IntPtr"/>
            </param>
            <param name="data">
            A <see cref="T:System.IntPtr"/>
            </param>
            <returns>
            A <see cref="T:Kavprot.Packets.RawPacket"/>
            </returns>
        </member>
        <member name="M:KPCAP.LibPcap.PcapDevice.DumpOpen(System.String)">
            <summary>
            Opens a file for packet writings
            </summary>
            <param name="fileName"></param>
        </member>
        <member name="M:KPCAP.LibPcap.PcapDevice.DumpClose">
            <summary>
            Closes the opened dump file
            </summary>
        </member>
        <member name="M:KPCAP.LibPcap.PcapDevice.DumpFlush">
            <summary>
            Flushes all write buffers of the opened dump file
            </summary>
        </member>
        <member name="M:KPCAP.LibPcap.PcapDevice.Dump(System.Byte[],KPCAP.LibPcap.PcapHeader)">
            <summary>
            Writes a packet to the pcap dump file associated with this device.
            </summary>
        </member>
        <member name="M:KPCAP.LibPcap.PcapDevice.Dump(System.Byte[])">
            <summary>
            Writes a packet to the pcap dump file associated with this device.
            </summary>
            <param name="p">The packet to write</param>
        </member>
        <member name="M:KPCAP.LibPcap.PcapDevice.Dump(Kavprot.Packets.RawPacket)">
            <summary>
            Writes a packet to the pcap dump file associated with this device.
            </summary>
            <param name="p">The packet to write</param>
        </member>
        <member name="M:KPCAP.LibPcap.PcapDevice.SetFilter(System.String)">
            <summary>
            Assign a filter to this device given a filterExpression
            </summary>
            <param name="filterExpression">The filter expression to compile</param>
        </member>
        <member name="M:KPCAP.LibPcap.PcapDevice.CompileFilter(System.IntPtr,System.String,System.UInt32,System.IntPtr@,System.String@)">
            or unmanaged memory will be leaked
        </member>
        <member name="M:KPCAP.LibPcap.PcapDevice.FreeBpfProgram(System.IntPtr)">
            <summary>
            Free memory allocated in CompileFilter()
            </summary>
            <param name="bpfProgram">
            A <see cref="T:System.IntPtr"/>
            </param>
        </member>
        <member name="M:KPCAP.LibPcap.PcapDevice.CheckFilter(System.String,System.String@)">
            <summary>
            Returns true if the filter expression was able to be compiled into a
            program without errors
            </summary>
        </member>
        <member name="M:KPCAP.LibPcap.PcapDevice.SendPacket(Kavprot.Packets.Packet)">
            <summary>
            Sends a raw packet throgh this device
            </summary>
            <param name="p">The packet to send</param>
        </member>
        <member name="M:KPCAP.LibPcap.PcapDevice.SendPacket(Kavprot.Packets.Packet,System.Int32)">
            <summary>
            Sends a raw packet throgh this device
            </summary>
            <param name="p">The packet to send</param>
            <param name="size">The number of bytes to send</param>
        </member>
        <member name="M:KPCAP.LibPcap.PcapDevice.SendPacket(System.Byte[])">
            <summary>
            Sends a raw packet throgh this device
            </summary>
            <param name="p">The packet bytes to send</param>
        </member>
        <member name="M:KPCAP.LibPcap.PcapDevice.SendPacket(System.Byte[],System.Int32)">
            <summary>
            Sends a raw packet throgh this device
            </summary>
            <param name="p">The packet bytes to send</param>
            <param name="size">The number of bytes to send</param>
        </member>
        <member name="M:KPCAP.LibPcap.PcapDevice.ThrowIfNotOpen(System.String)">
            <summary>
            Helper method for checking that the adapter is open, throws an
            exception with a string of ExceptionString if the device isn't open
            </summary>
            <param name="ExceptionString">
            A <see cref="T:System.String"/>
            </param>
        </member>
        <member name="M:KPCAP.LibPcap.PcapDevice.ToString">
            <summary>
            Override the default ToString() implementation
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:KPCAP.LibPcap.PcapDevice.Started">
            <summary>
            Return a value indicating if the capturing process of this adapter is started
            </summary>
        </member>
        <member name="P:KPCAP.LibPcap.PcapDevice.StopCaptureTimeout">
            <summary>
            Maximum time within which the capture thread must join the main thread (on 
            <see cref="M:KPCAP.LibPcap.PcapDevice.StopCapture"/>) or else the thread is aborted and an exception thrown.
            </summary>
        </member>
        <member name="P:KPCAP.LibPcap.PcapDevice.Name">
            <summary>
            Device name
            </summary>
        </member>
        <member name="P:KPCAP.LibPcap.PcapDevice.Description">
            <summary>
            Description
            </summary>
        </member>
        <member name="E:KPCAP.LibPcap.PcapDevice.OnPacketArrival">
            <summary>
            Fires whenever a new packet is processed, either when the packet arrives
            from the network device or when the packet is read from the on-disk file.<br/>
            For network captured packets this event is invoked only when working in "PcapMode.Capture" mode.
            </summary>
        </member>
        <member name="E:KPCAP.LibPcap.PcapDevice.OnCaptureStopped">
            <summary>
            Fired when the capture process of this pcap device is stopped
            </summary>
        </member>
        <member name="P:KPCAP.LibPcap.PcapDevice.Interface">
            <value>
            Low level pcap device values
            </value>
        </member>
        <member name="P:KPCAP.LibPcap.PcapDevice.Opened">
            <summary>
            Return a value indicating if this adapter is opened
            </summary>
        </member>
        <member name="P:KPCAP.LibPcap.PcapDevice.DumpOpened">
            <summary>
            Gets a value indicating wether pcap dump file is already associated with this device
            </summary>
        </member>
        <member name="P:KPCAP.LibPcap.PcapDevice.PcapHandle">
            <summary>
            The underlying pcap device handle
            </summary>
        </member>
        <member name="P:KPCAP.LibPcap.PcapDevice.LastError">
            <summary>
            The last pcap error associated with this pcap device
            </summary>
        </member>
        <member name="P:KPCAP.LibPcap.PcapDevice.LinkType">
            <summary>
            Link type in terms of Kavprot.Packets.LinkLayers
            </summary>
        </member>
        <member name="P:KPCAP.LibPcap.PcapDevice.Statistics">
            <summary>
            Retrieves pcap statistics
            </summary>
            <returns>
            A <see cref="T:KPCAP.LibPcap.PcapStatistics"/>
            </returns>
        </member>
        <member name="P:KPCAP.LibPcap.PcapDevice.Filter">
            <summary>
            Kernel level filtering expression associated with this device.
            For more info on filter expression syntax, see:
            http://www.winpcap.org/docs/docs31/html/group__language.html
            </summary>
        </member>
        <member name="T:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapChannelInfo">
            <summary>
            Channel information
            Used by \ref AirpcapSetDeviceChannelEx(), \ref AirpcapGetDeviceChannelEx(), \ref AirpcapGetDeviceSupportedChannels()
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapChannelInfo.Frequency">
            <summary>
            Channel frequency, in MHz
            UINT
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapChannelInfo.ExtChannel">
             <summary>
             802.11n specific. Offset of the extension channel in case of 40MHz channels. 
            
             Possible values are -1, 0 +1:
             - -1 means that the extension channel should be below the control channel (e.g. Control = 5 and Extension = 1)
             - 0 means that no extension channel should be used (20MHz channels or legacy mode)
             - +1 means that the extension channel should be above the control channel (e.g. Control = 1 and Extension = 5)
            
             In case of 802.11a/b/g channels (802.11n legacy mode), this field should be set to 0.
            
             CHAR
             </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapChannelInfo.Flags">
            <summary>
            Channel Flags. The only flag supported at this time is \ref AIRPCAP_CIF_TX_ENABLED.
            UCHAR
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapChannelInfo.Reserved1">
            <summary>
            Reserved. It should be set to {0,0}.
            </summary>
        </member>
        <member name="T:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapStats">
            <summary>
            Capture statistics
            Returned by AirpcapGetStats()
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapStats.Recvs">
            <summary>
             Number of packets that the driver received by the adapter 
             from the beginning of the current capture. This value includes the packets 
             dropped because of buffer full.
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapStats.Drops">
            <summary>
             Number of packets that the driver dropped from the beginning of a capture.
             A packet is lost when the the buffer of the driver is full. 
             </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapStats.IfDrops">
            <summary>
            Packets dropped by the card before going to the USB bus. 
            Not supported at the moment.
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapStats.Capt">
            <summary>
            Number of packets that pass the BPF filter, find place in the kernel buffer and
            therefore reach the application.
            </summary>
        </member>
        <member name="T:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapDeviceCapabilities">
            <summary>
            Device capabilities
            Returned by AirpcapGetDeviceCapabilities()
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapDeviceCapabilities.AdapterId">
            <summary>
            An id that identifies the adapter model
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapDeviceCapabilities.AdapterModelName">
            <summary>
            String containing a printable adapter model
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapDeviceCapabilities.AdapterBus">
            <summary>
            The type of bus the adapter is plugged to
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapDeviceCapabilities.CanTransmit">
            <summary>
            TRUE if the adapter is able to perform frame injection.
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapDeviceCapabilities.CanSetTransmitPower">
            <summary>
            TRUE if the adapter's transmit power is can be specified by the user application.
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapDeviceCapabilities.ExternalAntennaPlug">
            <summary>
            TRUE if the adapter supports plugging one or more external antennas.
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapDeviceCapabilities.SupportedMedia">
            <summary>
            An OR combination of the media that the device supports. Possible values are: \ref AIRPCAP_MEDIUM_802_11_A,
            \ref AIRPCAP_MEDIUM_802_11_B, \ref AIRPCAP_MEDIUM_802_11_G or \ref AIRPCAP_MEDIUM_802_11_N.
            Not supported at the moment.
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapDeviceCapabilities.SupportedBands">
            <summary>
            An OR combination of the bands that the device supports. Can be one of: \ref AIRPCAP_BAND_2GHZ, 
            \ref AIRPCAP_BAND_5GHZ.
            </summary>
        </member>
        <member name="T:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapKey">
            <summary>
            WEB key container
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapKey.KeyType">
            <summary>
            Type of key, can be on of: \ref AIRPCAP_KEYTYPE_WEP, \ref AIRPCAP_KEYTYPE_TKIP, \ref AIRPCAP_KEYTYPE_CCMP. Only AIRPCAP_KEYTYPE_WEP is supported by the driver at the moment.
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapKey.KeyLen">
            <summary>
            Length of the key in bytes
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapKey.KeyData">
            <summary>
            Key data
            </summary>
        </member>
        <member name="T:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapChannelBand">
            <summary>
            frequency Band.
            802.11 adapters can support different frequency bands, the most important of which are: 2.4GHz (802.11b/g/n) 
            and 5GHz (802.11a/n).
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapChannelBand.AIRPCAP_CB_AUTO">
            <summary>Automatically pick the best frequency band</summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapChannelBand.AIRPCAP_CB_2_4_GHZ">
            <summary>2.4 GHz frequency band</summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapChannelBand.AIRPCAP_CB_4_GHZ">
            <summary>4 GHz frequency band</summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapChannelBand.AIRPCAP_CB_5_GHZ">
            <summary>5 GHz frequency band</summary>
        </member>
        <member name="T:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapDeviceDescription">
            <summary>
            Entry in the list returned by \ref AirpcapGetDeviceList().
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapDeviceDescription.next">
            <summary>
            Next element in the list
            struct _AirpcapDeviceDescription*
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapDeviceDescription.Name">
            <summary>
            Device name
            PCHAR
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapDeviceDescription.Description">
            <summary>
            Device description
            PCHAR
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapKeysCollection.nKeys">
            <summary>
            Number of keys in the collection
            </summary>
        </member>
        <member name="T:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapBpfHeader">
            <summary>
            Packet header
            This structure defines the BPF that preceeds every packet delivered to the application
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapBpfHeader.TsSec">
            <summary>
            Timestamp associated with the captured packet. SECONDS.
            UINT
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapBpfHeader.TsUsec">
            <summary>
            Timestamp associated with the captured packet. MICROSECONDS.
            UINT
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapBpfHeader.Caplen">
            <summary>
            Length of captured portion. The captured portion <b>can be different</b> from the original packet, because it is possible (with a proper filter) to instruct the driver to capture only a portion of the packets.
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapBpfHeader.Originallen">
            <summary>
            Original length of packet
            UINT
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapBpfHeader.Hdrlen">
            <summary>
            Length of bpf header (this struct plus alignment padding). In some cases, a padding could be added between the end of this structure and the packet data for performance reasons. This field can be used to retrieve the actual data of the packet.
            USHORT
            </summary>
        </member>
        <member name="T:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapDeviceTimestamp">
             <summary>
             Structure used to read the free running counter on a device
            
             This structure contains the current value of the counter used by the device to timestamp packets (when the hardware supports hardware timestamps). 
             This structure also contains the value of the software counter (used to timestamp packets in software), before and after the hardware counter is read
             on the device.
             </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapDeviceTimestamp.DeviceTimestamp">
            <summary>Current value of the device counter, in microseconds.</summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapDeviceTimestamp.SoftwareTimestampBefore">
            <summary>Value of the software counter used to timestamp packets before reading the device counter, in microseconds.</summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapUnmanagedStructures.AirpcapDeviceTimestamp.SoftwareTimestampAfter">
            <summary>Value of the software counter used to timestamp packets after reading the device counter, in microseconds.</summary>
        </member>
        <member name="T:KPCAP.AirPcap.AirPcapAdapterId">
            <summary>
            Types of airpcap adapters
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapAdapterId.Classic">
            <summary>
            Class
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapAdapterId.ClassicRelease2">
            <summary>
            Class release 2
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapAdapterId.Tx">
            <summary>
            AirPcap TX
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapAdapterId.Ex">
            <summary>
            AirPcap EX
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapAdapterId.N">
            <summary>
            AirPcap N
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapAdapterId.Nx">
            <summary>
            AirPcap Nx
            </summary>
        </member>
        <member name="T:KPCAP.WinPcap.StatisticsModePacket">
            <summary>
            Holds network statistics entry from winpcap when in statistics mode
            See http://www.winpcap.org/docs/docs_41b5/html/group__wpcap__tut9.html
            </summary>
        </member>
        <member name="F:KPCAP.WinPcap.StatisticsModePacket.m_pktData">
            <summary>
            This holds byte received and packets received
            </summary>
        </member>
        <member name="P:KPCAP.WinPcap.StatisticsModePacket.Timeval">
            <summary>
            This holds time value
            </summary>
        </member>
        <member name="P:KPCAP.WinPcap.StatisticsModePacket.RecievedPackets">
            <summary>
            Number of packets received since last sample
            </summary>
        </member>
        <member name="P:KPCAP.WinPcap.StatisticsModePacket.RecievedBytes">
            <summary>
            Number of bytes received since last sample
            </summary>
        </member>
        <member name="T:KPCAP.WinPcap.StatisticsModeEventArgs">
            <summary>
            Event that contains statistics mode data
            NOTE: WinPcap only
            </summary>
        </member>
        <member name="T:KPCAP.CaptureEventArgs">
            <summary>
            Capture event arguments
            </summary>
        </member>
        <member name="M:KPCAP.CaptureEventArgs.#ctor(Kavprot.Packets.RawPacket,KPCAP.ICaptureDevice)">
            <summary>
            Constructor
            </summary>
            <param name="packet">
            A <see cref="T:Kavprot.Packets.RawPacket"/>
            </param>
            <param name="device">
            A <see cref="T:KPCAP.ICaptureDevice"/>
            </param>
        </member>
        <member name="P:KPCAP.CaptureEventArgs.Packet">
            <summary>
            Packet that was captured
            </summary>
        </member>
        <member name="P:KPCAP.CaptureEventArgs.Device">
            <summary>
            Device this EventArgs was generated for
            </summary>
        </member>
        <member name="M:KPCAP.WinPcap.StatisticsModeEventArgs.#ctor(Kavprot.Packets.RawPacket,KPCAP.LibPcap.PcapDevice)">
            <summary>
            Constructor for a statistics mode event
            </summary>
            <param name="packet">
            A <see cref="T:Kavprot.Packets.RawPacket"/>
            </param>
            <param name="device">
            A <see cref="T:KPCAP.LibPcap.PcapDevice"/>
            </param>
        </member>
        <member name="P:KPCAP.WinPcap.StatisticsModeEventArgs.Statistics">
            <summary>
            Statistics data for this event
            </summary>
        </member>
        <member name="T:KPCAP.WinPcap.SendQueueTransmitModes">
            <summary>
            The types of transmit modes allowed by the WinPcap specific send queue
            implementation
            </summary>
        </member>
        <member name="F:KPCAP.WinPcap.SendQueueTransmitModes.Normal">
            <summary>
            Packets are sent as fast as possible
            </summary>
        </member>
        <member name="F:KPCAP.WinPcap.SendQueueTransmitModes.Synchronized">
            <summary>
            Packets are synchronized in the kernel with a high precision timestamp
            </summary>
        </member>
        <member name="T:KPCAP.WinPcap.SafeNativeMethods">
            <summary>
            Per http://msdn.microsoft.com/en-us/ms182161.aspx 
            </summary>
        </member>
        <member name="M:KPCAP.WinPcap.SafeNativeMethods.pcap_open(System.String,System.Int32,System.Int32,System.Int32,System.IntPtr,System.Text.StringBuilder)">
            <summary>
            Extended pcap_open() method that is WinPcap specific that
            provides extra flags and functionality
            See http://www.winpcap.org/docs/docs_40_2/html/group__wpcapfunc.html#g2b64c7b6490090d1d37088794f1f1791
            </summary>
            <param name="dev">
            A <see cref="T:System.String"/>
            </param>
            <param name="packetLen">
            A <see cref="T:System.Int32"/>
            </param>
            <param name="flags">
            A <see cref="T:System.Int32"/>
            </param>
            <param name="read_timeout">
            A <see cref="T:System.Int32"/>
            </param>
            <param name="rmtauth">
            A <see cref="T:System.IntPtr"/>
            </param>
            <param name="errbuf">
            A <see cref="T:System.Text.StringBuilder"/>
            </param>
            <returns>
            A <see cref="T:System.IntPtr"/>
            </returns>
        </member>
        <member name="M:KPCAP.WinPcap.SafeNativeMethods.pcap_findalldevs_ex(System.String,System.IntPtr,System.IntPtr@,System.Text.StringBuilder)">
            <summary>Create a list of network devices that can be opened with pcap_open().</summary>
        </member>
        <member name="M:KPCAP.WinPcap.SafeNativeMethods.pcap_setmode(System.IntPtr,System.Int32)">
            <summary>
            Set the working mode of the interface p to mode. 
            Valid values for mode are MODE_CAPT (default capture mode) 
            and MODE_STAT (statistical mode). See the tutorial 
            "\ref wpcap_tut9" for details about statistical mode.
            WinPcap specific method
            </summary>
        </member>
        <member name="M:KPCAP.WinPcap.SafeNativeMethods.pcap_setbuff(System.IntPtr,System.Int32)">
            <summary>
            WinPcap specific method for setting the kernel buffer size
            associated with this adapter. The old buffer is discarded
            when the buffer size is changed.
            See http://www.winpcap.org/docs/docs_40_2/html/group__wpcapfunc.html
            </summary>
            <param name="adapter">
            A <see cref="T:System.IntPtr"/>
            </param>
            <param name="bufferSizeInBytes">
            A <see cref="T:System.Int32"/>
            </param>
            <returns>
            A <see cref="T:System.Int32"/>
            </returns>
        </member>
        <member name="M:KPCAP.WinPcap.SafeNativeMethods.pcap_setmintocopy(System.IntPtr,System.Int32)">
            <summary>
            changes the minimum amount of data in the kernel buffer that causes 
            a read from the application to return (unless the timeout expires)
            See http://www.winpcap.org/docs/docs_412/html/group__wpcapfunc.html#gab14ceacbf1c2f63026416dd73f80dc0d
            </summary>
            <param name="adapter">
            A <see cref="T:System.IntPtr"/>
            </param>
            <param name="sizeInBytes">
            A <see cref="T:System.Int32"/>
            </param>
            <returns>
            A <see cref="T:System.Int32"/>
            </returns>
        </member>
        <member name="M:KPCAP.WinPcap.SafeNativeMethods.pcap_get_airpcap_handle(System.IntPtr)">
             <summary>
             Returns the AirPcap handler associated with an adapter. This handler can be used to change the
             wireless-related settings of the CACE Technologies AirPcap wireless capture adapters.
            
             Note: THIS FUNCTION SHOULD BE CONSIDERED PROVISIONAL, AND MAY BE REPLACED IN THE FUTURE BY A
             MORE COMPLETE SET OF FUNCTIONS FOR WIRELESS SUPPORT.
             pcap_get_airpcap_handle() allows to obtain the airpcap handle of an open adapter. This handle
             can be used with the AirPcap API functions to perform wireless-releated operations, e.g. changing
             the channel or enabling WEP decryption. For more details about the AirPcap wireless capture adapters,
             see http://www.cacetech.com/products/airpcap.html
            
             Parameters:
               p,: handle to an open libpcap adapter
             Returns:
               a PAirpcapHandle pointer to an open AirPcap handle, used internally by the libpcap open adapter.
               NULL if the libpcap adapter doesn't have wireless support through AirPcap.
             </summary>
             <param name="p"></param>
             <returns></returns>
        </member>
        <member name="M:KPCAP.WinPcap.SafeNativeMethods.pcap_sendqueue_alloc(System.Int32)">
            <summary>
            Allocate a send queue. 
            </summary>
            <param name="memsize">The size of the queue</param>
            <returns>A pointer to the allocated buffer</returns>
        </member>
        <member name="M:KPCAP.WinPcap.SafeNativeMethods.pcap_sendqueue_destroy(System.IntPtr)">
            <summary>
            Destroy a send queue. 
            </summary>
            <param name="queue">A pointer to the queue start address</param>
        </member>
        <member name="M:KPCAP.WinPcap.SafeNativeMethods.pcap_sendqueue_queue(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
            Add a packet to a send queue. 
            </summary>
            <param name="queue">A pointer to a queue</param>
            <param name="header">The pcap header of the packet to send</param>
            <param name="data">The packet data</param>
        </member>
        <member name="M:KPCAP.WinPcap.SafeNativeMethods.pcap_sendqueue_transmit(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Send a queue of raw packets to the network. 
            </summary>
            <param name="p"></param>
            <param name="queue"></param>
            <param name="sync">determines if the send operation must be synchronized: 
            if it is non-zero, the packets are sent respecting the timestamps, 
            otherwise they are sent as fast as possible</param>
            <returns>The amount of bytes actually sent. 
            If it is smaller than the size parameter, an error occurred 
            during the send. The error can be caused by a driver/adapter 
            problem or by an inconsistent/bogus send queue.</returns>
        </member>
        <member name="T:KPCAP.LibPcap.LibPcapSafeNativeMethods">
            <summary>
            Per http://msdn.microsoft.com/en-us/ms182161.aspx 
            </summary>
        </member>
        <member name="M:KPCAP.LibPcap.LibPcapSafeNativeMethods.pcap_dump_open(System.IntPtr,System.String)">
            <summary>Open a file to write packets. </summary>
        </member>
        <member name="M:KPCAP.LibPcap.LibPcapSafeNativeMethods.pcap_dump(System.IntPtr,System.IntPtr,System.IntPtr)">
            <summary>
             Save a packet to disk.  
            </summary>
        </member>
        <member name="M:KPCAP.LibPcap.LibPcapSafeNativeMethods.pcap_close(System.IntPtr)">
            <summary> close the files associated with p and deallocates resources.</summary>
        </member>
        <member name="M:KPCAP.LibPcap.LibPcapSafeNativeMethods.pcap_next_ex(System.IntPtr,System.IntPtr@,System.IntPtr@)">
            <summary>
            To avoid callback, this returns one packet at a time
            </summary>
        </member>
        <member name="M:KPCAP.LibPcap.LibPcapSafeNativeMethods.pcap_sendpacket(System.IntPtr,System.IntPtr,System.Int32)">
            <summary>
            Send a raw packet.<br/>
            This function allows to send a raw packet to the network. 
            The MAC CRC doesn't need to be included, because it is transparently calculated
             and added by the network interface driver.
            </summary>
            <param name="adaptHandle">the interface that will be used to send the packet</param>
            <param name="data">contains the data of the packet to send (including the various protocol headers)</param>
            <param name="size">the dimension of the buffer pointed by data</param>
            <returns>0 if the packet is succesfully sent, -1 otherwise.</returns>
        </member>
        <member name="M:KPCAP.LibPcap.LibPcapSafeNativeMethods.pcap_compile(System.IntPtr,System.IntPtr,System.String,System.Int32,System.UInt32)">
            <summary>
            Compile a packet filter, converting an high level filtering expression (see Filtering expression syntax) in a program that can be interpreted by the kernel-level filtering engine. 
            </summary>
        </member>
        <member name="M:KPCAP.LibPcap.LibPcapSafeNativeMethods.pcap_freecode(System.IntPtr)">
            <summary>
            Free up allocated memory pointed to by a bpf_program struct generated by pcap_compile()
            </summary>
        </member>
        <member name="M:KPCAP.LibPcap.LibPcapSafeNativeMethods.pcap_geterr(System.IntPtr)">
            <summary>
            return the error text pertaining to the last pcap library error.
            </summary>
        </member>
        <member name="M:KPCAP.LibPcap.LibPcapSafeNativeMethods.pcap_lib_version">
            <summary>Returns a pointer to a string giving information about the version of the libpcap library being used; note that it contains more information than just a version number. </summary>
        </member>
        <member name="M:KPCAP.LibPcap.LibPcapSafeNativeMethods.pcap_dump_file(System.IntPtr)">
            <summary>return the standard I/O stream of the 'savefile' opened by pcap_dump_open().</summary>
        </member>
        <member name="M:KPCAP.LibPcap.LibPcapSafeNativeMethods.pcap_dump_flush(System.IntPtr)">
            <summary>Flushes the output buffer to the 'savefile', so that any packets 
            written with pcap_dump() but not yet written to the 'savefile' will be written. 
            -1 is returned on error, 0 on success. </summary>
        </member>
        <member name="M:KPCAP.LibPcap.LibPcapSafeNativeMethods.pcap_dump_close(System.IntPtr)">
            <summary>Closes a savefile. </summary>
        </member>
        <member name="M:KPCAP.LibPcap.LibPcapSafeNativeMethods.pcap_datalink(System.IntPtr)">
            <summary> Return the link layer of an adapter. </summary>
        </member>
        <member name="M:KPCAP.LibPcap.LibPcapSafeNativeMethods.pcap_setnonblock(System.IntPtr,System.Int32,System.Text.StringBuilder)">
            <summary>
            Set nonblocking mode. pcap_loop() and pcap_next() doesnt work in  nonblocking mode!
            </summary>
        </member>
        <member name="M:KPCAP.LibPcap.LibPcapSafeNativeMethods.pcap_getnonblock(System.IntPtr,System.Text.StringBuilder)">
            <summary>
            Get nonblocking mode, returns allways 0 for savefiles.
            </summary>
        </member>
        <member name="M:KPCAP.LibPcap.LibPcapSafeNativeMethods.pcap_dispatch(System.IntPtr,System.Int32,KPCAP.LibPcap.LibPcapSafeNativeMethods.pcap_handler,System.IntPtr)">
            <summary>
            Read packets until cnt packets are processed or an error occurs.
            </summary>
        </member>
        <member name="M:KPCAP.LibPcap.LibPcapSafeNativeMethods.pcap_get_selectable_fd(System.IntPtr)">
            <summary>
            Retrieves a selectable file descriptor
            </summary>
            <param name="adaptHandle">
            A <see cref="T:System.IntPtr"/>
            </param>
            <returns>
            A <see cref="T:System.Int32"/>
            </returns>
        </member>
        <member name="M:KPCAP.LibPcap.LibPcapSafeNativeMethods.pcap_stats(System.IntPtr,System.IntPtr)">
            <summary>
            Fills in the pcap_stat structure passed to the function
            based on the pcap_t adapter
            </summary>
            <param name="adapter">
            A <see cref="T:System.IntPtr"/>
            </param>
            <param name="stat">
            A <see cref="T:System.IntPtr"/>
            </param>
            <returns>
            A <see cref="T:System.Int32"/>
            </returns>
        </member>
        <member name="M:KPCAP.LibPcap.LibPcapSafeNativeMethods.pcap_fileno(System.IntPtr)">
            <summary>
            Returns the file descriptor number from which captured packets are read,
            if a network device was opened with pcap_create() and pcap_activate() or
            with pcap_open_live(), or -1, if a ``savefile'' was opened with
            pcap_open_offline()
            Libpcap specific method
            </summary>
            <param name="adapter">
            A <see cref="T:System.IntPtr"/>
            </param>
            <returns>
            A <see cref="T:System.Int32"/>
            </returns>
        </member>
        <member name="T:KPCAP.LibPcap.LibPcapSafeNativeMethods.pcap_handler">
            <summary>
            The delegate declaration for PcapHandler requires an UnmanagedFunctionPointer attribute.
            Without this it fires for one time and then throws null pointer exception
            </summary>
        </member>
        <member name="T:KPCAP.AirPcap.AirPcapChannelInfo">
            <summary>
            Channel info
            </summary>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapChannelInfo.ToString">
            <summary>
            ToString() override
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapChannelInfo.Frequency">
            <summary>
            Channel frequency, in MHz
            </summary>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapChannelInfo.ExtChannel">
             <summary>
             802.11n specific. Offset of the extension channel in case of 40MHz channels. 
            
             Possible values are -1, 0 +1: 
             - -1 means that the extension channel should be below the control channel (e.g. Control = 5 and Extension = 1)
             - 0 means that no extension channel should be used (20MHz channels or legacy mode)
             - +1 means that the extension channel should be above the control channel (e.g. Control = 1 and Extension = 5)
            
             In case of 802.11a/b/g channels (802.11n legacy mode), this field should be set to 0.
            
             </summary>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapChannelInfo.Flags">
            <summary>
            Channel Flags. The only flag supported at this time is \ref AIRPCAP_CIF_TX_ENABLED.
            </summary>
        </member>
        <member name="T:KPCAP.LibPcap.LibPcapLiveDeviceList">
            <summary>
            List of available Pcap Interfaces.
            </summary>
        </member>
        <member name="M:KPCAP.LibPcap.LibPcapLiveDeviceList.New">
            <summary>
            Caution: Use the singlton instance unless you know why you need to call this.
            One use is for multiple filters on the same physical device. To apply multiple
            filters open the same physical device multiple times, one for each
            filter by calling this routine and picking the same device out of each list.
            </summary>
            <returns>
            A <see cref="T:KPCAP.LibPcap.LibPcapLiveDeviceList"/>
            </returns>
        </member>
        <member name="M:KPCAP.LibPcap.LibPcapLiveDeviceList.#ctor">
            <summary>
            Represents a strongly typed, read-only list of PcapDevices.
            </summary>
        </member>
        <member name="M:KPCAP.LibPcap.LibPcapLiveDeviceList.GetDevices">
            <summary>
            Retrieve a list of the current PcapDevices
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.List`1"/>
            </returns>
        </member>
        <member name="M:KPCAP.LibPcap.LibPcapLiveDeviceList.Refresh">
            <summary>
            Refresh the device list
            </summary>
        </member>
        <member name="P:KPCAP.LibPcap.LibPcapLiveDeviceList.Instance">
            <summary>
            Method to retrieve this classes singleton instance
            </summary>
        </member>
        <member name="P:KPCAP.LibPcap.LibPcapLiveDeviceList.Item(System.String)">
            <param name="Name">The name or description of the pcap interface to get.</param>
        </member>
        <member name="T:KPCAP.AirPcap.AirPcapLinkTypes">
            <summary>
            Link type
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapLinkTypes._802_11">
            <summary>
            plain 802.11 link type. Every packet in the buffer contains the raw 802.11 frame, including MAC FCS.
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapLinkTypes._802_11_PLUS_RADIO">
            <summary>
            802.11 plus radiotap link type. Every packet in the buffer contains a radiotap header followed by the 802.11 frame. MAC FCS is included.
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapLinkTypes.UNKNOWN">
            <summary>
            Unknown link type, should be seen only in error
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapLinkTypes._802_11_PLUS_PPI">
            <summary>
            802.11 plus PPI header link type. Every packet in the buffer contains a PPI header followed by the 802.11 frame. MAC FCS is included.
            </summary>
        </member>
        <member name="T:KPCAP.WinPcap.CaptureMode">
            <summary>
            The working mode of a Pcap device
            </summary>
        </member>
        <member name="F:KPCAP.WinPcap.CaptureMode.Packets">
            <summary>
            Set a Pcap device to capture packets, Capture mode
            </summary>
        </member>
        <member name="F:KPCAP.WinPcap.CaptureMode.Statistics">
            <summary>
            Set a Pcap device to report statistics.
            <br/>
            Statistics mode is only supported in WinPcap
            </summary>
        </member>
        <member name="T:KPCAP.WinPcap.OpenFlags">
            <summary>
            The mode used when opening a device
            </summary>
        </member>
        <member name="F:KPCAP.WinPcap.OpenFlags.Promiscuous">
            <summary>
            Defines if the adapter has to go in promiscuous mode. 
            </summary>
        </member>
        <member name="F:KPCAP.WinPcap.OpenFlags.DataTransferUdp">
            <summary>
            Defines if the data trasfer (in case of a remote capture)
            has to be done with UDP protocol. 
            </summary>
        </member>
        <member name="F:KPCAP.WinPcap.OpenFlags.NoCaptureRemote">
            <summary>
            Defines if the remote probe will capture its own generated traffic. 
            </summary>
        </member>
        <member name="F:KPCAP.WinPcap.OpenFlags.NoCaptureLocal">
            <summary>
            Defines if the local adapter will capture its own generated traffic. 
            </summary>
        </member>
        <member name="F:KPCAP.WinPcap.OpenFlags.MaxResponsiveness">
            <summary>
            This flag configures the adapter for maximum responsiveness. 
            </summary>
        </member>
        <member name="T:KPCAP.InvalidOperationDuringBackgroundCaptureException">
            <summary>
            Thrown when an operation can't be performed because
            a background capture has been started via PcapDevice.StartCapture()
            </summary>
        </member>
        <member name="M:KPCAP.InvalidOperationDuringBackgroundCaptureException.#ctor(System.String)">
            <summary>
            string constructor
            </summary>
            <param name="msg">
            A <see cref="T:System.String"/>
            </param>
        </member>
        <member name="T:KPCAP.CaptureStoppedEventStatus">
            <summary>
            Status types when capture is stopped
            </summary>
        </member>
        <member name="F:KPCAP.CaptureStoppedEventStatus.CompletedWithoutError">
            <summary>
            Capture completed without errors
            </summary>
        </member>
        <member name="F:KPCAP.CaptureStoppedEventStatus.ErrorWhileCapturing">
            <summary>
            Error while capturing
            </summary>
        </member>
        <member name="T:KPCAP.AirPcap.AirPcapDeviceList">
            <summary>
            AirPcap device list
            </summary>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapDeviceList.New">
            <summary>
            Caution: Use the singlton instance unless you know why you need to call this.
            One use is for multiple filters on the same physical device. To apply multiple
            filters open the same physical device multiple times, one for each
            filter by calling this routine and picking the same device out of each list.
            </summary>
            <returns>
            A <see cref="T:KPCAP.CaptureDeviceList"/>
            </returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapDeviceList.#ctor">
            <summary>
            Represents a strongly typed, read-only list of PcapDevices.
            </summary>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapDeviceList.GetDevices">
            <summary>
            Retrieve an array of AirPcapDevices
            </summary>
            <returns></returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapDeviceList.Refresh">
            <summary>
            Refresh the device list
            </summary>
        </member>
        <!-- Commentaire XML incorrect ignoré pour le membre "M:KPCAP.AirPcap.AirPcapDeviceList.GetAirPcapDevices" -->
        <member name="P:KPCAP.AirPcap.AirPcapDeviceList.Instance">
            <summary>
            Method to retrieve this classes singleton instance
            </summary>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapDeviceList.Item(System.String)">
            <param name="Name">The name or description of the pcap interface to get.</param>
        </member>
        <member name="T:KPCAP.AirPcap.AirPcapAdapterBus">
            <summary>
            Adapter bus types
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapAdapterBus.Usb">
            <summary>
            Usb
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapAdapterBus.Pci">
            <summary>
            Pci
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapAdapterBus.PciExpress">
            <summary>
            PciExpress
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapAdapterBus.MiniPci">
            <summary>
            MiniPci
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapAdapterBus.MiniPciExpress">
            <summary>
            MiniPciExpress
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapAdapterBus.Cardbus">
            <summary>
            Cardbus
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapAdapterBus.Expresscard">
            <summary>
            Expresscard
            </summary>
        </member>
        <member name="T:KPCAP.LibPcap.PcapStatistics">
            <summary>
            Adapter statistics, received, dropped packet counts etc
            </summary>
        </member>
        <member name="M:KPCAP.LibPcap.PcapStatistics.#ctor(System.IntPtr)">
            <summary>
            Retrieve pcap statistics from the adapter
            </summary>
            <param name="pcap_t">
            pcap_t* for the adapter
            A <see cref="T:System.IntPtr"/>
            </param>
        </member>
        <member name="M:KPCAP.LibPcap.PcapStatistics.ToString">
            <summary>
            ToString override
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:KPCAP.LibPcap.PcapStatistics.ReceivedPackets">
            <value>
            Number of packets received
            </value>
        </member>
        <member name="P:KPCAP.LibPcap.PcapStatistics.DroppedPackets">
            <value>
            Number of packets dropped
            </value>
        </member>
        <member name="P:KPCAP.LibPcap.PcapStatistics.InterfaceDroppedPackets">
            <value>
            Number of interface dropped packets
            </value>
        </member>
        <member name="T:KPCAP.LibPcap.Sockaddr">
            <summary>
            Container class that represents either an ip address or a mac address
            An analog to the 'sockaddr_' series of structures
            </summary>
        </member>
        <member name="F:KPCAP.LibPcap.Sockaddr.type">
            <summary>
            Address type represented by this Sockaddr
            </summary>
        </member>
        <member name="F:KPCAP.LibPcap.Sockaddr.ipAddress">
            <summary>
            If type == AF_INET_AF_INET6
            </summary>
        </member>
        <member name="F:KPCAP.LibPcap.Sockaddr.hardwareAddress">
            <summary>
            If type == HARDWARE
            </summary>
        </member>
        <member name="M:KPCAP.LibPcap.Sockaddr.#ctor(System.Net.NetworkInformation.PhysicalAddress)">
            <summary>
            Create a Sockaddr from a PhysicalAddress which is presumed to
            be a hardware address
            </summary>
            <param name="hardwareAddress">
            A <see cref="T:System.Net.NetworkInformation.PhysicalAddress"/>
            </param>
        </member>
        <member name="M:KPCAP.LibPcap.Sockaddr.ToString">
            <summary>
            ToString override
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:KPCAP.LibPcap.Sockaddr.sa_family">
            <summary>
            Address family
            </summary>
        </member>
        <member name="T:KPCAP.LibPcap.Sockaddr.Type">
            <summary>
            Types of addresses a Sockaddr can represent
            </summary>
        </member>
        <member name="F:KPCAP.LibPcap.Sockaddr.Type.AF_INET_AF_INET6">
            <summary>
            Address represents an ipv4 or ipv6 address
            </summary>
        </member>
        <member name="F:KPCAP.LibPcap.Sockaddr.Type.HARDWARE">
            <summary>
            Address represents a physical hardware address eg. a ethernet mac address
            </summary>
        </member>
        <member name="F:KPCAP.LibPcap.Sockaddr.Type.UNKNOWN">
            <summary>
            Unknown address type
            </summary>
        </member>
        <member name="T:KPCAP.LibPcap.PcapAddress">
            <summary>
            Managed representation of the unmanaged pcap_addr structure
            </summary>
        </member>
        <member name="M:KPCAP.LibPcap.PcapAddress.ToString">
            <summary>
            ToString override
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:KPCAP.LibPcap.PcapAddress.Addr">
            <summary>
            The address value of this PcapAddress, null if none is present
            </summary>
        </member>
        <member name="P:KPCAP.LibPcap.PcapAddress.Netmask">
            <summary>
            Netmask of this PcapAddress, null if none is present
            </summary>
        </member>
        <member name="P:KPCAP.LibPcap.PcapAddress.Broadaddr">
            <summary>
            Broadcast address of this PcapAddress, null if none is present
            </summary>
        </member>
        <member name="P:KPCAP.LibPcap.PcapAddress.Dstaddr">
            <summary>
            Destination address, null if the interface isn't a point-to-point interface
            </summary>
        </member>
        <member name="T:KPCAP.WinPcap.SendQueue">
            <summary>
            Interface to the WinPcap send queue extension methods
            </summary>
        </member>
        <member name="M:KPCAP.WinPcap.SendQueue.#ctor(System.Int32)">
            <summary>
            Creates and allocates a new SendQueue
            </summary>
            <param name="memSize">
            The maximun amount of memory (in bytes) 
            to allocate for the queue</param>
        </member>
        <member name="M:KPCAP.WinPcap.SendQueue.AddInternal(System.Byte[],KPCAP.LibPcap.PcapHeader)">
            <summary>
            Add a packet to this send queue. The PcapHeader defines the packet length.
            </summary>
            <param name="packet">The packet bytes to add</param>
            <param name="pcapHdr">The pcap header of the packet</param>
            <returns>True if success, else false</returns>
        </member>
        <member name="M:KPCAP.WinPcap.SendQueue.Add(System.Byte[],KPCAP.LibPcap.PcapHeader)">
            <summary>
            Add a packet to this send queue. 
            </summary>
            <param name="packet">The packet bytes to add</param>
            <param name="pcapHdr">The pcap header of the packet</param>
            <returns>True if success, else false</returns>
        </member>
        <member name="M:KPCAP.WinPcap.SendQueue.Add(System.Byte[])">
            <summary>
            Add a packet to this send queue. 
            </summary>
            <param name="packet">The packet bytes to add</param>
            <returns>True if success, else false</returns>
        </member>
        <member name="M:KPCAP.WinPcap.SendQueue.Add(Kavprot.Packets.RawPacket)">
            <summary>
            Add a packet to this send queue. 
            </summary>
            <param name="packet">The packet to add</param>
            <returns>True if success, else false</returns>
        </member>
        <member name="M:KPCAP.WinPcap.SendQueue.Add(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Add a packet to this send queue.
            </summary>
            <param name="packet">The packet to add</param>
            <param name="seconds">The 'seconds' part of the packet's timestamp</param>
            <param name="microseconds">The 'microseconds' part of the packet's timestamp</param>
            <returns>True if success, else false</returns>
        </member>
        <member name="M:KPCAP.WinPcap.SendQueue.Transmit(KPCAP.WinPcap.WinPcapDevice,KPCAP.WinPcap.SendQueueTransmitModes)">
            <summary>
            Send a queue of raw packets to the network. 
            </summary>
            <param name="device">
            The device on which to send the queue
            A <see cref="T:KPCAP.LibPcap.PcapDevice"/>
            </param>
            <param name="transmitMode">
            A <see cref="T:KPCAP.WinPcap.SendQueueTransmitModes"/>
            </param>
            <returns>
            A <see cref="T:System.Int32"/>
            </returns>
        </member>
        <member name="M:KPCAP.WinPcap.SendQueue.Dispose">
            <summary>
            Destroy the send queue. 
            </summary>
        </member>
        <member name="P:KPCAP.WinPcap.SendQueue.CurrentLength">
            <summary>
            The current length in bytes of this queue
            </summary>
        </member>
        <member name="T:KPCAP.AirPcap.AirPcapKeyType">
            <summary>
            Type of keys in the adapter
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapKeyType.Wep">
            <summary>
            Key type: WEP. The key can have an arbitrary length smaller than 32 bytes.
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapKeyType.Tkip">
            <summary>
            Key type: TKIP (WPA). NOT SUPPORTED YET by AirPcap
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapKeyType.Ccmp">
            <summary>
            Key type: CCMP (WPA2). NOT SUPPORTED YET by AirPcap
            </summary>
        </member>
        <member name="T:KPCAP.AirPcap.AirPcapKey">
            <summary>
            WEB key container
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapKey.WepKeyMaxSize">
            <summary>
            Number of bytes in a wep key
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapKey.Type">
            <summary>
            Type of key, can be on of: \ref AIRPCAP_KEYTYPE_WEP, \ref AIRPCAP_KEYTYPE_TKIP, \ref AIRPCAP_KEYTYPE_CCMP. Only AIRPCAP_KEYTYPE_WEP is supported by the driver at the moment.
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapKey.Data">
            <summary>
            Key data
            </summary>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapKey.#ctor(KPCAP.AirPcap.AirPcapKeyType,System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="Type"></param>
            <param name="Data"></param>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapKey.ToString">
             <summary>
            
             </summary>
             <returns>
             A <see cref="T:System.String"/>
             </returns>
        </member>
        <member name="T:KPCAP.AirPcap.AirPcapDevice">
            <summary>
            AirPcap device
            </summary>
        </member>
        <member name="T:KPCAP.WinPcap.WinPcapDevice">
            <summary>
            WinPcap device
            </summary>
        </member>
        <member name="T:KPCAP.LibPcap.LibPcapLiveDevice">
            <summary>
            Capture live packets from a network device
            </summary>
        </member>
        <member name="M:KPCAP.LibPcap.LibPcapLiveDevice.#ctor(KPCAP.LibPcap.PcapInterface)">
            <summary>
            Constructs a new PcapDevice based on a 'pcapIf' struct
            </summary>
            <param name="pcapIf">A 'pcapIf' struct representing
            the pcap device</param>
        </member>
        <member name="M:KPCAP.LibPcap.LibPcapLiveDevice.#ctor">
            <summary>
            Default contructor for subclasses
            </summary>
        </member>
        <member name="M:KPCAP.LibPcap.LibPcapLiveDevice.Finalize">
            <summary>
            PcapDevice finalizer.  Ensure PcapDevices are stopped and closed before exit.
            </summary>
        </member>
        <member name="M:KPCAP.LibPcap.LibPcapLiveDevice.Open">
            <summary>
            Open the device with default values of: promiscuous_mode = false, read_timeout = 1000
            To start capturing call the 'StartCapture' function
            </summary>
        </member>
        <member name="M:KPCAP.LibPcap.LibPcapLiveDevice.Open(KPCAP.DeviceMode)">
            <summary>
            Open the device. To start capturing call the 'StartCapture' function
            </summary>
            <param name="mode">
            A <see cref="T:KPCAP.DeviceMode"/>
            </param>
        </member>
        <member name="M:KPCAP.LibPcap.LibPcapLiveDevice.Open(KPCAP.DeviceMode,System.Int32)">
            <summary>
            Open the device. To start capturing call the 'StartCapture' function
            </summary>
            <param name="mode">
            A <see cref="T:KPCAP.DeviceMode"/>
            </param>
            <param name="read_timeout">
            A <see cref="T:System.Int32"/>
            </param>
        </member>
        <member name="M:KPCAP.LibPcap.LibPcapLiveDevice.SendPacket(System.Byte[],System.Int32)">
            <summary>
            Sends a raw packet throgh this device
            </summary>
            <param name="p">The packet bytes to send</param>
            <param name="size">The number of bytes to send</param>
        </member>
        <member name="P:KPCAP.LibPcap.LibPcapLiveDevice.Name">
            <summary>
            Gets the pcap name of this network device
            </summary>
        </member>
        <member name="P:KPCAP.LibPcap.LibPcapLiveDevice.Addresses">
            <summary>
            Addresses that represent this device
            </summary>
        </member>
        <member name="P:KPCAP.LibPcap.LibPcapLiveDevice.Description">
            <summary>
            Gets the pcap description of this device
            </summary>
        </member>
        <member name="P:KPCAP.LibPcap.LibPcapLiveDevice.Flags">
            <summary>
            Interface flags, see pcap_findalldevs() man page for more info
            </summary>
        </member>
        <member name="P:KPCAP.LibPcap.LibPcapLiveDevice.Loopback">
            <summary>
            True if device is a loopback interface, false if not
            </summary>
        </member>
        <member name="P:KPCAP.LibPcap.LibPcapLiveDevice.NonBlockingMode">
            <summary>
            Set/Get Non-Blocking Mode. returns allways false for savefiles.
            </summary>
        </member>
        <member name="P:KPCAP.LibPcap.LibPcapLiveDevice.Statistics">
            <summary>
            Retrieves pcap statistics
            </summary>
            <returns>
            A <see cref="T:KPCAP.LibPcap.PcapStatistics"/>
            </returns>
        </member>
        <member name="M:KPCAP.WinPcap.WinPcapDevice.#ctor(KPCAP.LibPcap.PcapInterface)">
            <summary>
            Constructs a new PcapDevice based on a 'pcapIf' struct
            </summary>
            <param name="pcapIf">A 'pcapIf' struct representing
            the pcap device</param>
        </member>
        <member name="M:KPCAP.WinPcap.WinPcapDevice.Open">
            <summary>
            Open the device
            </summary>
        </member>
        <member name="M:KPCAP.WinPcap.WinPcapDevice.Open(KPCAP.WinPcap.OpenFlags,System.Int32,KPCAP.WinPcap.RemoteAuthentication)">
            <summary>
            Open
            </summary>
            <param name="flags">
            A <see cref="T:KPCAP.WinPcap.OpenFlags"/>
            </param>
            <param name="readTimeoutMilliseconds">
            A <see cref="T:System.Int32"/>
            </param>
            <param name="remoteAuthentication">
            A <see cref="T:KPCAP.WinPcap.RemoteAuthentication"/>
            </param>
        </member>
        <member name="M:KPCAP.WinPcap.WinPcapDevice.Open(KPCAP.WinPcap.OpenFlags,System.Int32)">
            <summary>
            Open a device with specific flags
            WinPcap extension - Use of this method will exclude your application
                                from working on Linux or Mac
            </summary>
        </member>
        <member name="M:KPCAP.WinPcap.WinPcapDevice.Close">
            <summary>
            Close the device
            </summary>
        </member>
        <member name="M:KPCAP.WinPcap.WinPcapDevice.SendPacketArrivalEvent(Kavprot.Packets.RawPacket)">
            <summary>
            Notify the OnPacketArrival delegates about a newly captured packet
            </summary>
            <param name="p">
            A <see cref="T:Kavprot.Packets.RawPacket"/>
            </param>
        </member>
        <member name="M:KPCAP.WinPcap.WinPcapDevice.SendQueue(KPCAP.WinPcap.SendQueue,KPCAP.WinPcap.SendQueueTransmitModes)">
            <summary>
            Sends all packets in a 'PcapSendQueue' out this pcap device
            </summary>
            <param name="q">
            A <see cref="M:KPCAP.WinPcap.WinPcapDevice.SendQueue(KPCAP.WinPcap.SendQueue,KPCAP.WinPcap.SendQueueTransmitModes)"/>
            </param>
            <param name="transmitMode">
            A <see cref="T:KPCAP.WinPcap.SendQueueTransmitModes"/>
            </param>
            <returns>
            A <see cref="T:System.Int32"/>
            </returns>
        </member>
        <member name="M:KPCAP.WinPcap.WinPcapDevice.ThrowIfNotWinPcap">
            <summary>
            Helper method for ensuring we are running in winpcap. Throws
            a PcapWinPcapRequiredException() if not on a windows platform
            </summary>
        </member>
        <member name="E:KPCAP.WinPcap.WinPcapDevice.OnPcapStatistics">
            <summary>
            Fires whenever a new pcap statistics is available for this Pcap Device.<br/>
            For network captured packets this event is invoked only when working in "PcapMode.Statistics" mode.
            </summary>
        </member>
        <member name="P:KPCAP.WinPcap.WinPcapDevice.Mode">
            <value>
            WinPcap specific property
            </value>
        </member>
        <member name="P:KPCAP.WinPcap.WinPcapDevice.KernelBufferSize">
            <value>
            Set the kernel value buffer size in bytes
            WinPcap extension
            </value>
        </member>
        <member name="P:KPCAP.WinPcap.WinPcapDevice.MinToCopy">
            <value>
            Set the minumum amount of data (in bytes) received by the kernel in a single call. 
            WinPcap extension
            </value>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapDevice.MacAddressSizeInBytes">
            <summary>
            TODO: Get this from packet.net or another place in System.Net.xxx?
            </summary>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapDevice.ThrowIfNotOpen">
            <summary>
            See ThrowIfNotOpen(string ExceptionString)
            </summary>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapDevice.GetLastError(System.IntPtr)">
            <summary>
            Retrieve the last error string for a given pcap_t* device
            </summary>
            <param name="AirPcapDeviceHandle">
            A <see cref="T:System.IntPtr"/>
            </param>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapDevice.Open">
            <summary>
            Open a device
            </summary>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapDevice.Open(KPCAP.DeviceMode)">
            <summary>
            Open the device. To start capturing call the 'StartCapture' function
            </summary>
            <param name="mode">
            A <see cref="T:KPCAP.DeviceMode"/>
            </param>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapDevice.Open(KPCAP.DeviceMode,System.Int32)">
            <summary>
            Open the device. To start capturing call the 'StartCapture' function
            </summary>
            <param name="mode">
            A <see cref="T:KPCAP.DeviceMode"/>
            </param>
            <param name="read_timeout">
            A <see cref="T:System.Int32"/>
            </param>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapDevice.Open(KPCAP.WinPcap.OpenFlags,System.Int32)">
            <summary>
            Opens an Airpcap device with optional WinPcap.OpenFlags
            </summary>
            <param name="flags">
            A <see cref="T:KPCAP.WinPcap.OpenFlags"/>
            </param>
            <param name="read_timeout">
            A <see cref="T:System.Int32"/>
            </param>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapDevice.Close">
            <summary>
            Close a device
            </summary>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapDevice.KeyCollectionSize(System.Int32)">
            <summary>
            Size in bytes of a key collection with a given count of keys
            </summary>
            <param name="keyCount"></param>
            <returns></returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapDevice.IntPtrToKeys(System.IntPtr)">
            <summary>
            Convert a AirpcapKeysCollection unmanaged buffer to a list of managed keys
            </summary>
            <param name="pKeysCollection"></param>
            <returns></returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapDevice.KeysToIntPtr(System.Collections.Generic.List{KPCAP.AirPcap.AirPcapKey})">
            <summary>
            Convert an array of keys into unmanaged memory
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapDevice.Led(System.Int32,KPCAP.AirPcap.AirPcapDevice.LedState)">
            <summary>
            Constructor
            </summary>
            <param name="ledIndex">
            A <see cref="T:System.Int32"/>
            </param>
            <param name="newLedState">
            A <see cref="T:KPCAP.AirPcap.AirPcapDevice.LedState"/>
            </param>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapDevice.CaptureThread">
            <summary>
            AirPcap specific capture thread
            </summary>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapDevice.MarshalPackets(System.IntPtr,System.IntPtr,System.Collections.Generic.List{Kavprot.Packets.RawPacket}@)">
            <summary>
            Marshal a chunk of captured packets into a packet list
            </summary>
            <param name="packetsBuffer"></param>
            <param name="bufferEnd"></param>
            <param name="packets"></param>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapDevice.AirPcapDeviceHandle">
            <summary>
            Handle to the device
            </summary>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapDevice.LastError">
            <summary>
            The last pcap error associated with this pcap device
            </summary>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapDevice.Capabilities">
            <summary>
            Device capabilities, whether the device can transmit, its id, model name etc
            </summary>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapDevice.Channel">
            <summary>
            Adapter channel
            </summary>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapDevice.ChannelInfo">
            <summary>
            Channel information
            </summary>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapDevice.DeviceKeys">
            <summary>
            Decryption keys that are currently associated with the specified device
            </summary>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapDevice.DriverKeys">
            <summary>
            Global list of decryption keys that AirPcap is using with all the devices.
            </summary>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapDevice.DecryptionState">
            <summary>
            Tells if decryption of the incoming frames with the <b>device-specific</b> keys.
            </summary>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapDevice.DriverDecryptionState">
            <summary>
            Tells if this open instance is configured to perform the decryption of the incoming frames with the <b>global</b> set of keys.
            </summary>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapDevice.FcsPresence">
            <summary>
            Configures the adapter on whether to include the MAC Frame Check Sequence in the captured packets.
            </summary>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapDevice.FcsValidation">
            <summary>
            The kinds of frames that the device will capture
            By default all frames are captured
            </summary>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapDevice.KernelBufferSize">
            <summary>
            Kernel packet buffer size for this adapter in bytes
            </summary>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapDevice.LedCount">
            <summary>
            Number of leds on this adapter
            </summary>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapDevice.AirPcapLinkType">
            <summary>
            Link type
            </summary>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapDevice.LinkType">
            <summary>
            Link type in terms of Kavprot.Packets.LinkLayers
            </summary>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapDevice.MacAddress">
            <summary>
            Mac address
            </summary>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapDevice.MacFlags">
            <summary>
            Mac flags
            </summary>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapDevice.Statistics">
            <summary>
            Adapter statistics
            </summary>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapDevice.SupportedChannels">
            <summary>
            List of supported channels
            </summary>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapDevice.TxPower">
            <summary>
            Transmit power
            </summary>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapDevice.Timestamp">
            <summary>
            Device timestamp
            </summary>
        </member>
        <member name="T:KPCAP.AirPcap.AirPcapDevice.LedState">
            <summary>
            Led states
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapDevice.LedState.On">
            <summary>
            Led on
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapDevice.LedState.Off">
            <summary>
            Led off
            </summary>
        </member>
        <member name="T:KPCAP.WinPcap.RemoteAuthentication">
            <summary>
            Remote authentication type and parameters
            </summary>
        </member>
        <member name="M:KPCAP.WinPcap.RemoteAuthentication.#ctor(KPCAP.WinPcap.AuthenticationTypes,System.String,System.String)">
            <summary>
            Constructor
            </summary>
            <param name="Type">
            A <see cref="T:KPCAP.WinPcap.AuthenticationTypes"/>
            </param>
            <param name="Username">
            A <see cref="T:System.String"/>
            </param>
            <param name="Password">
            A <see cref="T:System.String"/>
            </param>
        </member>
        <member name="M:KPCAP.WinPcap.RemoteAuthentication.GetUnmanaged">
            <summary>
            Converts this structure to an unmanaged IntPtr. Should be
            freed with Marshal.FreeHGlobal(IntPtr);
            </summary>
            <returns>
            A <see cref="T:System.IntPtr"/>
            </returns>
        </member>
        <member name="P:KPCAP.WinPcap.RemoteAuthentication.Type">
            <summary>
            Type of authentication
            </summary>
        </member>
        <member name="P:KPCAP.WinPcap.RemoteAuthentication.Username">
            <summary>
            Username
            </summary>
        </member>
        <member name="P:KPCAP.WinPcap.RemoteAuthentication.Password">
            <summary>
            Password
            </summary>
        </member>
        <member name="T:KPCAP.StatisticsException">
            <summary>
            thrown when pcap_stats() reports an error
            </summary>
        </member>
        <member name="M:KPCAP.StatisticsException.#ctor(System.String)">
            <summary>
            string constructor
            </summary>
            <param name="msg">
            A <see cref="T:System.String"/>
            </param>
        </member>
        <member name="T:KPCAP.AirPcap.AirPcapVersion">
            <summary>
            Version
            </summary>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapVersion.Version(System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">
            <summary>
            Returns the version in separate fields
            </summary>
            <param name="Major"></param>
            <param name="Minor"></param>
            <param name="Rev"></param>
            <param name="Build"></param>
            <returns></returns>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapVersion.VersionString">
            <summary>
            Returns the version in a.b.c.d format
            </summary>
            <returns></returns>
        </member>
        <member name="T:KPCAP.AirPcap.AirPcapMediumType">
            <summary>
            Medium type
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapMediumType._802_11_A">
            <summary>802.11a medium</summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapMediumType._802_11_B">
            <summary>802.11b medium</summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapMediumType._802_11_G">
            <summary>802.11g medium</summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapMediumType._802_11_N">
            <summary>802.11n medium</summary>
        </member>
        <member name="T:KPCAP.DeviceMode">
            <summary>
            The mode used when opening a device
            </summary>
        </member>
        <member name="F:KPCAP.DeviceMode.Promiscuous">
            <summary>
            Promiscuous mode.
            Instructs the OS that we want to receive all packets, even those not
            intended for the adapter. On non-switched networks this can result in
            a large amount of addtional traffic.
            NOTE: Devices in this mode CAN be detected via the network
            </summary>
        </member>
        <member name="F:KPCAP.DeviceMode.Normal">
            <summary>
            Not promiscuous mode
            </summary>
        </member>
        <member name="T:KPCAP.AirPcap.AirPcapValidationType">
            <summary>
            Type of frame validation the adapter performs.
            An adapter can be instructed to accept different kind of frames: correct frames only, frames with wrong Frame Check Sequence (FCS) only, all frames.
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapValidationType.ACCEPT_EVERYTHING">
            <summary>Accept all the frames the device captures</summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapValidationType.ACCEPT_CORRECT_FRAMES">
            <summary>Accept correct frames only, i.e. frames with correct Frame Check Sequence (FCS).</summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapValidationType.ACCEPT_CORRUPT_FRAMES">
            <summary>Accept corrupt frames only, i.e. frames with worng Frame Check Sequence (FCS).</summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapValidationType.UNKNOWN">
            <summary>Unknown validation type. You should see it only in case of error.</summary>
        </member>
        <member name="T:KPCAP.CaptureStoppedEventHandler">
            <summary>
            A delegate for notifying of a capture stopped event
            </summary>
        </member>
        <member name="T:KPCAP.LibPcap.PcapInterface">
            <summary>
            managed version of struct pcap_if
            NOTE: we can't use pcap_if directly because the class contains
                  a pointer to pcap_if that will be freed when the
                  device memory is freed, so instead convert the unmanaged structure
                  to a managed one to avoid this issue
            </summary>
        </member>
        <member name="M:KPCAP.LibPcap.PcapInterface.ToString">
            <summary>
            ToString override
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:KPCAP.LibPcap.PcapInterface.Name">
            <value>
            Name of the interface. Used internally when passed to pcap_open_live()
            </value>
        </member>
        <member name="P:KPCAP.LibPcap.PcapInterface.FriendlyName">
            <value>
            Human readable interface name derived from System.Net.NetworkInformation.NetworkInterface.Name
            </value>
        </member>
        <member name="P:KPCAP.LibPcap.PcapInterface.Description">
            <value>
            Text description of the interface as given by pcap/winpcap
            </value>
        </member>
        <member name="P:KPCAP.LibPcap.PcapInterface.GatewayAddress">
            <value>
            Gateway address of this device
            NOTE: May only be available on Windows
            </value>
        </member>
        <member name="P:KPCAP.LibPcap.PcapInterface.Addresses">
            <value>
            Addresses associated with this device
            </value>
        </member>
        <member name="P:KPCAP.LibPcap.PcapInterface.Flags">
            <value>
            Pcap interface flags
            </value>
        </member>
        <member name="P:KPCAP.LibPcap.PcapInterface.MacAddress">
            <summary>
            MacAddress of the interface
            </summary>
        </member>
        <member name="T:KPCAP.CaptureDeviceList">
            <summary>
            List of available capture devices
            </summary>
        </member>
        <member name="M:KPCAP.CaptureDeviceList.New">
            <summary>
            Caution: Use the singlton instance unless you know why you need to call this.
            One use is for multiple filters on the same physical device. To apply multiple
            filters open the same physical device multiple times, one for each
            filter by calling this routine and picking the same device out of each list.
            </summary>
            <returns>
            A <see cref="T:KPCAP.CaptureDeviceList"/>
            </returns>
        </member>
        <member name="M:KPCAP.CaptureDeviceList.#ctor">
            <summary>
            Represents a strongly typed, read-only list of PcapDevices.
            </summary>
        </member>
        <member name="M:KPCAP.CaptureDeviceList.GetDevices">
            <summary>
            Retrieve a list of the current devices
            </summary>
            <returns>
            A <see cref="T:System.Collections.Generic.List`1"/>
            </returns>
        </member>
        <member name="M:KPCAP.CaptureDeviceList.Refresh">
            <summary>
            Refresh the device list
            </summary>
        </member>
        <member name="P:KPCAP.CaptureDeviceList.Instance">
            <summary>
            Method to retrieve this classes singleton instance
            </summary>
        </member>
        <member name="P:KPCAP.CaptureDeviceList.Item(System.String)">
            <param name="Name">The name or description of the pcap interface to get.</param>
        </member>
        <member name="T:KPCAP.AirPcap.AirPcapDeviceTimestamp">
            <summary>
            Defines the internal AirPcap device timestamp
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapDeviceTimestamp.DeviceTimestamp">
            <summary>Current value of the device counter, in microseconds.</summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapDeviceTimestamp.SoftwareTimestampBefore">
            <summary>Value of the software counter used to timestamp packets before reading the device counter, in microseconds.</summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapDeviceTimestamp.SoftwareTimestampAfter">
            <summary>Value of the software counter used to timestamp packets after reading the device counter, in microseconds.</summary>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapDeviceTimestamp.ToString">
            <summary>
            ToString() override
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="T:KPCAP.WinPcap.UnmanagedStructures">
            <summary>
            WinPcap specific unmanaged structures
            </summary>
        </member>
        <member name="T:KPCAP.WinPcap.UnmanagedStructures.pcap_rmtauth">
            <summary>
            Struct to specifiy Remote Address using rpcapd.exe, Winpcaps Remote Packet Capture Daemon
            </summary>
        </member>
        <member name="F:KPCAP.WinPcap.UnmanagedStructures.pcap_rmtauth.type">
             <summary>
             NOTE: IntPtr used to ensure that the correct data size is used depending on
             the platform being used, 32bits on a 32bit machine, 64bits on a 64bit machine
            
             Auth Type, 0=Null, 1= Password
             </summary>
        </member>
        <member name="F:KPCAP.WinPcap.UnmanagedStructures.pcap_rmtauth.username">
            <summary>
            Username
            </summary>
        </member>
        <member name="F:KPCAP.WinPcap.UnmanagedStructures.pcap_rmtauth.password">
            <summary>
            Password
            </summary>
        </member>
        <member name="T:KPCAP.Version">
            <summary>
            Helper class/method to retrieve the version of the KPCAP assembly
            </summary>
        </member>
        <member name="P:KPCAP.Version.VersionString">
            <summary>
            Returns the current version string of the KPCAP library
            </summary>
            <returns>the current version string of the KPCAP library</returns>
        </member>
        <member name="T:KPCAP.LibPcap.PcapHeader">
            <summary>
             A wrapper class for libpcap's pcap_pkthdr structure
            </summary>
        </member>
        <member name="M:KPCAP.LibPcap.PcapHeader.#ctor">
            <summary>
            Constructs a new PcapHeader
            </summary>
        </member>
        <member name="M:KPCAP.LibPcap.PcapHeader.#ctor(System.UInt64,System.UInt64,System.UInt32,System.UInt32)">
            <summary>
            Constructs a new PcapHeader
            </summary>
            <param name="seconds">The seconds value of the packet's timestamp</param>
            <param name="microseconds">The microseconds value of the packet's timestamp</param>
            <param name="packetLength">The actual length of the packet</param>
            <param name="captureLength">The length of the capture</param>
        </member>
        <member name="M:KPCAP.LibPcap.PcapHeader.MarshalToIntPtr">
             <summary>
             Marshal this structure into the platform dependent version and return
             and IntPtr to that memory
            
             NOTE: IntPtr MUST BE FREED via Marshal.FreeHGlobal()
             </summary>
             <returns>
             A <see cref="T:System.IntPtr"/>
             </returns>
        </member>
        <member name="P:KPCAP.LibPcap.PcapHeader.Seconds">
            <summary>
            The seconds value of the packet's timestamp
            </summary>
        </member>
        <member name="P:KPCAP.LibPcap.PcapHeader.MicroSeconds">
            <summary>
            The microseconds value of the packet's timestamp
            </summary>
        </member>
        <member name="P:KPCAP.LibPcap.PcapHeader.PacketLength">
            <summary>
            The actual length of the packet
            </summary>
        </member>
        <member name="P:KPCAP.LibPcap.PcapHeader.CaptureLength">
            <summary>
            The length of the capture
            </summary>
        </member>
        <member name="P:KPCAP.LibPcap.PcapHeader.Date">
            <summary>
            Return the DateTime value of this pcap header
            </summary>
        </member>
        <member name="T:KPCAP.AirPcap.AirPcapDeviceCapabilities">
            <summary>
            Capabilities for the adapter
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapDeviceCapabilities.AdapterId">
            <summary>
            An id that identifies the adapter model
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapDeviceCapabilities.AdapterModelName">
            <summary>
            String containing a printable adapter model
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapDeviceCapabilities.AdapterBus">
            <summary>
            The type of bus the adapter is plugged to
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapDeviceCapabilities.SupportedMedia">
            <summary>
            An OR combination of the media that the device supports. Possible values are: \ref AIRPCAP_MEDIUM_802_11_A,
            \ref AIRPCAP_MEDIUM_802_11_B, \ref AIRPCAP_MEDIUM_802_11_G or \ref AIRPCAP_MEDIUM_802_11_N.
            Not supported at the moment.
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapDeviceCapabilities.SupportedBands">
            <summary>
            An OR combination of the bands that the device supports. Can be one of: \ref AIRPCAP_BAND_2GHZ, 
            \ref AIRPCAP_BAND_5GHZ.
            </summary>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapDeviceCapabilities.ToString">
            <summary>
            ToString() overload
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapDeviceCapabilities.CanTransmit">
            <summary>
            TRUE if the adapter is able to perform frame injection.
            </summary>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapDeviceCapabilities.CanSetTransmitPower">
            <summary>
            TRUE if the adapter's transmit power is can be specified by the user application.
            </summary>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapDeviceCapabilities.ExternalAntennaPlug">
            <summary>
            TRUE if the adapter supports plugging one or more external antennas.
            </summary>
        </member>
        <member name="T:KPCAP.AirPcap.AirPcapPacketHeader">
            <summary>
            Packet header
            </summary>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapPacketHeader.ToString">
            <summary>
            ToString() override
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapPacketHeader.TsSec">
            <summary>
            Seconds field
            </summary>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapPacketHeader.TsUsec">
            <summary>
            Microseconds field
            </summary>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapPacketHeader.Caplen">
            <summary>
            Number of bytes captured
            </summary>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapPacketHeader.Originallen">
            <summary>
            On-line packet size in bytes
            </summary>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapPacketHeader.Hdrlen">
            <summary>
            Header length in bytes
            </summary>
        </member>
        <member name="T:KPCAP.LibPcap.OfflinePcapDevice">
            <summary>
            Capture packets from an offline pcap file
            </summary>
        </member>
        <member name="F:KPCAP.LibPcap.OfflinePcapDevice.PCAP_OFFLINE_DESCRIPTION">
            <summary>
            The description of this device
            </summary>
        </member>
        <member name="M:KPCAP.LibPcap.OfflinePcapDevice.#ctor(System.String)">
            <summary>
            Constructs a new offline device for reading 
            pcap files
            </summary>
            <param name="pcapFile"></param>
        </member>
        <member name="M:KPCAP.LibPcap.OfflinePcapDevice.Open">
            <summary>
            Opens the device for capture
            </summary>
        </member>
        <member name="P:KPCAP.LibPcap.OfflinePcapDevice.Name">
            <value>
            The name of the capture file
            </value>
        </member>
        <member name="P:KPCAP.LibPcap.OfflinePcapDevice.Description">
            <value>
            Description of the device
            </value>
        </member>
        <member name="P:KPCAP.LibPcap.OfflinePcapDevice.FileSize">
            <value>
            Number of bytes in the capture file
            </value>
        </member>
        <member name="P:KPCAP.LibPcap.OfflinePcapDevice.FileName">
            <summary>
            The underlying pcap file name
            </summary>
        </member>
        <member name="P:KPCAP.LibPcap.OfflinePcapDevice.Statistics">
            <summary>
            Retrieves pcap statistics
            </summary>
            <returns>
            A <see cref="T:KPCAP.LibPcap.PcapStatistics"/>
            </returns>
        </member>
        <member name="T:KPCAP.AirPcap.AirPcapMacFlags">
            <summary>
            Mac flags
            </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapMacFlags.MonitorModeOn">
            <summary>
             If set, the device is configured to work in monitor mode.
             When monitor mode is on, the device captures all the frames transmitted on the channel. This includes:
                - unicast packets
                - multicast packets
                - broadcast packets
                - control and management packets
            
             When monitor mode is off, the device has a filter on unicast packets to capture only the packets whose MAC
             destination address equals the device's address. This means the following frames will be received:
               - unicast packets whose destination is the address of the device
               - multicast packets
               - broadcast packets
               - beacons and probe requests
             </summary>
        </member>
        <member name="F:KPCAP.AirPcap.AirPcapMacFlags.AckFramesOn">
            <summary>
             If set, the device will acknowledge the data frames sent to its address. This is useful when the device needs to interact with other devices on the 
             802.11 network, bacause handling the ACKs in software is normally too slow.
            </summary>
        </member>
        <member name="T:KPCAP.AirPcap.AirPcapDeviceDescription">
            <summary>
            Adapter description
            </summary>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapDeviceDescription.ToString">
            <summary>
            ToString() override
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapDeviceDescription.Name">
            <summary>
            Device name
            </summary>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapDeviceDescription.Description">
            <summary>
            Device description
            </summary>
        </member>
        <member name="T:KPCAP.WinPcap.WinPcapDeviceList">
            <summary>
            Remote adapter list
            </summary>
        </member>
        <member name="F:KPCAP.WinPcap.WinPcapDeviceList.RpcapdDefaultPort">
            <summary>
            Port used by rpcapd by default
            </summary>
        </member>
        <member name="M:KPCAP.WinPcap.WinPcapDeviceList.#ctor">
            <summary>
            Represents a strongly typed, read-only list of PcapDevices.
            </summary>
        </member>
        <!-- Commentaire XML incorrect ignoré pour le membre "M:KPCAP.WinPcap.WinPcapDeviceList.Devices(System.Net.IPAddress,System.Int32,KPCAP.WinPcap.RemoteAuthentication)" -->
        <member name="M:KPCAP.WinPcap.WinPcapDeviceList.GetDevices">
            <summary>
            Retrieve the local devices
            </summary>
            <returns></returns>
        </member>
        <member name="M:KPCAP.WinPcap.WinPcapDeviceList.Refresh">
            <summary>
            Refresh the device list
            </summary>
        </member>
        <member name="P:KPCAP.WinPcap.WinPcapDeviceList.Instance">
            <summary>
            Method to retrieve this classes singleton instance
            </summary>
        </member>
        <member name="P:KPCAP.WinPcap.WinPcapDeviceList.Item(System.String)">
            <param name="Name">The name or description of the pcap interface to get.</param>
        </member>
        <member name="T:KPCAP.WinPcap.StatisticsModeEventHandler">
            <summary>
            A delegate for delivering network statistics when using winpcap in
            statistics mode
            </summary>
        </member>
        <member name="T:KPCAP.OfflineCaptureDevice">
            <summary>
            Capture device that reads from a pcap format file
            </summary>
        </member>
        <member name="M:KPCAP.OfflineCaptureDevice.#ctor(System.String)">
            <summary>
            Default constructor
            </summary>
            <param name="pcapFile">
            A <see cref="T:System.String"/>
            </param>
        </member>
        <member name="T:KPCAP.AirPcap.AirPcapStatistics">
            <summary>
            Device statistics
            </summary>
        </member>
        <member name="M:KPCAP.AirPcap.AirPcapStatistics.ToString">
            <summary>
            ToString override 
            </summary>
            <returns></returns>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapStatistics.ReceivedPackets">
            <value>
            Number of packets received
            </value>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapStatistics.DroppedPackets">
            <value>
            Number of packets dropped
            </value>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapStatistics.InterfaceDroppedPackets">
            <value>
            Number of interface dropped packets
            </value>
        </member>
        <member name="P:KPCAP.AirPcap.AirPcapStatistics.CapturedPackets">
            <summary>
            Number of packets that pass the BPF filter, find place in the kernel buffer and
            therefore reach the application.
            </summary>
        </member>
        <member name="T:Kavprot.Packets.WakeOnLanPacket">
            <summary>
            Wake-On-Lan
            See: http://en.wikipedia.org/wiki/Wake-on-LAN
            See: http://wiki.wireshark.org/WakeOnLAN
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Packet">
            <summary>
            Base class for all packet types.
            Defines helper methods and accessors for the architecture that underlies how
            packets interact and store their data.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Packet.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Packet.ParsePacket(Kavprot.Packets.LinkLayers,System.Byte[])">
            <summary>
            Parse bytes into a packet
            </summary>
            <param name="LinkLayer">
            A <see cref="T:Kavprot.Packets.LinkLayers"/>
            </param>
            <param name="PacketData">
            A <see cref="T:System.Byte"/>
            </param>
            <returns>
            A <see cref="T:Kavprot.Packets.Packet"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.Packet.RecursivelyUpdateCalculatedValues">
            <summary>
            Used to ensure that values like checksums and lengths are
            properly updated
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Packet.UpdateCalculatedValues">
             <summary>
             Called to ensure that calculated values are updated before
             the packet bytes are retrieved
            
             Classes should override this method to update things like
             checksums and lengths that take too much time or are too complex
             to update for each packet parameter change
             </summary>
        </member>
        <member name="M:Kavprot.Packets.Packet.ToString">
            <summary>Output this packet as a readable string</summary>
        </member>
        <member name="M:Kavprot.Packets.Packet.ToString(Kavprot.Packets.StringOutputType)">
             <summary cref="M:Kavprot.Packets.Packet.ToString">
            
             Output the packet information in the specified format
               Normal - outputs the packet info to a single line
               Colored - outputs the packet info to a single line with coloring
               Verbose - outputs detailed info about the packet
               VerboseColored - outputs detailed info about the packet with coloring
             </summary>
             <param name="outputFormat">
             <see cref="T:Kavprot.Packets.StringOutputType"/>
             </param>
        </member>
        <member name="M:Kavprot.Packets.Packet.PrintHex">
            <summary>
            Prints the Packet PayloadData in Hex format
             With the 16-byte segment number, raw bytes, and parsed ascii output
            Ex:
             0010  00 18 82 6c 7c 7f 00 c0  9f 77 a3 b0 88 64 11 00   ...1|... .w...d..
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Packet.SharesMemoryWithSubPackets">
             <value>
             Returns true if we already have a contiguous byte[] in either
             of these conditions:
            
             - This packet's header byte[] and payload byte[] are the same instance
             or
             - This packet's header byte[] and this packet's payload packet
             are the same instance and the offsets indicate that the bytes
             are contiguous
             </value>
        </member>
        <member name="P:Kavprot.Packets.Packet.ParentPacket">
            <summary>
            The packet that is carrying this one
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Packet.Header">
            <value>
            Returns a
            </value>
        </member>
        <member name="P:Kavprot.Packets.Packet.PayloadPacket">
            <summary>
            Packet that this packet carries if one is present.
            Note that the packet MAY have a null PayloadPacket but
            a non-null PayloadData
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Packet.PayloadData">
            <summary>
            Payload byte[] if one is present.
            Note that the packet MAY have a null PayloadData but a
            non-null PayloadPacket
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Packet.Bytes">
            <summary>
            byte[] containing this packet and its payload
            NOTE: Use 'public virtual ByteArraySegment BytesHighPerformance' for highest performance
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Packet.BytesHighPerformance">
            <value>
            The option to return a ByteArraySegment means that this method
            is higher performance as the data can start at an offset other than
            the first byte.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Packet.Color">
            <value>
            Color used when generating the text description of a packet
            </value>
        </member>
        <member name="M:Kavprot.Packets.WakeOnLanPacket.#ctor(System.Net.NetworkInformation.PhysicalAddress)">
            <summary>
            Create a Wake-On-LAN packet from the destination MAC address
            </summary>
            <param name="destinationMAC">
            A <see cref="T:System.Net.NetworkInformation.PhysicalAddress"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.WakeOnLanPacket.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Constructor
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.WakeOnLanPacket.GetEncapsulated(Kavprot.Packets.Packet)">
            <summary>
            Returns the embedded Wake-On-LAN packet
             or null if there is none
            </summary>
            <returns>
            A Wake-On-LAN packet
            </returns>
        </member>
        <member name="M:Kavprot.Packets.WakeOnLanPacket.RandomPacket">
            <summary>
            Generate a random WakeOnLanPacket
            </summary>
            <returns>
            A <see cref="T:Kavprot.Packets.WakeOnLanPacket"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.WakeOnLanPacket.IsValid">
            <summary>
            Checks the validity of the Wake-On-LAN payload
             - by checking the synchronization sequence
             - by checking to see if there are 16 iterations of the Destination MAC address
            </summary>
            <returns>
            True if the Wake-On-LAN payload is valid
            </returns>
        </member>
        <member name="M:Kavprot.Packets.WakeOnLanPacket.IsValid(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            See IsValid
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
            <returns>
            A <see cref="T:System.Boolean"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.WakeOnLanPacket.Equals(System.Object)">
            <summary>
            Compare two instances
            </summary>
            <param name="obj">
            A <see cref="T:System.Object"/>
            </param>
            <returns>
            A <see cref="T:System.Boolean"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.WakeOnLanPacket.GetHashCode">
            <summary>
            GetHashCode override
            </summary>
            <returns>
            A <see cref="T:System.Int32"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.WakeOnLanPacket.ToString(Kavprot.Packets.StringOutputType)">
            <summary cref="M:Kavprot.Packets.Packet.ToString(Kavprot.Packets.StringOutputType)"/>
        </member>
        <member name="P:Kavprot.Packets.WakeOnLanPacket.DestinationMAC">
            <summary>
            The Physical Address (MAC) of the host being woken up from sleep
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Tcp.OptionTypes">
            <summary>
            The different types fields that could be found in the Options field
            </summary>
            <remarks>
            References:
             http://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_Timestamps
             http://www.networksorcery.com/enp/default1101.htm
            </remarks>
        </member>
        <member name="F:Kavprot.Packets.Tcp.OptionTypes.EndOfOptionList">
            <summary>End Of List</summary>
            <remarks>See RFC 793</remarks>
        </member>
        <member name="F:Kavprot.Packets.Tcp.OptionTypes.NoOperation">
            <summary>No Operation</summary>
            <remarks>See RFC 793</remarks>
        </member>
        <member name="F:Kavprot.Packets.Tcp.OptionTypes.MaximumSegmentSize">
            <summary>Maximum Segment Size</summary>
            <remarks>See RFC 793</remarks>
        </member>
        <member name="F:Kavprot.Packets.Tcp.OptionTypes.WindowScaleFactor">
            <summary>Window Scale Factor</summary>
            <remarks>See RFC 1323</remarks>
        </member>
        <member name="F:Kavprot.Packets.Tcp.OptionTypes.SACKPermitted">
            <summary>SACK (Selective Ack) Permitted</summary>
            <remarks>See RFC 2018</remarks>
        </member>
        <member name="F:Kavprot.Packets.Tcp.OptionTypes.SACK">
            <summary>SACK (Selective Ack)</summary>
            <remarks>See RFC 2018 and RFC 2883</remarks>
        </member>
        <member name="F:Kavprot.Packets.Tcp.OptionTypes.Echo">
            <summary>Echo (obsolete)</summary>
            <remarks>See RFC 1072</remarks>
        </member>
        <member name="F:Kavprot.Packets.Tcp.OptionTypes.EchoReply">
            <summary>Echo Reply (obsolete)</summary>
            <remarks>See RFC 1072</remarks>
        </member>
        <member name="F:Kavprot.Packets.Tcp.OptionTypes.Timestamp">
            <summary>Timestamp</summary>
            <remarks>See RFC 1323</remarks>
        </member>
        <member name="F:Kavprot.Packets.Tcp.OptionTypes.POConnectionPermitted">
            <summary>Partial Order Connection Permitted (experimental)</summary>
            <remarks>See RFC 1693</remarks>
        </member>
        <member name="F:Kavprot.Packets.Tcp.OptionTypes.POServiceProfile">
            <summary>Partial Order Service Profile (experimental)</summary>
            <remarks>See RFC 1693</remarks>
        </member>
        <member name="F:Kavprot.Packets.Tcp.OptionTypes.ConnectionCount">
            <summary>Connection Count (experimental)</summary>
            <remarks>See RFC 1644</remarks>
        </member>
        <member name="F:Kavprot.Packets.Tcp.OptionTypes.ConnectionCountNew">
            <summary>Connection Count New (experimental)</summary>
            <remarks>See RFC 1644</remarks>
        </member>
        <member name="F:Kavprot.Packets.Tcp.OptionTypes.ConnectionCountEcho">
            <summary>Connection Count Echo (experimental)</summary>
            <remarks>See RFC 1644</remarks>
        </member>
        <member name="F:Kavprot.Packets.Tcp.OptionTypes.AlternateChecksumRequest">
            <summary>Alternate Checksum Request</summary>
            <remarks>See RFC 1146</remarks>
        </member>
        <member name="F:Kavprot.Packets.Tcp.OptionTypes.AlternateChecksumData">
            <summary>Alternate Checksum Data</summary>
            <remarks>See RFC 1146</remarks>
        </member>
        <member name="F:Kavprot.Packets.Tcp.OptionTypes.MD5Signature">
            <summary>MD5 Signature</summary>
            <remarks>See RFC 2385</remarks>
        </member>
        <member name="F:Kavprot.Packets.Tcp.OptionTypes.QuickStartResponse">
            <summary>Quick-Start Response (experimental)</summary>
            <remarks>See RFC 4782</remarks>
        </member>
        <member name="F:Kavprot.Packets.Tcp.OptionTypes.UserTimeout">
            <summary>User Timeout</summary>
            <remarks>See RFC 5482</remarks>
        </member>
        <member name="T:Kavprot.Packets.LLDP.InterfaceNumbering">
            <summary>
            Interface Numbering Types
            </summary>
            <remarks>Source IETF RFC 802.1AB</remarks>
        </member>
        <member name="F:Kavprot.Packets.LLDP.InterfaceNumbering.Unknown">
            <summary>Unknown</summary>
        </member>
        <member name="F:Kavprot.Packets.LLDP.InterfaceNumbering.ifIndex">
            <summary>Interface Index</summary>
        </member>
        <member name="F:Kavprot.Packets.LLDP.InterfaceNumbering.SystemPortNumber">
            <summary>System Port Number</summary>
        </member>
        <member name="T:Kavprot.Packets.LinuxSLLPacket">
             <summary>
             Represents a Linux cooked capture packet, the kinds of packets
             received when capturing on an 'any' device
            
             See http://github.com/mcr/libpcap/blob/master/pcap/sll.h
             </summary>
        </member>
        <member name="T:Kavprot.Packets.InternetLinkLayerPacket">
            <summary>
            Internet Link layer packet
            See http://en.wikipedia.org/wiki/Link_Layer
            </summary>
        </member>
        <member name="M:Kavprot.Packets.InternetLinkLayerPacket.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Kavprot.Packets.InternetLinkLayerPacket.GetInnerPayload(Kavprot.Packets.InternetLinkLayerPacket)">
            <summary>
            Look for the innermost payload. This method is useful because
            while some packets are LinuxSSL-&gt;IpPacket or
            EthernetPacket-&gt;IpPacket, there are some packets that are
            EthernetPacket-&gt;PPPoEPacket-&gt;PPPPacket-&gt;IpPacket, and for these cases
            we really want to get to the IpPacket
            </summary>
            <returns>
            A <see cref="T:Kavprot.Packets.Packet"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.LinuxSLLPacket.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Constructor
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.LinuxSLLPacket.ToString(Kavprot.Packets.StringOutputType)">
            <summary cref="M:Kavprot.Packets.Packet.ToString(Kavprot.Packets.StringOutputType)"/>
        </member>
        <member name="P:Kavprot.Packets.LinuxSLLPacket.Type">
            <value>
            Information about the packet direction
            </value>
        </member>
        <member name="P:Kavprot.Packets.LinuxSLLPacket.LinkLayerAddressType">
            <value>
            The
            </value>
        </member>
        <member name="P:Kavprot.Packets.LinuxSLLPacket.LinkLayerAddressLength">
            <value>
            Number of bytes in the link layer address of the sender of the packet
            </value>
        </member>
        <member name="P:Kavprot.Packets.LinuxSLLPacket.LinkLayerAddress">
            <value>
            Link layer header bytes, maximum of 8 bytes
            </value>
        </member>
        <member name="P:Kavprot.Packets.LinuxSLLPacket.EthernetProtocolType">
            <value>
            The encapsulated protocol type
            </value>
        </member>
        <member name="T:Kavprot.Packets.DataLinkPacket">
            <summary>
            Represents a Layer 2 protocol.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.DataLinkPacket.#ctor">
            <summary>
            DataLinkPacket constructor
            </summary>
        </member>
        <member name="T:Kavprot.Packets.ARPOperation">
            <summary>
            The possible ARP operation values
            </summary>
            <remarks>
            References:
             - http://www.networksorcery.com/enp/default1101.htm
            </remarks>
        </member>
        <member name="F:Kavprot.Packets.ARPOperation.Request">
            <summary>Request</summary>
            <remarks>See RFC 826, RFC 5227</remarks>
        </member>
        <member name="F:Kavprot.Packets.ARPOperation.Response">
            <summary>Response</summary>
            <remarks>See RFC 826, RFC 1868, RFC 5227</remarks>
        </member>
        <member name="F:Kavprot.Packets.ARPOperation.RequestReverse">
            <summary>Request Reverse</summary>
            <remarks>See RFC 903</remarks>
        </member>
        <member name="F:Kavprot.Packets.ARPOperation.ReplyReverse">
            <summary>Reply Reverse</summary>
            <remarks>See RFC 903</remarks>
        </member>
        <member name="F:Kavprot.Packets.ARPOperation.DRARPRequest">
            <summary>DRARP Request</summary>
            <remarks>See RFC 1931</remarks>
        </member>
        <member name="F:Kavprot.Packets.ARPOperation.DRARPReply">
            <summary>DRARP Reply</summary>
            <remarks>See RFC 1931</remarks>
        </member>
        <member name="F:Kavprot.Packets.ARPOperation.DRARPError">
            <summary>DRARP Error</summary>
            <remarks>See RFC 1931</remarks>
        </member>
        <member name="F:Kavprot.Packets.ARPOperation.InARPRequest">
            <summary>InARP Request</summary>
            <remarks>See RFC 1293</remarks>
        </member>
        <member name="F:Kavprot.Packets.ARPOperation.InARPReply">
            <summary>InARP Reply</summary>
            <remarks>See RFC 1293</remarks>
        </member>
        <member name="F:Kavprot.Packets.ARPOperation.ARPNAK">
            <summary>ARP NAK</summary>
            <remarks>See RFC 1577</remarks>
        </member>
        <member name="F:Kavprot.Packets.ARPOperation.MARSRequest">
            <summary>MARS Request</summary>
        </member>
        <member name="F:Kavprot.Packets.ARPOperation.MARSMulti">
            <summary>MARS Multi</summary>
        </member>
        <member name="F:Kavprot.Packets.ARPOperation.MARSMServ">
            <summary>MARS MServ</summary>
        </member>
        <member name="F:Kavprot.Packets.ARPOperation.MARSJoin">
            <summary>MARS Join</summary>
        </member>
        <member name="F:Kavprot.Packets.ARPOperation.MARSLeave">
            <summary>MARS Leave</summary>
        </member>
        <member name="F:Kavprot.Packets.ARPOperation.MARSNAK">
            <summary>MARS NAK</summary>
        </member>
        <member name="F:Kavprot.Packets.ARPOperation.MARSUnserv">
            <summary>MARS Unserv</summary>
        </member>
        <member name="F:Kavprot.Packets.ARPOperation.MARSSJoin">
            <summary>MARS SJoin</summary>
        </member>
        <member name="F:Kavprot.Packets.ARPOperation.MARSSLeave">
            <summary>MARS SLeave</summary>
        </member>
        <member name="F:Kavprot.Packets.ARPOperation.MARSGrouplistRequest">
            <summary>MARS Grouplist Request</summary>
        </member>
        <member name="F:Kavprot.Packets.ARPOperation.MARSGrouplistReply">
            <summary>MARS Grouplist Reply</summary>
        </member>
        <member name="F:Kavprot.Packets.ARPOperation.MARSRedirectMap">
            <summary>MARS Redirect Map</summary>
        </member>
        <member name="F:Kavprot.Packets.ARPOperation.MaposUnarp">
            <summary>MARS UNARP</summary>
            <remarks>See RFC 2176</remarks>
        </member>
        <member name="F:Kavprot.Packets.ARPOperation.OP_EXP1">
            <summary>OP_EXP1</summary>
            <remarks>See RFC 5494</remarks>
        </member>
        <member name="F:Kavprot.Packets.ARPOperation.OP_EXP2">
            <summary>OP_EXP2</summary>
        </member>
        <member name="T:Kavprot.Packets.Utils.ChecksumUtils">
            <summary>
            Computes the one's sum on a byte array.
            Based TCP/IP Illustrated Vol. 2(1995) by Gary R. Wright and W. Richard
            Stevens. Page 236. And on http://www.cs.utk.edu/~cs594np/unp/checksum.html
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Utils.ChecksumUtils.OnesComplementSum(System.Byte[])">
            <summary>
            Computes the one's complement sum on a byte array
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Utils.ChecksumUtils.OnesComplementSum(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Computes the one's complement sum on a byte array
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Utils.ChecksumUtils.OnesSum(System.Byte[])">
            <summary>
            Compute a ones sum of a byte array
            </summary>
            <param name="bytes">
            A <see cref="T:System.Byte"/>
            </param>
            <returns>
            A <see cref="T:System.Int32"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.Utils.ChecksumUtils.OnesSum(System.Byte[],System.Int32,System.Int32)">
            <summary>
            16 bit sum of all values
            http://en.wikipedia.org/wiki/Signed_number_representations#Ones.27_complement
            </summary>
            <param name="bytes">
            A <see cref="T:System.Byte"/>
            </param>
            <param name="start">
            A <see cref="T:System.Int32"/>
            </param>
            <param name="len">
            A <see cref="T:System.Int32"/>
            </param>
            <returns>
            A <see cref="T:System.Int32"/>
            </returns>
        </member>
        <member name="T:Kavprot.Packets.UdpFields">
            <summary>
            Defines the lengths and positions of the udp fields within
            a udp packet
            </summary>
        </member>
        <member name="F:Kavprot.Packets.UdpFields.PortLength">
            <summary> Length of a UDP port in bytes.</summary>
        </member>
        <member name="F:Kavprot.Packets.UdpFields.HeaderLengthLength">
            <summary> Length of the header length field in bytes.</summary>
        </member>
        <member name="F:Kavprot.Packets.UdpFields.ChecksumLength">
            <summary> Length of the checksum field in bytes.</summary>
        </member>
        <member name="F:Kavprot.Packets.UdpFields.SourcePortPosition">
            <summary> Position of the source port.</summary>
        </member>
        <member name="F:Kavprot.Packets.UdpFields.DestinationPortPosition">
            <summary> Position of the destination port.</summary>
        </member>
        <member name="F:Kavprot.Packets.UdpFields.HeaderLengthPosition">
            <summary> Position of the header length.</summary>
        </member>
        <member name="F:Kavprot.Packets.UdpFields.ChecksumPosition">
            <summary> Position of the header checksum length.</summary>
        </member>
        <member name="F:Kavprot.Packets.UdpFields.HeaderLength">
            <summary> Length of a UDP header in bytes.</summary>
        </member>
        <member name="T:Kavprot.Packets.Tcp.TimeStamp">
             <summary>
             A Time Stamp Option
              Used for RTTM (Round Trip Time Measurement)
              and PAWS (Protect Against Wrapped Sequences)
            
              Opsoletes the Echo and EchoReply option fields
             </summary>
             <remarks>
             References:
              http://datatracker.ietf.org/doc/rfc1323/
             </remarks>
        </member>
        <member name="T:Kavprot.Packets.Tcp.Option">
            <summary>
            A TCP Option
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Tcp.Option.KindFieldLength">
            <summary>The length (in bytes) of the Kind field</summary>
        </member>
        <member name="F:Kavprot.Packets.Tcp.Option.LengthFieldLength">
            <summary>The length (in bytes) of the Length field</summary>
        </member>
        <member name="F:Kavprot.Packets.Tcp.Option.KindFieldOffset">
            <summary>The offset (in bytes) of the Kind Field</summary>
        </member>
        <member name="F:Kavprot.Packets.Tcp.Option.LengthFieldOffset">
            <summary>The offset (in bytes) of the Length field</summary>
        </member>
        <member name="M:Kavprot.Packets.Tcp.Option.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Creates an Option from a byte[]
            </summary>
            <param name="bytes">
            A <see cref="!:System.Byte[]"/>
            </param>
            <param name="offset">
            A <see cref="T:System.Int32"/>
            </param>
            <param name="length">
            A <see cref="T:System.Int32"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Tcp.Option.ToString">
            <summary>
            Returns the Option info as a string
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Tcp.Option.Length">
            <summary>
            The Length of the Option type
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Tcp.Option.Kind">
            <summary>
            The Kind of option
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Tcp.Option.Bytes">
            <summary>
            Returns a TLV that contains the Option
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Tcp.TimeStamp.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Creates a Timestamp Option
            </summary>
            <param name="bytes">
            A <see cref="!:System.Byte[]"/>
            </param>
            <param name="offset">
            A <see cref="T:System.Int32"/>
            </param>
            <param name="length">
            A <see cref="T:System.Int32"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Tcp.TimeStamp.ToString">
            <summary>
            Returns the Option info as a string
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Tcp.TimeStamp.Value">
            <summary>
            The Timestamp value
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Tcp.TimeStamp.EchoReply">
            <summary>
            The Echo Reply
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Tcp.SACKPermitted">
            <summary>
            SACK (Selective Ack) Permitted Option
             Notifies the receiver that SACK is allowed.
             Must only be sent in a SYN segment
            </summary>
            <remarks>
            References:
             http://datatracker.ietf.org/doc/rfc2018/
            </remarks>
        </member>
        <member name="M:Kavprot.Packets.Tcp.SACKPermitted.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Creates a Sack Permitted Option
            </summary>
            <param name="bytes">
            A <see cref="!:System.Byte[]"/>
            </param>
            <param name="offset">
            A <see cref="T:System.Int32"/>
            </param>
            <param name="length">
            A <see cref="T:System.Int32"/>
            </param>
        </member>
        <member name="T:Kavprot.Packets.PPPoECode">
            <summary>
            Values for the Code field of a PPPoE packet
            See http://tools.ietf.org/html/rfc2516
            </summary>
        </member>
        <member name="F:Kavprot.Packets.PPPoECode.SessionStage">
            <summary>
            The PPPoe payload must contain a PPP packet
            </summary>
        </member>
        <member name="F:Kavprot.Packets.PPPoECode.ActiveDiscoveryOffer">
            <summary>
            Active Discovery Offer (PADO) packet
            </summary>
        </member>
        <member name="F:Kavprot.Packets.PPPoECode.ActiveDiscoveryInitiation">
             <summary>
             From RFC2516:
             The Host sends the PADI packet with the DESTINATION_ADDR set to the
             broadcast address.  The CODE field is set to 0x09 and the SESSION_ID
             MUST be set to 0x0000.
            
             The PADI packet MUST contain exactly one TAG of TAG_TYPE Service-
             Name, indicating the service the Host is requesting, and any number
             of other TAG types.  An entire PADI packet (including the PPPoE
             header) MUST NOT exceed 1484 octets so as to leave sufficient room
             for a relay agent to add a Relay-Session-Id TAG.
             </summary>
        </member>
        <member name="F:Kavprot.Packets.PPPoECode.ActiveDiscoveryTerminate">
            <summary>
            Indicate that the PPPoe session specified by the SessionId field of
            the PPPoe packet has been terminated
            </summary>
        </member>
        <member name="T:MiscUtil.Conversion.Endianness">
            <summary>
            Endianness of a converter
            </summary>
        </member>
        <member name="F:MiscUtil.Conversion.Endianness.LittleEndian">
            <summary>
            Little endian - least significant byte first
            </summary>
        </member>
        <member name="F:MiscUtil.Conversion.Endianness.BigEndian">
            <summary>
            Big endian - most significant byte first
            </summary>
        </member>
        <member name="T:Kavprot.Packets.IpPacket">
            <summary>
            Base class for IPv4 and IPv6 packets that exports the common
            functionality that both of these classes has in common
            </summary>
        </member>
        <member name="T:Kavprot.Packets.InternetPacket">
            <summary>
            Internet packets include IPv4, IPv6, IGMP etc, see
            http://en.wikipedia.org/wiki/Internet_Layer
            </summary>
        </member>
        <member name="M:Kavprot.Packets.InternetPacket.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="F:Kavprot.Packets.IpPacket.DefaultTimeToLive">
            <summary>
            The default time to live value for Ip packets being constructed
            </summary>
        </member>
        <member name="M:Kavprot.Packets.IpPacket.AttachPseudoIPHeader(System.Byte[])">
            <summary>
            Adds a pseudo ip header to a given packet. Used to generate the full
            byte array required to generate a udp or tcp checksum.
            </summary>
            <param name="origHeader">
            A <see cref="T:System.Byte"/>
            </param>
            <returns>
            A <see cref="T:System.Byte"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.IpPacket.GetIPAddress(System.Net.Sockets.AddressFamily,System.Int32,System.Byte[])">
            <summary>
            Convert an ip address from a byte[]
            </summary>
            <param name="ipType">
            A <see cref="T:System.Net.Sockets.AddressFamily"/>
            </param>
            <param name="fieldOffset">
            A <see cref="T:System.Int32"/>
            </param>
            <param name="bytes">
            A <see cref="T:System.Byte"/>
            </param>
            <returns>
            A <see cref="T:System.Net.IPAddress"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.IpPacket.#ctor">
            <summary>
            IpPacket constructor
            </summary>
        </member>
        <member name="M:Kavprot.Packets.IpPacket.ParseEncapsulatedBytes(Kavprot.Packets.Utils.ByteArraySegment,Kavprot.Packets.IPProtocolType,Kavprot.Packets.Packet)">
            <summary>
            Called by IPv4 and IPv6 packets to parse their packet payload
            </summary>
            <param name="payload">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
            <param name="ProtocolType">
            A <see cref="T:Kavprot.Packets.IPProtocolType"/>
            </param>
            <param name="ParentPacket">
            A <see cref="T:Kavprot.Packets.Packet"/>
            </param>
            <returns>
            A <see cref="T:Kavprot.Packets.PacketOrByteArraySegment"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.IpPacket.GetEncapsulated(Kavprot.Packets.Packet)">
            <summary>
            Returns the IpPacket inside of the Packet p or null if
            there is no encapsulated packet
            </summary>
            <param name="p">
            A <see cref="T:Kavprot.Packets.Packet"/>
            </param>
            <returns>
            A <see cref="T:Kavprot.Packets.IpPacket"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.IpPacket.RandomPacket(Kavprot.Packets.IpVersion)">
            <summary>
            Generate a random packet of a specific ip version
            </summary>
            <param name="version">
            A <see cref="T:Kavprot.Packets.IpVersion"/>
            </param>
            <returns>
            A <see cref="T:Kavprot.Packets.IpPacket"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.IpPacket.PayloadPacket">
            <value>
            Payload packet, overridden to set the NextHeader/Protocol based
            on the type of payload packet when the payload packet is set
            </value>
        </member>
        <member name="P:Kavprot.Packets.IpPacket.DestinationAddress">
            <value>
            The destination address
            </value>
        </member>
        <member name="P:Kavprot.Packets.IpPacket.SourceAddress">
            <value>
            The source address
            </value>
        </member>
        <member name="P:Kavprot.Packets.IpPacket.Version">
            <value>
            The IP version
            </value>
        </member>
        <member name="P:Kavprot.Packets.IpPacket.Protocol">
            <value>
            The protocol of the ip packet's payload
            Named 'Protocol' in IPv4
            Named 'NextHeader' in IPv6'
            </value>
        </member>
        <member name="P:Kavprot.Packets.IpPacket.NextHeader">
            <value>
            The protocol of the ip packet's payload
            Included along side Protocol for user convienence
            </value>
        </member>
        <member name="P:Kavprot.Packets.IpPacket.TimeToLive">
            <value>
            The number of hops remaining before this packet is discarded
            Named 'TimeToLive' in IPv4
            Named 'HopLimit' in IPv6
            </value>
        </member>
        <member name="P:Kavprot.Packets.IpPacket.HopLimit">
            <value>
            The number of hops remaining for this packet
            Included along side of TimeToLive for user convienence
            </value>
        </member>
        <member name="P:Kavprot.Packets.IpPacket.HeaderLength">
            <summary>
            ipv4 header length field, calculated for ipv6 packets
            NOTE: This field is the number of 32bit words in the ip header,
                  ie. the number of bytes is 4x this value
            </summary>
        </member>
        <member name="P:Kavprot.Packets.IpPacket.TotalLength">
            <summary>
            ipv4 total number of bytes in the ipv4 header + payload,
            ipv6 PayloadLength + IPv6Fields.HeaderLength
            </summary>
        </member>
        <member name="P:Kavprot.Packets.IpPacket.PayloadLength">
            <summary>
            ipv6 payload length in bytes,
            calculate from ipv4.TotalLength - (ipv4.HeaderLength * 4)
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Utils.ByteArraySegment">
            <summary>
            Container class that refers to a segment of bytes in a byte[]
            Used to ensure high performance by allowing memory copies to
            be avoided
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Utils.ByteArraySegment.#ctor(System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="Bytes">
            A <see cref="!:System.Byte[]"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Utils.ByteArraySegment.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Constructor from a byte array, offset into the byte array and
            a length beyond that offset of the bytes this class is referencing
            </summary>
            <param name="Bytes">
            A <see cref="T:System.Byte"/>
            </param>
            <param name="Offset">
            A <see cref="T:System.Int32"/>
            </param>
            <param name="Length">
            A <see cref="T:System.Int32"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Utils.ByteArraySegment.#ctor(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructor
            </summary>
            <param name="Bytes">
            A <see cref="!:System.Byte[]"/>
            </param>
            <param name="Offset">
            A <see cref="T:System.Int32"/>
            </param>
            <param name="Length">
            A <see cref="T:System.Int32"/>
            </param>
            <param name="BytesLength">
            A <see cref="T:System.Int32"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Utils.ByteArraySegment.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Copy constructor
            </summary>
            <param name="original">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Utils.ByteArraySegment.ActualBytes">
             <summary>
             Returns a contiguous byte[] from this container, if necessary, by copying
             the bytes from the current offset into a newly allocated byte[].
             NeedsCopyForActualBytes can be used to determine if the copy is necessary
            
             </summary>
             <returns>
             A <see cref="T:System.Byte"/>
             </returns>
        </member>
        <member name="M:Kavprot.Packets.Utils.ByteArraySegment.EncapsulatedBytes">
            <summary>
            Helper method that returns the segment immediately following
            this instance, useful for processing where the parent
            wants to pass the next segment to a sub class for processing
            </summary>
            <returns>
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.Utils.ByteArraySegment.EncapsulatedBytes(System.Int32)">
            <summary>
            Create the segment after the current one
            </summary>
            <param name="NewSegmentLength">
            A <see cref="T:System.Int32"/> that can be used to limit the segment length
            of the ByteArraySegment that is to be returned. Often used to exclude trailing bytes.
            </param>
            <returns>
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.Utils.ByteArraySegment.ToString">
            <summary>
            Format the class information as a string
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Utils.ByteArraySegment.Bytes">
            <value>
            The byte[] array
            </value>
        </member>
        <member name="P:Kavprot.Packets.Utils.ByteArraySegment.BytesLength">
            <value>
            The maximum number of bytes we should treat Bytes as having, allows
            for controling the number of bytes produced by EncapsulatedBytes()
            </value>
        </member>
        <member name="P:Kavprot.Packets.Utils.ByteArraySegment.Length">
            <value>
            Number of bytes beyond the offset into Bytes
            </value>
        </member>
        <member name="P:Kavprot.Packets.Utils.ByteArraySegment.Offset">
            <value>
            Offset into Bytes
            </value>
        </member>
        <member name="P:Kavprot.Packets.Utils.ByteArraySegment.NeedsCopyForActualBytes">
            <summary>
            Return true if we need to perform a copy to get
            the bytes represented by this class
            </summary>
            <returns>
            A <see cref="T:System.Boolean"/>
            </returns>
        </member>
        <member name="T:Kavprot.Packets.Tcp.AlternateChecksumData">
            <summary>
            Alternative Checksum Date
             Used as an extension to Alternative Checksum Response when the
              checksum is longer than the standard 16bit TCP Checksum field
            </summary>
            <remarks>
            References:
             http://datatracker.ietf.org/doc/rfc1146/
            </remarks>
        </member>
        <member name="M:Kavprot.Packets.Tcp.AlternateChecksumData.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Creates an Alternate Checksum Data Option
            </summary>
            <param name="bytes">
            A <see cref="!:System.Byte[]"/>
            </param>
            <param name="offset">
            A <see cref="T:System.Int32"/>
            </param>
            <param name="length">
            A <see cref="T:System.Int32"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Tcp.AlternateChecksumData.ToString">
            <summary>
            Returns the Option info as a string
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Tcp.AlternateChecksumData.Data">
            <summary>
            The array of attached Checksum
            </summary>
        </member>
        <member name="T:Kavprot.Packets.TcpFields">
             <summary> IP protocol field encoding information.
            
             </summary>
        </member>
        <member name="F:Kavprot.Packets.TcpFields.PortLength">
            <summary> Length of a TCP port in bytes.</summary>
        </member>
        <member name="F:Kavprot.Packets.TcpFields.SequenceNumberLength">
            <summary> Length of the sequence number in bytes.</summary>
        </member>
        <member name="F:Kavprot.Packets.TcpFields.AckNumberLength">
            <summary> Length of the acknowledgment number in bytes.</summary>
        </member>
        <member name="F:Kavprot.Packets.TcpFields.DataOffsetLength">
            <summary> Length of the data offset and flags field in bytes.</summary>
        </member>
        <member name="F:Kavprot.Packets.TcpFields.FlagsLength">
            <summary> The length of the flags field </summary>
        </member>
        <member name="F:Kavprot.Packets.TcpFields.WindowSizeLength">
            <summary> Length of the window size field in bytes.</summary>
        </member>
        <member name="F:Kavprot.Packets.TcpFields.ChecksumLength">
            <summary> Length of the checksum field in bytes.</summary>
        </member>
        <member name="F:Kavprot.Packets.TcpFields.UrgentPointerLength">
            <summary> Length of the urgent field in bytes.</summary>
        </member>
        <member name="F:Kavprot.Packets.TcpFields.SourcePortPosition">
            <summary> Position of the source port field.</summary>
        </member>
        <member name="F:Kavprot.Packets.TcpFields.DestinationPortPosition">
            <summary> Position of the destination port field.</summary>
        </member>
        <member name="F:Kavprot.Packets.TcpFields.SequenceNumberPosition">
            <summary> Position of the sequence number field.</summary>
        </member>
        <member name="F:Kavprot.Packets.TcpFields.AckNumberPosition">
            <summary> Position of the acknowledgment number field.</summary>
        </member>
        <member name="F:Kavprot.Packets.TcpFields.DataOffsetPosition">
            <summary> Position of the data offset </summary>
        </member>
        <member name="F:Kavprot.Packets.TcpFields.FlagsPosition">
            <summary> Position of the flags field </summary>
        </member>
        <member name="F:Kavprot.Packets.TcpFields.WindowSizePosition">
            <summary> Position of the window size field.</summary>
        </member>
        <member name="F:Kavprot.Packets.TcpFields.ChecksumPosition">
            <summary> Position of the checksum field.</summary>
        </member>
        <member name="F:Kavprot.Packets.TcpFields.UrgentPointerPosition">
            <summary> Position of the urgent pointer field.</summary>
        </member>
        <member name="F:Kavprot.Packets.TcpFields.HeaderLength">
            <summary> Length in bytes of a TCP header.</summary>
        </member>
        <member name="T:MiscUtil.Conversion.EndianBitConverter">
            <summary>
            Equivalent of System.BitConverter, but with either endianness.
            </summary>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.IsLittleEndian">
            <summary>
            Indicates the byte order ("endianess") in which data is converted using this class.
            </summary>
            <remarks>
            Different computer architectures store data using different byte orders. "Big-endian"
            means the most significant byte is on the left end of a word. "Little-endian" means the
            most significant byte is on the right end of a word.
            </remarks>
            <returns>true if this converter is little-endian, false otherwise.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.DoubleToInt64Bits(System.Double)">
            <summary>
            Converts the specified double-precision floating point number to a
            64-bit signed integer. Note: the endianness of this converter does not
            affect the returned value.
            </summary>
            <param name="value">The number to convert. </param>
            <returns>A 64-bit signed integer whose value is equivalent to value.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.Int64BitsToDouble(System.Int64)">
            <summary>
            Converts the specified 64-bit signed integer to a double-precision
            floating point number. Note: the endianness of this converter does not
            affect the returned value.
            </summary>
            <param name="value">The number to convert. </param>
            <returns>A double-precision floating point number whose value is equivalent to value.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.SingleToInt32Bits(System.Single)">
            <summary>
            Converts the specified single-precision floating point number to a
            32-bit signed integer. Note: the endianness of this converter does not
            affect the returned value.
            </summary>
            <param name="value">The number to convert. </param>
            <returns>A 32-bit signed integer whose value is equivalent to value.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.Int32BitsToSingle(System.Int32)">
            <summary>
            Converts the specified 32-bit signed integer to a single-precision floating point
            number. Note: the endianness of this converter does not
            affect the returned value.
            </summary>
            <param name="value">The number to convert. </param>
            <returns>A single-precision floating point number whose value is equivalent to value.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToBoolean(System.Byte[],System.Int32)">
            <summary>
            Returns a Boolean value converted from one byte at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>true if the byte at startIndex in value is nonzero; otherwise, false.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToChar(System.Byte[],System.Int32)">
            <summary>
            Returns a Unicode character converted from two bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A character formed by two bytes beginning at startIndex.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToDouble(System.Byte[],System.Int32)">
            <summary>
            Returns a double-precision floating point number converted from eight bytes
            at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A double precision floating point number formed by eight bytes beginning at startIndex.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToSingle(System.Byte[],System.Int32)">
            <summary>
            Returns a single-precision floating point number converted from four bytes
            at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A single precision floating point number formed by four bytes beginning at startIndex.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToInt16(System.Byte[],System.Int32)">
            <summary>
            Returns a 16-bit signed integer converted from two bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A 16-bit signed integer formed by two bytes beginning at startIndex.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToInt32(System.Byte[],System.Int32)">
            <summary>
            Returns a 32-bit signed integer converted from four bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A 32-bit signed integer formed by four bytes beginning at startIndex.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToInt64(System.Byte[],System.Int32)">
            <summary>
            Returns a 64-bit signed integer converted from eight bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A 64-bit signed integer formed by eight bytes beginning at startIndex.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToUInt16(System.Byte[],System.Int32)">
            <summary>
            Returns a 16-bit unsigned integer converted from two bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A 16-bit unsigned integer formed by two bytes beginning at startIndex.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToUInt32(System.Byte[],System.Int32)">
            <summary>
            Returns a 32-bit unsigned integer converted from four bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A 32-bit unsigned integer formed by four bytes beginning at startIndex.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToUInt64(System.Byte[],System.Int32)">
            <summary>
            Returns a 64-bit unsigned integer converted from eight bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A 64-bit unsigned integer formed by eight bytes beginning at startIndex.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CheckByteArgument(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Checks the given argument for validity.
            </summary>
            <param name="value">The byte array passed in</param>
            <param name="startIndex">The start index passed in</param>
            <param name="bytesRequired">The number of bytes required</param>
            <exception cref="T:System.ArgumentNullException">value is a null reference</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            startIndex is less than zero or greater than the length of value minus bytesRequired.
            </exception>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CheckedFromBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Checks the arguments for validity before calling FromBytes
            (which can therefore assume the arguments are valid).
            </summary>
            <param name="value">The bytes to convert after checking</param>
            <param name="startIndex">The index of the first byte to convert</param>
            <param name="bytesToConvert">The number of bytes to convert</param>
            <returns></returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.FromBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Convert the given number of bytes from the given array, from the given start
            position, into a long, using the bytes as the least significant part of the long.
            By the time this is called, the arguments have been checked for validity.
            </summary>
            <param name="value">The bytes to convert</param>
            <param name="startIndex">The index of the first byte to convert</param>
            <param name="bytesToConvert">The number of bytes to use in the conversion</param>
            <returns>The converted number</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToString(System.Byte[])">
            <summary>
            Returns a String converted from the elements of a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <remarks>All the elements of value are converted.</remarks>
            <returns>
            A String of hexadecimal pairs separated by hyphens, where each pair
            represents the corresponding element in value; for example, "7F-2C-4A".
            </returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToString(System.Byte[],System.Int32)">
            <summary>
            Returns a String converted from the elements of a byte array starting at a specified array position.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <remarks>The elements from array position startIndex to the end of the array are converted.</remarks>
            <returns>
            A String of hexadecimal pairs separated by hyphens, where each pair
            represents the corresponding element in value; for example, "7F-2C-4A".
            </returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToString(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Returns a String converted from a specified number of bytes at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <param name="length">The number of bytes to convert.</param>
            <remarks>The length elements from array position startIndex are converted.</remarks>
            <returns>
            A String of hexadecimal pairs separated by hyphens, where each pair
            represents the corresponding element in value; for example, "7F-2C-4A".
            </returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.ToDecimal(System.Byte[],System.Int32)">
            <summary>
            Returns a decimal value converted from sixteen bytes
            at a specified position in a byte array.
            </summary>
            <param name="value">An array of bytes.</param>
            <param name="startIndex">The starting position within value.</param>
            <returns>A decimal  formed by sixteen bytes beginning at startIndex.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.GetBytes(System.Decimal)">
            <summary>
            Returns the specified decimal value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 16.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytes(System.Decimal,System.Byte[],System.Int32)">
            <summary>
            Copies the specified decimal value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">A character to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.GetBytes(System.Int64,System.Int32)">
            <summary>
            Returns an array with the given number of bytes formed
            from the least significant bytes of the specified value.
            This is used to implement the other GetBytes methods.
            </summary>
            <param name="value">The value to get bytes for</param>
            <param name="bytes">The number of significant bytes to return</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.GetBytes(System.Boolean)">
            <summary>
            Returns the specified Boolean value as an array of bytes.
            </summary>
            <param name="value">A Boolean value.</param>
            <returns>An array of bytes with length 1.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.GetBytes(System.Char)">
            <summary>
            Returns the specified Unicode character value as an array of bytes.
            </summary>
            <param name="value">A character to convert.</param>
            <returns>An array of bytes with length 2.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.GetBytes(System.Double)">
            <summary>
            Returns the specified double-precision floating point value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 8.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.GetBytes(System.Int16)">
            <summary>
            Returns the specified 16-bit signed integer value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 2.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.GetBytes(System.Int32)">
            <summary>
            Returns the specified 32-bit signed integer value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 4.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.GetBytes(System.Int64)">
            <summary>
            Returns the specified 64-bit signed integer value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 8.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.GetBytes(System.Single)">
            <summary>
            Returns the specified single-precision floating point value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 4.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.GetBytes(System.UInt16)">
            <summary>
            Returns the specified 16-bit unsigned integer value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 2.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.GetBytes(System.UInt32)">
            <summary>
            Returns the specified 32-bit unsigned integer value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 4.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.GetBytes(System.UInt64)">
            <summary>
            Returns the specified 64-bit unsigned integer value as an array of bytes.
            </summary>
            <param name="value">The number to convert.</param>
            <returns>An array of bytes with length 8.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytes(System.Int64,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Copies the given number of bytes from the least-specific
            end of the specified value into the specified byte array, beginning
            at the specified index.
            This is used to implement the other CopyBytes methods.
            </summary>
            <param name="value">The value to copy bytes for</param>
            <param name="bytes">The number of significant bytes to copy</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytesImpl(System.Int64,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Copies the given number of bytes from the least-specific
            end of the specified value into the specified byte array, beginning
            at the specified index.
            This must be implemented in concrete derived classes, but the implementation
            may assume that the value will fit into the buffer.
            </summary>
            <param name="value">The value to copy bytes for</param>
            <param name="bytes">The number of significant bytes to copy</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytes(System.Boolean,System.Byte[],System.Int32)">
            <summary>
            Copies the specified Boolean value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">A Boolean value.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytes(System.Char,System.Byte[],System.Int32)">
            <summary>
            Copies the specified Unicode character value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">A character to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytes(System.Double,System.Byte[],System.Int32)">
            <summary>
            Copies the specified double-precision floating point value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytes(System.Int16,System.Byte[],System.Int32)">
            <summary>
            Copies the specified 16-bit signed integer value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytes(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Copies the specified 32-bit signed integer value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytes(System.Int64,System.Byte[],System.Int32)">
            <summary>
            Copies the specified 64-bit signed integer value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytes(System.Single,System.Byte[],System.Int32)">
            <summary>
            Copies the specified single-precision floating point value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytes(System.UInt16,System.Byte[],System.Int32)">
            <summary>
            Copies the specified 16-bit unsigned integer value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytes(System.UInt32,System.Byte[],System.Int32)">
            <summary>
            Copies the specified 32-bit unsigned integer value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.CopyBytes(System.UInt64,System.Byte[],System.Int32)">
            <summary>
            Copies the specified 64-bit unsigned integer value into the specified byte array,
            beginning at the specified index.
            </summary>
            <param name="value">The number to convert.</param>
            <param name="buffer">The byte array to copy the bytes into</param>
            <param name="index">The first index into the array to copy the bytes into</param>
        </member>
        <member name="P:MiscUtil.Conversion.EndianBitConverter.Endianness">
            <summary>
            Indicates the byte order ("endianess") in which data is converted using this class.
            </summary>
        </member>
        <member name="P:MiscUtil.Conversion.EndianBitConverter.Little">
            <summary>
            Returns a little-endian bit converter instance. The same instance is
            always returned.
            </summary>
        </member>
        <member name="P:MiscUtil.Conversion.EndianBitConverter.Big">
            <summary>
            Returns a big-endian bit converter instance. The same instance is
            always returned.
            </summary>
        </member>
        <member name="T:MiscUtil.Conversion.EndianBitConverter.Int32SingleUnion">
            <summary>
            Union used solely for the equivalent of DoubleToInt64Bits and vice versa.
            </summary>
        </member>
        <member name="F:MiscUtil.Conversion.EndianBitConverter.Int32SingleUnion.i">
            <summary>
            Int32 version of the value.
            </summary>
        </member>
        <member name="F:MiscUtil.Conversion.EndianBitConverter.Int32SingleUnion.f">
            <summary>
            Single version of the value.
            </summary>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.Int32SingleUnion.#ctor(System.Int32)">
            <summary>
            Creates an instance representing the given integer.
            </summary>
            <param name="i">The integer value of the new instance.</param>
        </member>
        <member name="M:MiscUtil.Conversion.EndianBitConverter.Int32SingleUnion.#ctor(System.Single)">
            <summary>
            Creates an instance representing the given floating point number.
            </summary>
            <param name="f">The floating point value of the new instance.</param>
        </member>
        <member name="P:MiscUtil.Conversion.EndianBitConverter.Int32SingleUnion.AsInt32">
            <summary>
            Returns the value of the instance as an integer.
            </summary>
        </member>
        <member name="P:MiscUtil.Conversion.EndianBitConverter.Int32SingleUnion.AsSingle">
            <summary>
            Returns the value of the instance as a floating point number.
            </summary>
        </member>
        <member name="T:Kavprot.Packets.IPv4Fields">
            <summary>
            IP protocol field encoding information.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.IPv4Fields.VersionAndHeaderLengthLength">
            <summary> Width of the IP version and header length field in bytes.</summary>
        </member>
        <member name="F:Kavprot.Packets.IPv4Fields.DifferentiatedServicesLength">
            <summary> Width of the Differentiated Services / Type of service field in bytes.</summary>
        </member>
        <member name="F:Kavprot.Packets.IPv4Fields.TotalLengthLength">
            <summary> Width of the total length field in bytes.</summary>
        </member>
        <member name="F:Kavprot.Packets.IPv4Fields.IdLength">
            <summary> Width of the ID field in bytes.</summary>
        </member>
        <member name="F:Kavprot.Packets.IPv4Fields.FragmentOffsetAndFlagsLength">
            <summary> Width of the fragment offset bits and offset field in bytes.</summary>
        </member>
        <member name="F:Kavprot.Packets.IPv4Fields.TtlLength">
            <summary> Width of the TTL field in bytes.</summary>
        </member>
        <member name="F:Kavprot.Packets.IPv4Fields.ProtocolLength">
            <summary> Width of the IP protocol code in bytes.</summary>
        </member>
        <member name="F:Kavprot.Packets.IPv4Fields.ChecksumLength">
            <summary> Width of the IP checksum in bytes.</summary>
        </member>
        <member name="F:Kavprot.Packets.IPv4Fields.VersionAndHeaderLengthPosition">
            <summary> Position of the version code and header length within the IP header.</summary>
        </member>
        <member name="F:Kavprot.Packets.IPv4Fields.DifferentiatedServicesPosition">
            <summary> Position of the differentiated services value within the IP header.</summary>
        </member>
        <member name="F:Kavprot.Packets.IPv4Fields.TotalLengthPosition">
            <summary> Position of the header length within the IP header.</summary>
        </member>
        <member name="F:Kavprot.Packets.IPv4Fields.IdPosition">
            <summary> Position of the packet ID within the IP header.</summary>
        </member>
        <member name="F:Kavprot.Packets.IPv4Fields.FragmentOffsetAndFlagsPosition">
            <summary> Position of the flag bits and fragment offset within the IP header.</summary>
        </member>
        <member name="F:Kavprot.Packets.IPv4Fields.TtlPosition">
            <summary> Position of the ttl within the IP header.</summary>
        </member>
        <member name="F:Kavprot.Packets.IPv4Fields.ProtocolPosition">
            <summary>
            Position of the protocol used within the IP data
            </summary>
        </member>
        <member name="F:Kavprot.Packets.IPv4Fields.ChecksumPosition">
            <summary> Position of the checksum within the IP header.</summary>
        </member>
        <member name="F:Kavprot.Packets.IPv4Fields.SourcePosition">
            <summary> Position of the source IP address within the IP header.</summary>
        </member>
        <member name="F:Kavprot.Packets.IPv4Fields.DestinationPosition">
            <summary> Position of the destination IP address within a packet.</summary>
        </member>
        <member name="F:Kavprot.Packets.IPv4Fields.HeaderLength">
            <summary> Length in bytes of an IP header, excluding options.</summary>
        </member>
        <member name="F:Kavprot.Packets.IPv4Fields.AddressLength">
            <summary>
            Number of bytes in an IPv4 address
            </summary>
        </member>
        <member name="T:Kavprot.Packets.UdpPacket">
            <summary>
            User datagram protocol
            See http://en.wikipedia.org/wiki/Udp
            </summary>
        </member>
        <member name="T:Kavprot.Packets.TransportPacket">
            <summary>
            Transport layer packet
            </summary>
        </member>
        <member name="M:Kavprot.Packets.TransportPacket.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Kavprot.Packets.TransportPacket.CalculateChecksum(Kavprot.Packets.TransportPacket.TransportChecksumOption)">
            <summary>
            Calculates the transport layer checksum, either for the
            tcp or udp packet
            </summary>
            <param name="option"><see cref="T:Kavprot.Packets.TransportPacket.TransportChecksumOption"/></param>
            <returns>
            A <see cref="T:System.Int32"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.TransportPacket.IsValidChecksum(Kavprot.Packets.TransportPacket.TransportChecksumOption)">
            <summary>
            Determine if the transport layer checksum is valid
            </summary>
            <param name="option">
            A <see cref="T:Kavprot.Packets.TransportPacket.TransportChecksumOption"/>
            </param>
            <returns>
            A <see cref="T:System.Boolean"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.TransportPacket.Checksum">
            <value>
            The Checksum version
            </value>
        </member>
        <member name="T:Kavprot.Packets.TransportPacket.TransportChecksumOption">
            <summary>
            Options for use when creating a transport layer checksum
            </summary>
        </member>
        <member name="F:Kavprot.Packets.TransportPacket.TransportChecksumOption.None">
            <summary>
            No extra options
            </summary>
        </member>
        <member name="F:Kavprot.Packets.TransportPacket.TransportChecksumOption.AttachPseudoIPHeader">
            <summary>
            Attach a pseudo IP header to the transport data being checksummed
            </summary>
        </member>
        <member name="M:Kavprot.Packets.UdpPacket.UpdateCalculatedValues">
            <summary>
            Update the Udp length
            </summary>
        </member>
        <member name="M:Kavprot.Packets.UdpPacket.#ctor(System.UInt16,System.UInt16)">
            <summary>
            Create from values
            </summary>
            <param name="SourcePort">
            A <see cref="T:System.UInt16"/>
            </param>
            <param name="DestinationPort">
            A <see cref="T:System.UInt16"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.UdpPacket.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Constructor
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.UdpPacket.#ctor(Kavprot.Packets.Utils.ByteArraySegment,Kavprot.Packets.Packet)">
            <summary>
            Constructor
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
            <param name="ParentPacket">
            A <see cref="T:Kavprot.Packets.Packet"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.UdpPacket.CalculateUDPChecksum">
            <summary>
            Calculates the UDP checksum, optionally updating the UDP checksum header.
            </summary>
            <returns>The calculated UDP checksum.</returns>
        </member>
        <member name="M:Kavprot.Packets.UdpPacket.UpdateUDPChecksum">
            <summary>
            Update the checksum value.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.UdpPacket.ToString(Kavprot.Packets.StringOutputType)">
            <summary cref="M:Kavprot.Packets.Packet.ToString(Kavprot.Packets.StringOutputType)"/>
        </member>
        <member name="M:Kavprot.Packets.UdpPacket.GetEncapsulated(Kavprot.Packets.Packet)">
            <summary>
            Returns the UdpPacket inside of the Packet p or null if
            there is no encapsulated packet
            </summary>
            <param name="p">
            A <see cref="T:Kavprot.Packets.Packet"/>
            </param>
            <returns>
            A <see cref="T:Kavprot.Packets.UdpPacket"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.UdpPacket.RandomPacket">
            <summary>
            Generate a random packet
            </summary>
            <returns>
            A <see cref="T:Kavprot.Packets.UdpPacket"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.UdpPacket.SourcePort">
            <summary> Fetch the port number on the source host.</summary>
        </member>
        <member name="P:Kavprot.Packets.UdpPacket.DestinationPort">
            <summary> Fetch the port number on the target host.</summary>
        </member>
        <member name="P:Kavprot.Packets.UdpPacket.Length">
            <value>
            Length in bytes of the header and payload, minimum size of 8,
            the size of the Udp header
            </value>
        </member>
        <member name="P:Kavprot.Packets.UdpPacket.Checksum">
            <summary> Fetch the header checksum.</summary>
        </member>
        <member name="P:Kavprot.Packets.UdpPacket.ValidChecksum">
            <summary> Check if the UDP packet is valid, checksum-wise.</summary>
        </member>
        <member name="P:Kavprot.Packets.UdpPacket.ValidUDPChecksum">
            <value>
            True if the udp checksum is valid
            </value>
        </member>
        <member name="P:Kavprot.Packets.UdpPacket.Color">
            <summary> Fetch ascii escape sequence of the color associated with this packet type.</summary>
        </member>
        <member name="T:Kavprot.Packets.Tcp.EndOfOptions">
            <summary>
            End-of-Options Option
             Marks the end of the Options list
            </summary>
            <remarks>
            References:
             http://datatracker.ietf.org/doc/rfc793/
            </remarks>
        </member>
        <member name="F:Kavprot.Packets.Tcp.EndOfOptions.OptionLength">
            <summary>
            The length (in bytes) of the EndOfOptions option
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Tcp.EndOfOptions.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Creates an End Of Options Option
            </summary>
            <param name="bytes">
            A <see cref="!:System.Byte[]"/>
            </param>
            <param name="offset">
            A <see cref="T:System.Int32"/>
            </param>
            <param name="length">
            A <see cref="T:System.Int32"/>
            </param>
        </member>
        <member name="P:Kavprot.Packets.Tcp.EndOfOptions.Length">
            <summary>
            The length of the EndOfOptions field
             Returns 1 as opposed to returning the length field because
             the EndOfOptions option is only 1 byte long and doesn't
             contain a length field
            </summary>
        </member>
        <member name="T:Kavprot.Packets.TcpPacket">
            <summary>
            TcpPacket
            See: http://en.wikipedia.org/wiki/Transmission_Control_Protocol
            </summary>
        </member>
        <member name="F:Kavprot.Packets.TcpPacket.HeaderMinimumLength">
            <value>
            20 bytes is the smallest tcp header
            </value>
        </member>
        <member name="M:Kavprot.Packets.TcpPacket.#ctor(System.UInt16,System.UInt16)">
            <summary>
            Create a new TCP packet from values
            </summary>
        </member>
        <member name="M:Kavprot.Packets.TcpPacket.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Constructor
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.TcpPacket.#ctor(Kavprot.Packets.Utils.ByteArraySegment,Kavprot.Packets.Packet)">
            <summary>
            Constructor
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
            <param name="ParentPacket">
            A <see cref="T:Kavprot.Packets.Packet"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.TcpPacket.CalculateTCPChecksum">
            <summary>
            Computes the TCP checksum. Does not update the current checksum value
            </summary>
            <returns> The calculated TCP checksum.</returns>
        </member>
        <member name="M:Kavprot.Packets.TcpPacket.UpdateTCPChecksum">
            <summary>
            Update the checksum value.
            </summary>
        </member>
        <!-- Commentaire XML incorrect ignoré pour le membre "M:Kavprot.Packets.TcpPacket.ParseOptions(System.Byte[])" -->
        <member name="M:Kavprot.Packets.TcpPacket.ToString(Kavprot.Packets.StringOutputType)">
            <summary cref="M:Kavprot.Packets.Packet.ToString(Kavprot.Packets.StringOutputType)"/>
        </member>
        <member name="M:Kavprot.Packets.TcpPacket.GetEncapsulated(Kavprot.Packets.Packet)">
            <summary>
            Returns the TcpPacket embedded in Packet p or null if
            there is no embedded TcpPacket
            </summary>
        </member>
        <member name="M:Kavprot.Packets.TcpPacket.RandomPacket">
            <summary>
            Create a randomized tcp packet with the given ip version
            </summary>
            <returns>
            A <see cref="T:Kavprot.Packets.Packet"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.TcpPacket.SourcePort">
            <summary> Fetch the port number on the source host.</summary>
        </member>
        <member name="P:Kavprot.Packets.TcpPacket.DestinationPort">
            <summary> Fetches the port number on the destination host.</summary>
        </member>
        <member name="P:Kavprot.Packets.TcpPacket.SequenceNumber">
            <summary> Fetch the packet sequence number.</summary>
        </member>
        <member name="P:Kavprot.Packets.TcpPacket.AcknowledgmentNumber">
            <summary> Fetch the packet acknowledgment number.</summary>
        </member>
        <member name="P:Kavprot.Packets.TcpPacket.DataOffset">
            <summary> The size of the tcp header in 32bit words </summary>
        </member>
        <member name="P:Kavprot.Packets.TcpPacket.WindowSize">
            <summary>
            The size of the receive window, which specifies the number of
            bytes (beyond the sequence number in the acknowledgment field) that
            the receiver is currently willing to receive.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.TcpPacket.Checksum">
            <value>
            Tcp checksum field value of type UInt16
            </value>
        </member>
        <member name="P:Kavprot.Packets.TcpPacket.ValidChecksum">
            <summary> Check if the TCP packet is valid, checksum-wise.</summary>
        </member>
        <member name="P:Kavprot.Packets.TcpPacket.ValidTCPChecksum">
            <value>
            True if the tcp checksum is valid
            </value>
        </member>
        <member name="P:Kavprot.Packets.TcpPacket.AllFlags">
            <summary>
            Flags, 9 bits
            TODO: Handle the NS bit
            </summary>
        </member>
        <member name="P:Kavprot.Packets.TcpPacket.Urg">
            <summary> Check the URG flag, flag indicates if the urgent pointer is valid.</summary>
        </member>
        <member name="P:Kavprot.Packets.TcpPacket.Ack">
            <summary> Check the ACK flag, flag indicates if the ack number is valid.</summary>
        </member>
        <member name="P:Kavprot.Packets.TcpPacket.Psh">
            <summary> Check the PSH flag, flag indicates the receiver should pass the
            data to the application as soon as possible.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.TcpPacket.Rst">
            <summary> Check the RST flag, flag indicates the session should be reset between
            the sender and the receiver.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.TcpPacket.Syn">
            <summary> Check the SYN flag, flag indicates the sequence numbers should
            be synchronized between the sender and receiver to initiate
            a connection.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.TcpPacket.Fin">
            <summary> Check the FIN flag, flag indicates the sender is finished sending.</summary>
        </member>
        <member name="P:Kavprot.Packets.TcpPacket.ECN">
            <value>
            ECN flag
            </value>
        </member>
        <member name="P:Kavprot.Packets.TcpPacket.CWR">
            <value>
            CWR flag
            </value>
        </member>
        <member name="P:Kavprot.Packets.TcpPacket.Color">
            <summary> Fetch ascii escape sequence of the color associated with this packet type.</summary>
        </member>
        <member name="P:Kavprot.Packets.TcpPacket.UrgentPointer">
            <summary> Fetch the urgent pointer.</summary>
        </member>
        <member name="P:Kavprot.Packets.TcpPacket.Options">
            <summary>
            Bytes that represent the tcp options
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.TcpPacket.OptionsCollection">
            <summary>
            Contains the Options list attached to the TCP header
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Tcp.UserTimeout">
            <summary>
            User Timeout Option
            The TCP user timeout controls how long transmitted data may remain
             unacknowledged before a connection is forcefully closed
            </summary>
            <remarks>
            References:
             http://datatracker.ietf.org/doc/rfc5482/
            </remarks>
        </member>
        <member name="M:Kavprot.Packets.Tcp.UserTimeout.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Creates a User Timeout Option
            </summary>
            <param name="bytes">
            A <see cref="!:System.Byte[]"/>
            </param>
            <param name="offset">
            A <see cref="T:System.Int32"/>
            </param>
            <param name="length">
            A <see cref="T:System.Int32"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Tcp.UserTimeout.ToString">
            <summary>
            Returns the Option info as a string
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Tcp.UserTimeout.Granularity">
            <summary>
            The Granularity
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Tcp.UserTimeout.Timeout">
            <summary>
            The User Timeout
            </summary>
        </member>
        <member name="T:Kavprot.Packets.SessionPacket">
            <summary>
            Session layer packet
            </summary>
        </member>
        <member name="M:Kavprot.Packets.SessionPacket.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="T:Kavprot.Packets.PPPoEFields">
            <summary>
            Point to Point Protocol
            See http://tools.ietf.org/html/rfc2516
            </summary>
        </member>
        <member name="F:Kavprot.Packets.PPPoEFields.VersionTypeLength">
            <summary> Size in bytes of the version/type field </summary>
        </member>
        <member name="F:Kavprot.Packets.PPPoEFields.CodeLength">
            <summary> Size in bytes of the code field </summary>
        </member>
        <member name="F:Kavprot.Packets.PPPoEFields.SessionIdLength">
            <summary> Size in bytes of the SessionId field </summary>
        </member>
        <member name="F:Kavprot.Packets.PPPoEFields.LengthLength">
            <summary> Size in bytes of the Length field </summary>
        </member>
        <member name="F:Kavprot.Packets.PPPoEFields.VersionTypePosition">
            <summary> Offset from the start of the header to the version/type field </summary>
        </member>
        <member name="F:Kavprot.Packets.PPPoEFields.CodePosition">
            <summary> Offset from the start of the header to the Code field </summary>
        </member>
        <member name="F:Kavprot.Packets.PPPoEFields.SessionIdPosition">
            <summary> Offset from the start of the header to the SessionId field </summary>
        </member>
        <member name="F:Kavprot.Packets.PPPoEFields.LengthPosition">
            <summary> Offset from the start of the header to the Length field </summary>
        </member>
        <member name="F:Kavprot.Packets.PPPoEFields.HeaderLength">
            <summary>
            Length of the overall PPPoe header
            </summary>
        </member>
        <member name="T:MiscUtil.IO.EndianBinaryWriter">
            <summary>
            Equivalent of System.IO.BinaryWriter, but with either endianness, depending on
            the EndianBitConverter it is constructed with.
            </summary>
        </member>
        <member name="F:MiscUtil.IO.EndianBinaryWriter.disposed">
            <summary>
            Whether or not this writer has been disposed yet.
            </summary>
        </member>
        <member name="F:MiscUtil.IO.EndianBinaryWriter.buffer">
            <summary>
            Buffer used for temporary storage during conversion from primitives
            </summary>
        </member>
        <member name="F:MiscUtil.IO.EndianBinaryWriter.charBuffer">
            <summary>
            Buffer used for Write(char)
            </summary>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.#ctor(MiscUtil.Conversion.EndianBitConverter,System.IO.Stream)">
            <summary>
            Constructs a new binary writer with the given bit converter, writing
            to the given stream, using UTF-8 encoding.
            </summary>
            <param name="bitConverter">Converter to use when writing data</param>
            <param name="stream">Stream to write data to</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.#ctor(MiscUtil.Conversion.EndianBitConverter,System.IO.Stream,System.Text.Encoding)">
            <summary>
            Constructs a new binary writer with the given bit converter, writing
            to the given stream, using the given encoding.
            </summary>
            <param name="bitConverter">Converter to use when writing data</param>
            <param name="stream">Stream to write data to</param>
            <param name="encoding">Encoding to use when writing character data</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Close">
            <summary>
            Closes the writer, including the underlying stream.
            </summary>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Flush">
            <summary>
            Flushes the underlying stream.
            </summary>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Seek(System.Int32,System.IO.SeekOrigin)">
            <summary>
            Seeks within the stream.
            </summary>
            <param name="offset">Offset to seek to.</param>
            <param name="origin">Origin of seek operation.</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.Boolean)">
            <summary>
            Writes a boolean value to the stream. 1 byte is written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.Int16)">
            <summary>
            Writes a 16-bit signed integer to the stream, using the bit converter
            for this writer. 2 bytes are written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.Int32)">
            <summary>
            Writes a 32-bit signed integer to the stream, using the bit converter
            for this writer. 4 bytes are written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.Int64)">
            <summary>
            Writes a 64-bit signed integer to the stream, using the bit converter
            for this writer. 8 bytes are written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.UInt16)">
            <summary>
            Writes a 16-bit unsigned integer to the stream, using the bit converter
            for this writer. 2 bytes are written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.UInt32)">
            <summary>
            Writes a 32-bit unsigned integer to the stream, using the bit converter
            for this writer. 4 bytes are written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.UInt64)">
            <summary>
            Writes a 64-bit unsigned integer to the stream, using the bit converter
            for this writer. 8 bytes are written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.Single)">
            <summary>
            Writes a single-precision floating-point value to the stream, using the bit converter
            for this writer. 4 bytes are written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.Double)">
            <summary>
            Writes a double-precision floating-point value to the stream, using the bit converter
            for this writer. 8 bytes are written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.Decimal)">
            <summary>
            Writes a decimal value to the stream, using the bit converter for this writer.
            16 bytes are written.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.Byte)">
            <summary>
            Writes a signed byte to the stream.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.SByte)">
            <summary>
            Writes an unsigned byte to the stream.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.Byte[])">
            <summary>
            Writes an array of bytes to the stream.
            </summary>
            <param name="value">The values to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes a portion of an array of bytes to the stream.
            </summary>
            <param name="value">An array containing the bytes to write</param>
            <param name="offset">The index of the first byte to write within the array</param>
            <param name="count">The number of bytes to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.Char)">
            <summary>
            Writes a single character to the stream, using the encoding for this writer.
            </summary>
            <param name="value">The value to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.Char[])">
            <summary>
            Writes an array of characters to the stream, using the encoding for this writer.
            </summary>
            <param name="value">An array containing the characters to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write(System.String)">
            <summary>
            Writes a string to the stream, using the encoding for this writer.
            </summary>
            <param name="value">The value to write. Must not be null.</param>
            <exception cref="T:System.ArgumentNullException">value is null</exception>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Write7BitEncodedInt(System.Int32)">
            <summary>
            Writes a 7-bit encoded integer from the stream. This is stored with the least significant
            information first, with 7 bits of information per byte of value, and the top
            bit as a continuation flag.
            </summary>
            <param name="value">The 7-bit encoded integer to write to the stream</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.CheckDisposed">
            <summary>
            Checks whether or not the writer has been disposed, throwing an exception if so.
            </summary>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.WriteInternal(System.Byte[],System.Int32)">
            <summary>
            Writes the specified number of bytes from the start of the given byte array,
            after checking whether or not the writer has been disposed.
            </summary>
            <param name="bytes">The array of bytes to write from</param>
            <param name="length">The number of bytes to write</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryWriter.Dispose">
            <summary>
            Disposes of the underlying stream.
            </summary>
        </member>
        <member name="P:MiscUtil.IO.EndianBinaryWriter.BitConverter">
            <summary>
            The bit converter used to write values to the stream
            </summary>
        </member>
        <member name="P:MiscUtil.IO.EndianBinaryWriter.Encoding">
            <summary>
            The encoding used to write strings
            </summary>
        </member>
        <member name="P:MiscUtil.IO.EndianBinaryWriter.BaseStream">
            <summary>
            Gets the underlying stream of the EndianBinaryWriter.
            </summary>
        </member>
        <member name="T:MiscUtil.IO.EndianBinaryReader">
            <summary>
            Equivalent of System.IO.BinaryReader, but with either endianness, depending on
            the EndianBitConverter it is constructed with. No data is buffered in the
            reader; the client may seek within the stream at will.
            </summary>
        </member>
        <member name="F:MiscUtil.IO.EndianBinaryReader.disposed">
            <summary>
            Whether or not this reader has been disposed yet.
            </summary>
        </member>
        <member name="F:MiscUtil.IO.EndianBinaryReader.decoder">
            <summary>
            Decoder to use for string conversions.
            </summary>
        </member>
        <member name="F:MiscUtil.IO.EndianBinaryReader.buffer">
            <summary>
            Buffer used for temporary storage before conversion into primitives
            </summary>
        </member>
        <member name="F:MiscUtil.IO.EndianBinaryReader.charBuffer">
            <summary>
            Buffer used for temporary storage when reading a single character
            </summary>
        </member>
        <member name="F:MiscUtil.IO.EndianBinaryReader.minBytesPerChar">
            <summary>
            Minimum number of bytes used to encode a character
            </summary>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.#ctor(MiscUtil.Conversion.EndianBitConverter,System.IO.Stream)">
            <summary>
            Equivalent of System.IO.BinaryWriter, but with either endianness, depending on
            the EndianBitConverter it is constructed with.
            </summary>
            <param name="bitConverter">Converter to use when reading data</param>
            <param name="stream">Stream to read data from</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.#ctor(MiscUtil.Conversion.EndianBitConverter,System.IO.Stream,System.Text.Encoding)">
            <summary>
            Constructs a new binary reader with the given bit converter, reading
            to the given stream, using the given encoding.
            </summary>
            <param name="bitConverter">Converter to use when reading data</param>
            <param name="stream">Stream to read data from</param>
            <param name="encoding">Encoding to use when reading character data</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.Close">
            <summary>
            Closes the reader, including the underlying stream..
            </summary>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.Seek(System.Int32,System.IO.SeekOrigin)">
            <summary>
            Seeks within the stream.
            </summary>
            <param name="offset">Offset to seek to.</param>
            <param name="origin">Origin of seek operation.</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadByte">
            <summary>
            Reads a single byte from the stream.
            </summary>
            <returns>The byte read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadSByte">
            <summary>
            Reads a single signed byte from the stream.
            </summary>
            <returns>The byte read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadBoolean">
            <summary>
            Reads a boolean from the stream. 1 byte is read.
            </summary>
            <returns>The boolean read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadInt16">
            <summary>
            Reads a 16-bit signed integer from the stream, using the bit converter
            for this reader. 2 bytes are read.
            </summary>
            <returns>The 16-bit integer read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadInt32">
            <summary>
            Reads a 32-bit signed integer from the stream, using the bit converter
            for this reader. 4 bytes are read.
            </summary>
            <returns>The 32-bit integer read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadInt64">
            <summary>
            Reads a 64-bit signed integer from the stream, using the bit converter
            for this reader. 8 bytes are read.
            </summary>
            <returns>The 64-bit integer read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadUInt16">
            <summary>
            Reads a 16-bit unsigned integer from the stream, using the bit converter
            for this reader. 2 bytes are read.
            </summary>
            <returns>The 16-bit unsigned integer read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadUInt32">
            <summary>
            Reads a 32-bit unsigned integer from the stream, using the bit converter
            for this reader. 4 bytes are read.
            </summary>
            <returns>The 32-bit unsigned integer read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadUInt64">
            <summary>
            Reads a 64-bit unsigned integer from the stream, using the bit converter
            for this reader. 8 bytes are read.
            </summary>
            <returns>The 64-bit unsigned integer read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadSingle">
            <summary>
            Reads a single-precision floating-point value from the stream, using the bit converter
            for this reader. 4 bytes are read.
            </summary>
            <returns>The floating point value read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadDouble">
            <summary>
            Reads a double-precision floating-point value from the stream, using the bit converter
            for this reader. 8 bytes are read.
            </summary>
            <returns>The floating point value read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadDecimal">
            <summary>
            Reads a decimal value from the stream, using the bit converter
            for this reader. 16 bytes are read.
            </summary>
            <returns>The decimal value read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.Read">
            <summary>
            Reads a single character from the stream, using the character encoding for
            this reader. If no characters have been fully read by the time the stream ends,
            -1 is returned.
            </summary>
            <returns>The character read, or -1 for end of stream.</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.Read(System.Char[],System.Int32,System.Int32)">
            <summary>
            Reads the specified number of characters into the given buffer, starting at
            the given index.
            </summary>
            <param name="data">The buffer to copy data into</param>
            <param name="index">The first index to copy data into</param>
            <param name="count">The number of characters to read</param>
            <returns>The number of characters actually read. This will only be less than
            the requested number of characters if the end of the stream is reached.
            </returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads the specified number of bytes into the given buffer, starting at
            the given index.
            </summary>
            <param name="buffer">The buffer to copy data into</param>
            <param name="index">The first index to copy data into</param>
            <param name="count">The number of bytes to read</param>
            <returns>The number of bytes actually read. This will only be less than
            the requested number of bytes if the end of the stream is reached.
            </returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadBytes(System.Int32)">
            <summary>
            Reads the specified number of bytes, returning them in a new byte array.
            If not enough bytes are available before the end of the stream, this
            method will return what is available.
            </summary>
            <param name="count">The number of bytes to read</param>
            <returns>The bytes read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadBytesOrThrow(System.Int32)">
            <summary>
            Reads the specified number of bytes, returning them in a new byte array.
            If not enough bytes are available before the end of the stream, this
            method will throw an IOException.
            </summary>
            <param name="count">The number of bytes to read</param>
            <returns>The bytes read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.Read7BitEncodedInt">
            <summary>
            Reads a 7-bit encoded integer from the stream. This is stored with the least significant
            information first, with 7 bits of information per byte of value, and the top
            bit as a continuation flag. This method is not affected by the endianness
            of the bit converter.
            </summary>
            <returns>The 7-bit encoded integer read from the stream.</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadBigEndian7BitEncodedInt">
            <summary>
            Reads a 7-bit encoded integer from the stream. This is stored with the most significant
            information first, with 7 bits of information per byte of value, and the top
            bit as a continuation flag. This method is not affected by the endianness
            of the bit converter.
            </summary>
            <returns>The 7-bit encoded integer read from the stream.</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadString">
            <summary>
            Reads a length-prefixed string from the stream, using the encoding for this reader.
            A 7-bit encoded integer is first read, which specifies the number of bytes
            to read from the stream. These bytes are then converted into a string with
            the encoding for this reader.
            </summary>
            <returns>The string read from the stream.</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.CheckDisposed">
            <summary>
            Checks whether or not the reader has been disposed, throwing an exception if so.
            </summary>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.ReadInternal(System.Byte[],System.Int32)">
            <summary>
            Reads the given number of bytes from the stream, throwing an exception
            if they can't all be read.
            </summary>
            <param name="data">Buffer to read into</param>
            <param name="size">Number of bytes to read</param>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.TryReadInternal(System.Byte[],System.Int32)">
            <summary>
            Reads the given number of bytes from the stream if possible, returning
            the number of bytes actually read, which may be less than requested if
            (and only if) the end of the stream is reached.
            </summary>
            <param name="data">Buffer to read into</param>
            <param name="size">Number of bytes to read</param>
            <returns>Number of bytes actually read</returns>
        </member>
        <member name="M:MiscUtil.IO.EndianBinaryReader.Dispose">
            <summary>
            Disposes of the underlying stream.
            </summary>
        </member>
        <member name="P:MiscUtil.IO.EndianBinaryReader.BitConverter">
            <summary>
            The bit converter used to read values from the stream
            </summary>
        </member>
        <member name="P:MiscUtil.IO.EndianBinaryReader.Encoding">
            <summary>
            The encoding used to read strings
            </summary>
        </member>
        <member name="P:MiscUtil.IO.EndianBinaryReader.BaseStream">
            <summary>
            Gets the underlying stream of the EndianBinaryReader.
            </summary>
        </member>
        <member name="T:Kavprot.Packets.LLDP.TLV">
            <summary>
            A Type-Length-Value object
            </summary>
        </member>
        <member name="M:Kavprot.Packets.LLDP.TLV.#ctor">
            <summary>
            Create a tlv
            </summary>
        </member>
        <member name="M:Kavprot.Packets.LLDP.TLV.#ctor(System.Byte[],System.Int32)">
            <summary>
            Creates a TLV
            </summary>
            <param name="bytes">
            Bytes that comprise the TLV
            </param>
            <param name="offset">
            The TLVs offset from the start of byte[] bytes
            </param>
        </member>
        <member name="F:Kavprot.Packets.LLDP.TLV._tlvData">
            <summary>
            Points to the TLV data
            </summary>
        </member>
        <member name="F:Kavprot.Packets.LLDP.TLV.TypeLength">
            <summary>
            Interface to this TLVs type and length
            </summary>
        </member>
        <member name="P:Kavprot.Packets.LLDP.TLV.Length">
            <summary>
            Length of value portion of the TLV
            NOTE: Does not include the length of the Type and Length fields
            </summary>
        </member>
        <member name="P:Kavprot.Packets.LLDP.TLV.TotalLength">
            <summary>
            Total length of the TLV, including the length of the Type and Length fields
            </summary>
        </member>
        <member name="P:Kavprot.Packets.LLDP.TLV.Type">
            <summary>
            Tlv type
            </summary>
        </member>
        <member name="P:Kavprot.Packets.LLDP.TLV.ValueOffset">
            <summary>
            Offset to the value bytes of the TLV
            </summary>
        </member>
        <member name="P:Kavprot.Packets.LLDP.TLV.Bytes">
            <summary>
            Return a byte[] that contains the tlv
            </summary>
        </member>
        <member name="P:Kavprot.Packets.LLDP.TLV.tlvData">
            <summary>
            Points to the TLV data
            </summary>
        </member>
        <member name="T:Kavprot.Packets.LLDP.NetworkAddress">
            <summary>
            A Network Address
            </summary>
        </member>
        <member name="F:Kavprot.Packets.LLDP.NetworkAddress.AddressFamilyLength">
            <summary>
            Length of AddressFamily field in bytes
            </summary>
        </member>
        <member name="M:Kavprot.Packets.LLDP.NetworkAddress.#ctor(System.Net.IPAddress)">
            <summary>
            Creates a Network Address entity
            </summary>
            <param name="address">
            The Network Address
            </param>
        </member>
        <member name="M:Kavprot.Packets.LLDP.NetworkAddress.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Create a network address from byte data
            </summary>
            <param name="bytes">
            A <see cref="!:System.Byte[]"/>
            </param>
            <param name="offset">
            A <see cref="T:System.Int32"/>
            </param>
            <param name="length">
            A <see cref="T:System.Int32"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.LLDP.NetworkAddress.Equals(System.Object)">
            <summary>
            Equals override
            </summary>
            <param name="obj">
            A <see cref="T:System.Object"/>
            </param>
            <returns>
            A <see cref="T:System.Boolean"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.LLDP.NetworkAddress.GetHashCode">
            <summary>
            GetHashCode() override
            </summary>
            <returns>
            A <see cref="T:System.Int32"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.LLDP.NetworkAddress.ToString">
            <summary>
            ToString() override
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.LLDP.NetworkAddress.Length">
            <summary>
            Number of bytes in the NetworkAddress
            </summary>
        </member>
        <member name="P:Kavprot.Packets.LLDP.NetworkAddress.AddressFamily">
            <summary>The format of the Network Address</summary>
        </member>
        <member name="P:Kavprot.Packets.LLDP.NetworkAddress.Address">
            <summary>The Network Address</summary>
        </member>
        <member name="T:Kavprot.Packets.IPv4Packet">
            <summary>
            IPv4 packet
            See http://en.wikipedia.org/wiki/IPv4 for into
            </summary>
        </member>
        <member name="F:Kavprot.Packets.IPv4Packet.HeaderMinimumLength">
            <value>
            Number of bytes in the smallest valid ipv4 packet
            </value>
        </member>
        <member name="F:Kavprot.Packets.IPv4Packet.ipVersion">
            <value>
            Version number of the IP protocol being used
            </value>
        </member>
        <member name="M:Kavprot.Packets.IPv4Packet.CalculateIPChecksum">
            <summary>
            Calculates the IP checksum, optionally updating the IP checksum header.
            </summary>
            <returns> The calculated IP checksum.
            </returns>
        </member>
        <member name="M:Kavprot.Packets.IPv4Packet.UpdateIPChecksum">
            <summary>
            Update the checksum value
            </summary>
        </member>
        <member name="M:Kavprot.Packets.IPv4Packet.AttachPseudoIPHeader(System.Byte[])">
             <summary>
             Prepend to the given byte[] origHeader the portion of the IPv6 header used for
             generating an tcp checksum
            
             http://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_checksum_using_IPv4
             http://tools.ietf.org/html/rfc793
             </summary>
             <param name="origHeader">
             A <see cref="T:System.Byte"/>
             </param>
             <returns>
             A <see cref="T:System.Byte"/>
             </returns>
        </member>
        <member name="M:Kavprot.Packets.IPv4Packet.#ctor(System.Net.IPAddress,System.Net.IPAddress)">
            <summary>
            Construct an instance by values
            </summary>
        </member>
        <member name="M:Kavprot.Packets.IPv4Packet.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Constructor
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.IPv4Packet.ToString(Kavprot.Packets.StringOutputType)">
            <summary cref="M:Kavprot.Packets.Packet.ToString(Kavprot.Packets.StringOutputType)"/>
        </member>
        <member name="M:Kavprot.Packets.IPv4Packet.RandomPacket">
            <summary>
            Generate a random packet
            </summary>
            <returns>
            A <see cref="T:Kavprot.Packets.Packet"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.IPv4Packet.UpdateCalculatedValues">
            <summary>
            Update the length fields
            </summary>
        </member>
        <member name="P:Kavprot.Packets.IPv4Packet.Version">
            <summary> Get the IP version code.</summary>
        </member>
        <member name="P:Kavprot.Packets.IPv4Packet.PayloadLength">
            <value>
            Forwards compatibility IPv6.PayloadLength property
            </value>
        </member>
        <member name="P:Kavprot.Packets.IPv4Packet.HeaderLength">
            <summary>
            The IP header length field.  At most, this can be a
            four-bit value.  The high order bits beyond the fourth bit
            will be ignored.
            </summary>
            <param name="length">The length of the IP header in 32-bit words.
            </param>
        </member>
        <member name="P:Kavprot.Packets.IPv4Packet.Id">
            <summary>
            The unique ID of this IP datagram. The ID normally
            increments by one each time a datagram is sent by a host.
            A 16-bit unsigned integer.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.IPv4Packet.FragmentOffset">
            <summary>
            Fragmentation offset
            The offset specifies a number of octets (i.e., bytes).
            A 13-bit unsigned integer.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.IPv4Packet.SourceAddress">
            <summary> Fetch the IP address of the host where the packet originated from.</summary>
        </member>
        <member name="P:Kavprot.Packets.IPv4Packet.DestinationAddress">
            <summary> Fetch the IP address of the host where the packet is destined.</summary>
        </member>
        <member name="P:Kavprot.Packets.IPv4Packet.Checksum">
            <summary> Fetch the header checksum.</summary>
        </member>
        <member name="P:Kavprot.Packets.IPv4Packet.ValidChecksum">
            <summary> Check if the IP packet is valid, checksum-wise.</summary>
        </member>
        <member name="P:Kavprot.Packets.IPv4Packet.ValidIPChecksum">
            <summary>
            Check if the IP packet header is valid, checksum-wise.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.IPv4Packet.Color">
            <summary> Fetch ascii escape sequence of the color associated with this packet type.</summary>
        </member>
        <member name="P:Kavprot.Packets.IPv4Packet.DifferentiatedServices">
            <summary> Fetch the type of service. </summary>
        </member>
        <member name="P:Kavprot.Packets.IPv4Packet.TypeOfService">
            <value>
            Renamed to DifferentiatedServices in IPv6 but present here
            for backwards compatibility
            </value>
        </member>
        <member name="P:Kavprot.Packets.IPv4Packet.TotalLength">
            <value>
            The entire datagram size including header and data
            </value>
        </member>
        <member name="P:Kavprot.Packets.IPv4Packet.FragmentFlags">
            <summary> Fetch fragment flags.</summary>
            <param name="flags">A 3-bit unsigned integer.</param>
        </member>
        <member name="P:Kavprot.Packets.IPv4Packet.TimeToLive">
             <summary> Fetch the time to live. TTL sets the upper limit on the number of
             routers through which this IP datagram is allowed to pass.
             Originally intended to be the number of seconds the packet lives it is now decremented
             by one each time a router passes the packet on
            
             8-bit value
             </summary>
        </member>
        <member name="P:Kavprot.Packets.IPv4Packet.Protocol">
            <summary> Fetch the code indicating the type of protocol embedded in the IP</summary>
            <seealso cref="T:Kavprot.Packets.IPProtocolType">
            </seealso>
        </member>
        <member name="T:Kavprot.Packets.IPv4Packet.TypesOfService_Fields">
            <summary> Type of service code constants for IP. Type of service describes
            how a packet should be handled.
            <p>
            TOS is an 8-bit record in an IP header which contains a 3-bit
            precendence field, 4 TOS bit fields and a 0 bit.
            </p>
            <p>
            The following constants are bit masks which can be logically and'ed
            with the 8-bit IP TOS field to determine what type of service is set.
            </p>
            <p>
            Taken from TCP/IP Illustrated V1 by Richard Stevens, p34.
            </p>
            </summary>
        </member>
        <member name="T:Kavprot.Packets.IpPort">
            <summary> Code constants for ip ports. </summary>
        </member>
        <member name="F:Kavprot.Packets.IpPort.Ssh">
            <summary>
            Secure shell
            </summary>
        </member>
        <member name="F:Kavprot.Packets.IpPort.Telnet">
            <summary>
            Terminal protocol
            </summary>
        </member>
        <member name="F:Kavprot.Packets.IpPort.Smtp">
            <summary>
            Simple mail transport protocol
            </summary>
        </member>
        <member name="F:Kavprot.Packets.IpPort.Http">
            <summary>
            Hyper text transfer protocol
            </summary>
        </member>
        <member name="F:Kavprot.Packets.IpPort.Www">
            <summary>
            Same as Http
            </summary>
        </member>
        <member name="F:Kavprot.Packets.IpPort.Sftp">
            <summary>
            Secure ftp
            </summary>
        </member>
        <member name="F:Kavprot.Packets.IpPort.Ntp">
            <summary>
            Network time protocol
            </summary>
        </member>
        <member name="F:Kavprot.Packets.IpPort.Snmp">
            <summary>
            Simple network management protocol
            </summary>
        </member>
        <member name="T:Kavprot.Packets.IGMPMessageType">
             <summary> Code constants for IGMP message types.
            
             From RFC #2236.
            
             </summary>
        </member>
        <member name="T:Kavprot.Packets.PayloadType">
            <summary>
            Differentiates between a packet class payload, a byte[] payload
            or no payload
            </summary>
        </member>
        <member name="T:Kavprot.Packets.LinuxSLLType">
            <summary>
            The types of cooked packets
            See http://github.com/mcr/libpcap/blob/master/pcap/sll.h
            </summary>
        </member>
        <member name="F:Kavprot.Packets.LinuxSLLType.PacketSentToUs">
            <summary>
            Packet was sent to us by somebody else
            </summary>
        </member>
        <member name="F:Kavprot.Packets.LinuxSLLType.PacketBroadCast">
            <summary>
            Packet was broadcast by somebody else
            </summary>
        </member>
        <member name="F:Kavprot.Packets.LinuxSLLType.PacketMulticast">
            <summary>
            Packet was multicast, but not broadcast
            </summary>
        </member>
        <member name="F:Kavprot.Packets.LinuxSLLType.PacketSentToSomeoneElse">
            <summary>
            Packet was sent by somebody else to somebody else
            </summary>
        </member>
        <member name="F:Kavprot.Packets.LinuxSLLType.PacketSentByUs">
            <summary>
            Packet was sent by us
            </summary>
        </member>
        <member name="T:Kavprot.Packets.EthernetFields">
            <summary>
            Ethernet protocol field encoding information.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetFields.TypeLength">
            <summary> Width of the ethernet type code in bytes.</summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetFields.DestinationMacPosition">
            <summary> Position of the destination MAC address within the ethernet header.</summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetFields.SourceMacPosition">
            <summary> Position of the source MAC address within the ethernet header.</summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetFields.TypePosition">
            <summary> Position of the ethernet type field within the ethernet header.</summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetFields.HeaderLength">
            <summary> Total length of an ethernet header in bytes.</summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetFields.MacAddressLength">
            <summary>
            size of an ethernet mac address in bytes
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Utils.HexPrinter">
            <summary>
            Helper class that prints out an array of hex values
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Utils.HexPrinter.GetString(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Create a string that contains the hex values of byte[] Byte in
            text form
            </summary>
            <param name="Byte">
            A <see cref="T:System.Byte"/>
            </param>
            <param name="Offset">
            A <see cref="T:System.Int32"/>
            </param>
            <param name="Length">
            A <see cref="T:System.Int32"/>
            </param>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.Utils.HexPrinter.PrintMACAddress(System.Net.NetworkInformation.PhysicalAddress)">
            <summary>
            Creates a string from a Physical address in the format "xx:xx:xx:xx:xx:xx"
            </summary>
            <param name="address">
            A <see cref="T:System.Net.NetworkInformation.PhysicalAddress"/>
            </param>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="T:Kavprot.Packets.Utils.AnsiEscapeSequences">
            <summary> String constants for color console output.
            <p>
            This file contains control sequences to print color text on a text
            console capable of interpreting and displaying control sequences.
            </p>
            <p>
            A capable console would be
            unix bash, os/2 shell, or command.com w/ ansi.sys loaded
            </p>
            </summary>
            <author>  Chris Cheetham
            </author>
        </member>
        <member name="F:Kavprot.Packets.Utils.AnsiEscapeSequences.EscapeBegin">
            <summary>
            Delimits the start of an ansi color sequence, the color code goes after this
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Utils.AnsiEscapeSequences.EscapeEnd">
            <summary>
            Delimits the stop of the ansi color sequence, the color code comes before this
            </summary>
        </member>
        <member name="T:Kavprot.Packets.PPPoEPacket">
            <summary>
            Point to Point Protocol
            See http://tools.ietf.org/html/rfc2516
            </summary>
        </member>
        <member name="M:Kavprot.Packets.PPPoEPacket.#ctor(Kavprot.Packets.PPPoECode,System.UInt16)">
            <summary>
            Construct a new PPPoEPacket from source and destination mac addresses
            </summary>
        </member>
        <member name="M:Kavprot.Packets.PPPoEPacket.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Constructor
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.PPPoEPacket.ToString(Kavprot.Packets.StringOutputType)">
            <summary cref="M:Kavprot.Packets.Packet.ToString(Kavprot.Packets.StringOutputType)"/>
        </member>
        <member name="M:Kavprot.Packets.PPPoEPacket.GetEncapsulated(Kavprot.Packets.Packet)">
            <summary>
            Returns the encapsulated PPPoE of the Packet p or null if
            there is no encapsulated packet
            </summary>
            <param name="p">
            A <see cref="T:Kavprot.Packets.Packet"/>
            </param>
            <returns>
            A <see cref="T:Kavprot.Packets.ARPPacket"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.PPPoEPacket.RandomPacket">
            <summary>
            Generate a random PPPoEPacket
            </summary>
            <returns>
            A <see cref="T:Kavprot.Packets.PPPoEPacket"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.PPPoEPacket.Version">
            <summary>
            PPPoe version, must be 0x1 according to RFC
            </summary>
            FIXME: This currently outputs the wrong version number
        </member>
        <member name="P:Kavprot.Packets.PPPoEPacket.Type">
            <summary>
            Type, must be 0x1 according to RFC
            </summary>
        </member>
        <member name="P:Kavprot.Packets.PPPoEPacket.Code">
             <summary>
            
             </summary>
             FIXME: This currently outputs the wrong code
        </member>
        <member name="P:Kavprot.Packets.PPPoEPacket.SessionId">
            <summary>
            Session identifier for this PPPoe packet
            </summary>
        </member>
        <member name="P:Kavprot.Packets.PPPoEPacket.Length">
            <summary>
            Length of the PPPoe payload, not including the PPPoe header
            </summary>
        </member>
        <member name="P:Kavprot.Packets.PPPoEPacket.Color">
            <summary> Fetch ascii escape sequence of the color associated with this packet type.</summary>
        </member>
        <member name="T:Kavprot.Packets.LLDP.StringTLV">
            <summary>
            Base class for several TLV types that all contain strings
            </summary>
        </member>
        <member name="M:Kavprot.Packets.LLDP.StringTLV.#ctor(System.Byte[],System.Int32)">
            <summary>
            Creates a String TLV
            </summary>
            <param name="bytes">
            </param>
            <param name="offset">
            The Port Description TLV's offset from the
            origin of the LLDP
            </param>
        </member>
        <member name="M:Kavprot.Packets.LLDP.StringTLV.#ctor(Kavprot.Packets.LLDP.TLVTypes,System.String)">
            <summary>
            Create from a type and string value
            </summary>
            <param name="tlvType">
            A <see cref="T:Kavprot.Packets.LLDP.TLVTypes"/>
            </param>
            <param name="StringValue">
            A <see cref="T:System.String"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.LLDP.StringTLV.ToString">
            <summary>
            Convert this Port Description TLV to a string.
            </summary>
            <returns>
            A human readable string
            </returns>
        </member>
        <member name="P:Kavprot.Packets.LLDP.StringTLV.StringValue">
            <value>
            A textual Description of the port
            </value>
        </member>
        <member name="T:Kavprot.Packets.IGMPv2Fields">
            <summary> IGMP protocol field encoding information. </summary>
        </member>
        <member name="F:Kavprot.Packets.IGMPv2Fields.TypeLength">
            <summary> Length of the IGMP message type code in bytes.</summary>
        </member>
        <member name="F:Kavprot.Packets.IGMPv2Fields.MaxResponseTimeLength">
            <summary> Length of the IGMP max response code in bytes.</summary>
        </member>
        <member name="F:Kavprot.Packets.IGMPv2Fields.ChecksumLength">
            <summary> Length of the IGMP header checksum in bytes.</summary>
        </member>
        <member name="F:Kavprot.Packets.IGMPv2Fields.GroupAddressLength">
            <summary> Length of group address in bytes.</summary>
        </member>
        <member name="F:Kavprot.Packets.IGMPv2Fields.TypePosition">
            <summary> Position of the IGMP message type.</summary>
        </member>
        <member name="F:Kavprot.Packets.IGMPv2Fields.MaxResponseTimePosition">
            <summary> Position of the IGMP max response code.</summary>
        </member>
        <member name="F:Kavprot.Packets.IGMPv2Fields.ChecksumPosition">
            <summary> Position of the IGMP header checksum.</summary>
        </member>
        <member name="F:Kavprot.Packets.IGMPv2Fields.GroupAddressPosition">
            <summary> Position of the IGMP group address.</summary>
        </member>
        <member name="F:Kavprot.Packets.IGMPv2Fields.HeaderLength">
            <summary> Length in bytes of an IGMP header.</summary>
        </member>
        <member name="T:Kavprot.Packets.ICMPv6Fields">
            <summary>
            ICMP protocol field encoding information.
            See http://en.wikipedia.org/wiki/ICMPv6
            </summary>
        </member>
        <member name="F:Kavprot.Packets.ICMPv6Fields.TypeLength">
            <summary> Length of the ICMP message type code in bytes.</summary>
        </member>
        <member name="F:Kavprot.Packets.ICMPv6Fields.CodeLength">
            <summary> Length of the ICMP subcode in bytes.</summary>
        </member>
        <member name="F:Kavprot.Packets.ICMPv6Fields.ChecksumLength">
            <summary> Length of the ICMP header checksum in bytes.</summary>
        </member>
        <member name="F:Kavprot.Packets.ICMPv6Fields.TypePosition">
            <summary> Position of the ICMP message type.</summary>
        </member>
        <member name="F:Kavprot.Packets.ICMPv6Fields.CodePosition">
            <summary> Position of the ICMP message subcode.</summary>
        </member>
        <member name="F:Kavprot.Packets.ICMPv6Fields.ChecksumPosition">
            <summary> Position of the ICMP header checksum.</summary>
        </member>
        <member name="F:Kavprot.Packets.ICMPv6Fields.HeaderLength">
            <summary> Length in bytes of an ICMP header.</summary>
        </member>
        <member name="T:Kavprot.Packets.EthernetPacketType">
             Copied from Pcap.Net @ 20091117
            
             <summary>
             Code constants for well-defined ethernet protocols.
            
             EtherType is a two-octet field in an Ethernet frame, as defined by the Ethernet II framing networking standard.
             It is used to indicate which protocol is encapsulated in the payload.
            
             Also contains entries taken from linux/if_ether.h and tcpdump/ethertype.h
             </summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetPacketType.None">
            <summary>
            No Ethernet type
            </summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetPacketType.IpV4">
            <summary>
            Internet Protocol, Version 4 (IPv4)
            </summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetPacketType.Arp">
            <summary>
            Address Resolution Protocol (ARP)
            </summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetPacketType.ReverseArp">
            <summary>
            Reverse Address Resolution Protocol (RARP)
            </summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetPacketType.WakeOnLan">
            <summary>
            Wake-On-Lan (WOL)
            </summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetPacketType.AppleTalk">
            <summary>
            AppleTalk (Ethertalk)
            </summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetPacketType.AppleTalkArp">
            <summary>
            AppleTalk Address Resolution Protocol (AARP)
            </summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetPacketType.VLanTaggedFrame">
            <summary>
            VLAN-tagged frame (IEEE 802.1Q)
            </summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetPacketType.NovellInternetworkPacketExchange">
            <summary>
            Novell IPX (alt)
            </summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetPacketType.Novell">
            <summary>
            Novell
            </summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetPacketType.IpV6">
            <summary>
            Internet Protocol, Version 6 (IPv6)
            </summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetPacketType.MacControl">
            <summary>
            MAC Control
            </summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetPacketType.CobraNet">
            <summary>
            CobraNet
            </summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetPacketType.MultiprotocolLabelSwitchingUnicast">
            <summary>
            MPLS unicast
            </summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetPacketType.MultiprotocolLabelSwitchingMulticast">
            <summary>
            MPLS multicast
            </summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetPacketType.PointToPointProtocolOverEthernetDiscoveryStage">
            <summary>
            PPPoE Discovery Stage
            </summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetPacketType.PointToPointProtocolOverEthernetSessionStage">
            <summary>
            PPPoE Session Stage
            </summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetPacketType.ExtensibleAuthenticationProtocolOverLan">
            <summary>
            EAP over LAN (IEEE 802.1X)
            </summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetPacketType.HyperScsi">
            <summary>
            HyperSCSI (SCSI over Ethernet)
            </summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetPacketType.AtaOverEthernet">
            <summary>
            ATA over Ethernet
            </summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetPacketType.EtherCatProtocol">
            <summary>
            EtherCAT Protocol
            </summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetPacketType.ProviderBridging">
            <summary>
            Provider Bridging (IEEE 802.1ad)
            </summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetPacketType.AvbTransportProtocol">
            <summary>
            AVB Transport Protocol (AVBTP)
            </summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetPacketType.LLDP">
            <summary>
            Link Layer Discovery Protocol (LLDP)
            </summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetPacketType.SerialRealTimeCommunicationSystemIii">
            <summary>
            SERCOS III
            </summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetPacketType.CircuitEmulationServicesOverEthernet">
            <summary>
            Circuit Emulation Services over Ethernet (MEF-8)
            </summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetPacketType.HomePlug">
            <summary>
            HomePlug
            </summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetPacketType.MacSecurity">
            <summary>
            MAC security (IEEE 802.1AE)
            </summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetPacketType.PrecisionTimeProtocol">
            <summary>
            Precision Time Protocol (IEEE 1588)
            </summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetPacketType.ConnectivityFaultManagementOrOperationsAdministrationManagement">
            <summary>
            IEEE 802.1ag Connectivity Fault Management (CFM) Protocol / ITU-T Recommendation Y.1731 (OAM)
            </summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetPacketType.FibreChannelOverEthernet">
            <summary>
            Fibre Channel over Ethernet
            </summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetPacketType.FibreChannelOverEthernetInitializationProtocol">
            <summary>
            FCoE Initialization Protocol
            </summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetPacketType.QInQ">
            <summary>
            Q-in-Q
            </summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetPacketType.VeritasLowLatencyTransport">
            <summary>
            Veritas Low Latency Transport (LLT)
            </summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetPacketType.Loop">
            <summary>
            Ethernet loopback packet
            </summary>
        </member>
        <member name="F:Kavprot.Packets.EthernetPacketType.Echo">
            <summary>
            Ethernet echo packet
            </summary>
        </member>
        <member name="T:Kavprot.Packets.EthernetPacket">
            <summary>
            See http://en.wikipedia.org/wiki/Ethernet#Ethernet_frame_types_and_the_EtherType_field
            </summary>
        </member>
        <member name="M:Kavprot.Packets.EthernetPacket.#ctor(System.Net.NetworkInformation.PhysicalAddress,System.Net.NetworkInformation.PhysicalAddress,Kavprot.Packets.EthernetPacketType)">
            <summary>
            Construct a new ethernet packet from source and destination mac addresses
            </summary>
        </member>
        <member name="M:Kavprot.Packets.EthernetPacket.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Constructor
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.EthernetPacket.ParseEncapsulatedBytes(Kavprot.Packets.Utils.ByteArraySegment,Kavprot.Packets.EthernetPacketType)">
            <summary>
            Used by the EthernetPacket constructor. Located here because the LinuxSLL constructor
            also needs to perform the same operations as it contains an ethernet type
            </summary>
            <param name="Header">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
            <param name="Type">
            A <see cref="T:Kavprot.Packets.EthernetPacketType"/>
            </param>
            <returns>
            A <see cref="T:Kavprot.Packets.PacketOrByteArraySegment"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.EthernetPacket.GetEncapsulated(Kavprot.Packets.Packet)">
            <summary>
            Returns the EthernetPacket inside of the Packet p or null if
            there is no encapsulated packet
            </summary>
            <param name="p">
            A <see cref="T:Kavprot.Packets.Packet"/>
            </param>
            <returns>
            A <see cref="T:Kavprot.Packets.EthernetPacket"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.EthernetPacket.ToString(Kavprot.Packets.StringOutputType)">
            <summary cref="M:Kavprot.Packets.Packet.ToString(Kavprot.Packets.StringOutputType)"/>
        </member>
        <member name="M:Kavprot.Packets.EthernetPacket.RandomPacket">
            <summary>
            Generate a random EthernetPacket
            TODO: could improve this routine to set a random payload as well
            </summary>
            <returns>
            A <see cref="T:Kavprot.Packets.EthernetPacket"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.EthernetPacket.PayloadPacket">
            <value>
            Payload packet, overridden to set the 'Type' field based on
            the type of packet being used here if the PayloadPacket is being set
            </value>
        </member>
        <member name="P:Kavprot.Packets.EthernetPacket.SourceHwAddress">
            <summary> MAC address of the host where the packet originated from.</summary>
        </member>
        <member name="P:Kavprot.Packets.EthernetPacket.DestinationHwAddress">
            <summary> MAC address of the host where the packet originated from.</summary>
        </member>
        <member name="P:Kavprot.Packets.EthernetPacket.Type">
            <value>
            Type of packet that this ethernet packet encapsulates
            </value>
        </member>
        <member name="P:Kavprot.Packets.EthernetPacket.Color">
            <summary> Fetch ascii escape sequence of the color associated with this packet type.</summary>
        </member>
        <member name="T:Kavprot.Packets.ApplicationPacket">
            <summary>
            Represents an application layer packet as described at http://en.wikipedia.org/wiki/Application_Layer
            </summary>
        </member>
        <member name="M:Kavprot.Packets.ApplicationPacket.#ctor">
            <summary>
            ApplicationPacket constructor
            </summary>
        </member>
        <member name="T:MiscUtil.Conversion.DoubleConverter">
            <summary>
            A class to allow the conversion of doubles to string representations of
            their exact decimal values. The implementation aims for readability over
            efficiency.
            </summary>
        </member>
        <member name="M:MiscUtil.Conversion.DoubleConverter.ToExactString(System.Double)">
            <summary>
            Converts the given double to a string representation of its
            exact decimal value.
            </summary>
            <param name="d">The double to convert.</param>
            <returns>A string representation of the double's exact decimal value.</returns>
        </member>
        <member name="T:MiscUtil.Conversion.DoubleConverter.ArbitraryDecimal">
            <summary>
            Private class used for manipulating sequences of decimal digits.
            </summary>
        </member>
        <member name="F:MiscUtil.Conversion.DoubleConverter.ArbitraryDecimal.digits">
            <summary>Digits in the decimal expansion, one byte per digit</summary>
        </member>
        <member name="F:MiscUtil.Conversion.DoubleConverter.ArbitraryDecimal.decimalPoint">
            <summary>
            How many digits are *after* the decimal point
            </summary>
        </member>
        <member name="M:MiscUtil.Conversion.DoubleConverter.ArbitraryDecimal.#ctor(System.Int64)">
            <summary>
            Constructs an arbitrary decimal expansion from the given long.
            The long must not be negative.
            </summary>
        </member>
        <member name="M:MiscUtil.Conversion.DoubleConverter.ArbitraryDecimal.MultiplyBy(System.Int32)">
            <summary>
            Multiplies the current expansion by the given amount, which should
            only be 2 or 5.
            </summary>
        </member>
        <member name="M:MiscUtil.Conversion.DoubleConverter.ArbitraryDecimal.Shift(System.Int32)">
            <summary>
            Shifts the decimal point; a negative value makes
            the decimal expansion bigger (as fewer digits come after the
            decimal place) and a positive value makes the decimal
            expansion smaller.
            </summary>
        </member>
        <member name="M:MiscUtil.Conversion.DoubleConverter.ArbitraryDecimal.Normalize">
            <summary>
            Removes leading/trailing zeroes from the expansion.
            </summary>
        </member>
        <member name="M:MiscUtil.Conversion.DoubleConverter.ArbitraryDecimal.ToString">
            <summary>
            Converts the value to a proper decimal string representation.
            </summary>
        </member>
        <member name="T:Kavprot.Packets.LLDP.SystemDescription">
            <summary>
            A System Description TLV
            </summary>
        </member>
        <member name="M:Kavprot.Packets.LLDP.SystemDescription.#ctor(System.Byte[],System.Int32)">
            <summary>
            Creates a System Description TLV
            </summary>
            <param name="bytes">
            </param>
            <param name="offset">
            The System Description TLV's offset from the
            origin of the LLDP
            </param>
        </member>
        <member name="M:Kavprot.Packets.LLDP.SystemDescription.#ctor(System.String)">
            <summary>
            Creates a System Description TLV and sets it value
            </summary>
            <param name="description">
            A textual Description of the system
            </param>
        </member>
        <member name="P:Kavprot.Packets.LLDP.SystemDescription.Description">
            <value>
            A textual Description of the system
            </value>
        </member>
        <member name="T:Kavprot.Packets.IGMPv2Packet">
            <summary>
            An IGMP packet.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.IGMPv2Packet.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Constructor
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.IGMPv2Packet.#ctor(Kavprot.Packets.Utils.ByteArraySegment,Kavprot.Packets.Packet)">
            <summary>
            Constructor with parent
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
            <param name="ParentPacket">
            A <see cref="T:Kavprot.Packets.Packet"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.IGMPv2Packet.GetEncapsulated(Kavprot.Packets.Packet)">
            <summary>
            Returns the encapsulated IGMPv2Packet of the Packet p or null if
            there is no encapsulated packet
            </summary>
            <param name="p">
            A <see cref="T:Kavprot.Packets.Packet"/>
            </param>
            <returns>
            A <see cref="T:Kavprot.Packets.IGMPv2Packet"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.IGMPv2Packet.ToString(Kavprot.Packets.StringOutputType)">
            <summary cref="M:Kavprot.Packets.Packet.ToString(Kavprot.Packets.StringOutputType)"/>
        </member>
        <member name="P:Kavprot.Packets.IGMPv2Packet.Type">
            <value>
            The type of IGMP message
            </value>
        </member>
        <member name="P:Kavprot.Packets.IGMPv2Packet.MaxResponseTime">
            <summary> Fetch the IGMP max response time.</summary>
        </member>
        <member name="P:Kavprot.Packets.IGMPv2Packet.Checksum">
            <summary> Fetch the IGMP header checksum.</summary>
        </member>
        <member name="P:Kavprot.Packets.IGMPv2Packet.GroupAddress">
            <summary> Fetch the IGMP group address.</summary>
        </member>
        <member name="P:Kavprot.Packets.IGMPv2Packet.Color">
            <summary> Fetch ascii escape sequence of the color associated with this packet type.</summary>
        </member>
        <member name="T:Kavprot.Packets.ICMPv6Packet">
            <summary>
            An ICMP packet.
            See http://en.wikipedia.org/wiki/ICMPv6
            </summary>
        </member>
        <member name="M:Kavprot.Packets.ICMPv6Packet.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Constructor
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.ICMPv6Packet.#ctor(Kavprot.Packets.Utils.ByteArraySegment,Kavprot.Packets.Packet)">
            <summary>
            Constructor with parent packet
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
            <param name="ParentPacket">
            A <see cref="T:Kavprot.Packets.Packet"/>
            </param>        
        </member>
        <member name="F:Kavprot.Packets.ICMPv6Packet.skipUpdating">
            <summary>
            Used to prevent a recursive stack overflow
            when recalculating in UpdateCalculatedValues()
            </summary>
        </member>
        <member name="M:Kavprot.Packets.ICMPv6Packet.UpdateCalculatedValues">
            <summary>
            Recalculate the checksum
            </summary>
        </member>
        <member name="M:Kavprot.Packets.ICMPv6Packet.ToString(Kavprot.Packets.StringOutputType)">
            <summary cref="M:Kavprot.Packets.Packet.ToString(Kavprot.Packets.StringOutputType)"/>
        </member>
        <member name="M:Kavprot.Packets.ICMPv6Packet.GetEncapsulated(Kavprot.Packets.Packet)">
            <summary>
            Returns the ICMPv6Packet inside of Packet p or null if
            there is no encapsulated ICMPv6Packet
            </summary>
            <param name="p">
            A <see cref="T:Kavprot.Packets.Packet"/>
            </param>
            <returns>
            A <see cref="T:Kavprot.Packets.ICMPv6Packet"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.ICMPv6Packet.Type">
            <value>
            The Type value
            </value>
        </member>
        <member name="P:Kavprot.Packets.ICMPv6Packet.Code">
            <summary> Fetch the ICMP code </summary>
        </member>
        <member name="P:Kavprot.Packets.ICMPv6Packet.Checksum">
            <value>
            Checksum value
            </value>
        </member>
        <member name="P:Kavprot.Packets.ICMPv6Packet.Color">
            <summary> Fetch ascii escape sequence of the color associated with this packet type.</summary>
        </member>
        <member name="T:Kavprot.Packets.Tcp.NoOperation">
            <summary>
            No Operation Option
             Used in the TCP Options field to pad the length to the next 32 byte boundary
            </summary>
            <remarks>
            References:
             http://datatracker.ietf.org/doc/rfc793/
            </remarks>
        </member>
        <member name="F:Kavprot.Packets.Tcp.NoOperation.OptionLength">
            <summary>
            The length (in bytes) of the NoOperation option
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Tcp.NoOperation.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Creates a No Operation Option
            </summary>
            <param name="bytes">
            A <see cref="!:System.Byte[]"/>
            </param>
            <param name="offset">
            A <see cref="T:System.Int32"/>
            </param>
            <param name="length">
            A <see cref="T:System.Int32"/>
            </param>
        </member>
        <member name="P:Kavprot.Packets.Tcp.NoOperation.Length">
            <summary>
            The length of the NoOperation field
             Returns 1 as opposed to returning the length field because
             the NoOperation option is only 1 byte long and doesn't
             contain a length field
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Tcp.MaximumSegmentSize">
            <summary>
            Maximum Segment Size Option
             An extension to the DataOffset/HeaderLength field to
             allow sizes greater than 65,535
            </summary>
            <remarks>
            References:
             http://datatracker.ietf.org/doc/rfc793/
            </remarks>
        </member>
        <member name="M:Kavprot.Packets.Tcp.MaximumSegmentSize.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Creates a Maximum Segment Size Option
            </summary>
            <param name="bytes">
            A <see cref="!:System.Byte[]"/>
            </param>
            <param name="offset">
            A <see cref="T:System.Int32"/>
            </param>
            <param name="length">
            A <see cref="T:System.Int32"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Tcp.MaximumSegmentSize.ToString">
            <summary>
            Returns the Option info as a string
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Tcp.MaximumSegmentSize.Value">
            <summary>
            The Maximum Segment Size
            </summary>
        </member>
        <member name="T:Kavprot.Packets.LLDP.TimeToLive">
            <summary>
            A Time to Live TLV
            </summary>
        </member>
        <member name="F:Kavprot.Packets.LLDP.TimeToLive.ValueLength">
            <summary>
            Number of bytes in the value portion of this tlv
            </summary>
        </member>
        <member name="M:Kavprot.Packets.LLDP.TimeToLive.#ctor(System.Byte[],System.Int32)">
            <summary>
            Creates a TTL TLV
            </summary>
            <param name="bytes">
            </param>
            <param name="offset">
            The TTL TLV's offset from the
            origin of the LLDP
            </param>
        </member>
        <member name="M:Kavprot.Packets.LLDP.TimeToLive.#ctor(System.UInt16)">
            <summary>
            Creates a TTL TLV and sets it value
            </summary>
            <param name="seconds">
            The length in seconds until the LLDP
            is refreshed
            </param>
        </member>
        <member name="M:Kavprot.Packets.LLDP.TimeToLive.ToString">
            <summary>
            Convert this TTL TLV to a string.
            </summary>
            <returns>
            A human readable string
            </returns>
        </member>
        <member name="P:Kavprot.Packets.LLDP.TimeToLive.Seconds">
             <value>
             The number of seconds until the LLDP needs
             to be refreshed
            
             A value of 0 means that the LLDP source is
             closed and should no longer be refreshed
             </value>
        </member>
        <member name="T:Kavprot.Packets.LLDP.SystemName">
            <summary>
            A System Name TLV
            </summary>
        </member>
        <member name="M:Kavprot.Packets.LLDP.SystemName.#ctor(System.Byte[],System.Int32)">
            <summary>
            Creates a System Name TLV
            </summary>
            <param name="bytes">
            </param>
            <param name="offset">
            The System Name TLV's offset from the
            origin of the LLDP
            </param>
        </member>
        <member name="M:Kavprot.Packets.LLDP.SystemName.#ctor(System.String)">
            <summary>
            Creates a System Name TLV and sets it value
            </summary>
            <param name="name">
            A textual Name of the system
            </param>
        </member>
        <member name="P:Kavprot.Packets.LLDP.SystemName.Name">
            <value>
            A textual Name of the system
            </value>
        </member>
        <member name="T:Kavprot.Packets.LLDP.SystemCapabilities">
             <summary>
             A System Capabilities TLV
            
             [TLVTypeLength - 2 bytes][System Capabilities - 2 bytes][Enabled Capabilities - 2 bytes]
             </summary>
        </member>
        <member name="M:Kavprot.Packets.LLDP.SystemCapabilities.#ctor(System.Byte[],System.Int32)">
            <summary>
            Creates a System Capabilities TLV
            </summary>
            <param name="bytes">
            </param>
            <param name="offset">
            The System Capabilities TLV's offset from the
            origin of the LLDP
            </param>
        </member>
        <member name="M:Kavprot.Packets.LLDP.SystemCapabilities.#ctor(System.UInt16,System.UInt16)">
            <summary>
            Creates a System Capabilities TLV and sets the value
            </summary>
            <param name="capabilities">
            A bitmap containing the available System Capabilities
            </param>
            <param name="enabled">
            A bitmap containing the enabled System Capabilities
            </param>
        </member>
        <member name="M:Kavprot.Packets.LLDP.SystemCapabilities.IsCapable(Kavprot.Packets.LLDP.CapabilityOptions)">
            <summary>
            Checks whether the system is capable of a certain function
            </summary>
            <param name="capability">
            The capability being checked
            </param>
            <returns>
            Whether or not the system is capable of the function being tested
            </returns>
        </member>
        <member name="M:Kavprot.Packets.LLDP.SystemCapabilities.IsEnabled(Kavprot.Packets.LLDP.CapabilityOptions)">
            <summary>
            Checks whether the specified function has been enabled on the system
            </summary>
            <param name="capability">
            The capability being checked
            </param>
            <returns>
            Whether or not the specified function is enabled
            </returns>
        </member>
        <member name="M:Kavprot.Packets.LLDP.SystemCapabilities.ToString">
            <summary>
            Convert this System Capabilities TLV to a string.
            </summary>
            <returns>
            A human readable string
            </returns>
        </member>
        <member name="P:Kavprot.Packets.LLDP.SystemCapabilities.Capabilities">
            <value>
            A bitmap containing the available System Capabilities
            </value>
        </member>
        <member name="P:Kavprot.Packets.LLDP.SystemCapabilities.Enabled">
            <value>
            A bitmap containing the Enabled System Capabilities
            </value>
        </member>
        <member name="T:Kavprot.Packets.LLDP.ChassisID">
            <summary>
            A Chassis ID TLV
            </summary>
        </member>
        <member name="F:Kavprot.Packets.LLDP.ChassisID.SubTypeLength">
            <summary>
            Length of the sub type field in bytes
            </summary>
        </member>
        <member name="M:Kavprot.Packets.LLDP.ChassisID.#ctor(System.Byte[],System.Int32)">
            <summary>
            Creates a Chassis ID TLV by parsing a byte[]
            </summary>
            <param name="bytes">
            </param>
            <param name="offset">
            The Chassis ID TLV's offset from the
            origin of the LLDP
            </param>
        </member>
        <member name="M:Kavprot.Packets.LLDP.ChassisID.#ctor(Kavprot.Packets.LLDP.ChassisSubTypes,System.Object)">
            <summary>
            Creates a Chassis ID TLV and sets it value
            </summary>
            <param name="subType">
            The ChassisID subtype
            </param>
            <param name="subTypeValue">
            The subtype's value
            </param>
        </member>
        <member name="M:Kavprot.Packets.LLDP.ChassisID.#ctor(System.Net.NetworkInformation.PhysicalAddress)">
            <summary>
            Create a ChassisID given a mac address
            </summary>
            <param name="MACAddress">
            A <see cref="T:System.Net.NetworkInformation.PhysicalAddress"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.LLDP.ChassisID.#ctor(System.String)">
            <summary>
            Create a ChassisID given an interface name
            http://tools.ietf.org/search/rfc2863 page 38
            </summary>
            <param name="InterfaceName">
            A <see cref="T:System.String"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.LLDP.ChassisID.EmptyTLVDataInit">
            <summary>
            Helper method to reduce duplication in type specific constructors
            </summary>
        </member>
        <member name="M:Kavprot.Packets.LLDP.ChassisID.ToString">
            <summary>
            Convert this Chassis ID TLV to a string.
            </summary>
            <returns>
            A human readable string
            </returns>
        </member>
        <member name="P:Kavprot.Packets.LLDP.ChassisID.SubType">
            <value>
            The type of the TLV subtype
            </value>
        </member>
        <member name="P:Kavprot.Packets.LLDP.ChassisID.SubTypeValue">
            <value>
            The TLV subtype value
            </value>
        </member>
        <member name="P:Kavprot.Packets.LLDP.ChassisID.ChassisComponent">
            <summary>
            If SubType is ChassisComponent
            </summary>
        </member>
        <member name="P:Kavprot.Packets.LLDP.ChassisID.InterfaceName">
            <summary>
            If SubType is InterfaceName the interface name
            </summary>
        </member>
        <member name="P:Kavprot.Packets.LLDP.ChassisID.MACAddress">
            <summary>
            If SubType is MACAddress the mac address
            </summary>
        </member>
        <member name="P:Kavprot.Packets.LLDP.ChassisID.NetworkAddress">
            <summary>
            If SubType is NetworkAddress the network address
            </summary>
        </member>
        <member name="P:Kavprot.Packets.LLDP.ChassisID.PortComponent">
            <summary>
            If SubType is PortComponent
            </summary>
        </member>
        <member name="P:Kavprot.Packets.LLDP.ChassisID.InterfaceAlias">
            <summary>
            If SubType is InterfaceAlias
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Tcp.MD5Signature">
            <summary>
            MD5 Signature
             Carries the MD5 Digest used by the BGP protocol to
              ensure security between two endpoints
            </summary>
            <remarks>
            References:
             http://datatracker.ietf.org/doc/rfc2385/
            </remarks>
        </member>
        <member name="M:Kavprot.Packets.Tcp.MD5Signature.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Creates a MD5 Signature Option
            </summary>
            <param name="bytes">
            A <see cref="!:System.Byte[]"/>
            </param>
            <param name="offset">
            A <see cref="T:System.Int32"/>
            </param>
            <param name="length">
            A <see cref="T:System.Int32"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Tcp.MD5Signature.ToString">
            <summary>
            Returns the Option info as a string
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Tcp.MD5Signature.MD5Digest">
            <summary>
            The MD5 Digest
            </summary>
        </member>
        <member name="T:Kavprot.Packets.LLDP.EndOfLLDPDU">
            <summary>
            An End Of LLDPDU TLV
            </summary>
        </member>
        <member name="M:Kavprot.Packets.LLDP.EndOfLLDPDU.#ctor(System.Byte[],System.Int32)">
            <summary>
            Parses bytes into an End Of LLDPDU TLV
            </summary>
            <param name="bytes">
            TLV bytes
            </param>
            <param name="offset">
            The End Of LLDPDU TLV's offset from the
            origin of the LLDP
            </param>
        </member>
        <member name="M:Kavprot.Packets.LLDP.EndOfLLDPDU.#ctor">
            <summary>
            Creates an End Of LLDPDU TLV
            </summary>
        </member>
        <member name="M:Kavprot.Packets.LLDP.EndOfLLDPDU.ToString">
            <summary>
            Convert this TTL TLV to a string.
            </summary>
            <returns>
            A human readable string
            </returns>
        </member>
        <member name="T:Kavprot.Packets.LLDPPacket">
            <summary>
            A LLDP packet.
            As specified in IEEE Std 802.1AB
            </summary>
            <remarks>
            See http://en.wikipedia.org/wiki/Link_Layer_Discovery_Protocol for general info
            See IETF 802.1AB for the full specification
            </remarks>
        </member>
        <member name="M:Kavprot.Packets.LLDPPacket.#ctor">
            <summary>
            Create an empty LLDPPacket
            </summary>
        </member>
        <member name="M:Kavprot.Packets.LLDPPacket.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Constructor
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.LLDPPacket.GetEnumerator">
            <summary>
            Enables foreach functionality for this class
            </summary>
            <returns>The next item in the list</returns>
        </member>
        <member name="M:Kavprot.Packets.LLDPPacket.ParseByteArrayIntoTlvs(System.Byte[],System.Int32)">
            <summary>
            Parse byte[] into TLVs
            </summary>
        </member>
        <member name="M:Kavprot.Packets.LLDPPacket.TLVFactory(System.Byte[],System.Int32,Kavprot.Packets.LLDP.TLVTypes)">
             <summary>
            
             </summary>
             <param name="Bytes">
             A <see cref="!:System.Byte[]"/>
             </param>
             <param name="offset">
             A <see cref="T:System.Int32"/>
             </param>
             <param name="type">
             A <see cref="T:Kavprot.Packets.LLDP.TLVTypes"/>
             </param>
             <returns>
             A <see cref="T:Kavprot.Packets.LLDP.TLV"/>
             </returns>
        </member>
        <member name="M:Kavprot.Packets.LLDPPacket.GetEncapsulated(Kavprot.Packets.Packet)">
            <summary>
            Returns the LLDP inside of the Packet p or null if
            there is no encapsulated packet
            </summary>
            <param name="p">
            A <see cref="T:Kavprot.Packets.Packet"/>
            </param>
            <returns>
            A <see cref="T:Kavprot.Packets.IpPacket"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.LLDPPacket.RandomPacket">
            <summary>
            Create a randomized LLDP packet with some basic TLVs
            </summary>
            <returns>
            A <see cref="T:Kavprot.Packets.Packet"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.LLDPPacket.ToString(Kavprot.Packets.StringOutputType)">
            <summary cref="M:Kavprot.Packets.Packet.ToString(Kavprot.Packets.StringOutputType)"/>
        </member>
        <member name="F:Kavprot.Packets.LLDPPacket.TlvCollection">
            <summary>
            Contains the TLV's in the LLDPDU
            </summary>
        </member>
        <member name="P:Kavprot.Packets.LLDPPacket.Length">
            <value>
            The current length of the LLDPDU
            </value>
        </member>
        <member name="P:Kavprot.Packets.LLDPPacket.BytesHighPerformance">
             <summary>
             LLDPPacket specific implementation of BytesHighPerformance
             Necessary because each TLV in the collection may have a
             byte[] that is not shared by other TLVs
            
             NOTE: There is potential for the same performance improvement that
                   the Packet class uses where we check to see if each TLVs uses the
                   same byte[] and that there are no gaps.
             </summary>
        </member>
        <member name="P:Kavprot.Packets.LLDPPacket.Item(System.Int32)">
            <summary>
            Allows access of the TlvCollection by index
            </summary>
            <param name="index">The index of the item being set/retrieved in the collection</param>
            <returns>The requested TLV</returns>
        </member>
        <member name="T:Kavprot.Packets.ICMPv4TypeCodes">
            <summary>
            Code constants for ICMP message types.
            From http://en.wikipedia.org/wiki/Internet_Control_Message_Protocol#List_of_permitted_control_messages_.28incomplete_list.29
            Note that these values represent the combined
            type and code fields, where the type field is the upper byte
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Tcp.SACK">
            <summary>
            SACK (Selective Ack) Option
             Provides a means for a receiver to notify the sender about
             all the segments that have arrived successfully.
             Used to cut down on the number of unnecessary re-transmissions.
            </summary>
            <remarks>
            References:
             http://datatracker.ietf.org/doc/rfc2018/
             http://datatracker.ietf.org/doc/rfc2883/
            </remarks>
        </member>
        <member name="M:Kavprot.Packets.Tcp.SACK.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Creates a SACK (Selective Ack) Option
            </summary>
            <param name="bytes">
            A <see cref="!:System.Byte[]"/>
            </param>
            <param name="offset">
            A <see cref="T:System.Int32"/>
            </param>
            <param name="length">
            A <see cref="T:System.Int32"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Tcp.SACK.ToString">
            <summary>
            Returns the Option info as a string
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Tcp.SACK.SACKBlocks">
            <summary>
            Contains an array of SACK (Selective Ack) Blocks
            </summary>
        </member>
        <member name="T:MiscUtil.Conversion.LittleEndianBitConverter">
            <summary>
            Implementation of EndianBitConverter which converts to/from little-endian
            byte arrays.
            </summary>
        </member>
        <member name="M:MiscUtil.Conversion.LittleEndianBitConverter.IsLittleEndian">
            <summary>
            Indicates the byte order ("endianess") in which data is converted using this class.
            </summary>
            <remarks>
            Different computer architectures store data using different byte orders. "Big-endian"
            means the most significant byte is on the left end of a word. "Little-endian" means the
            most significant byte is on the right end of a word.
            </remarks>
            <returns>true if this converter is little-endian, false otherwise.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.LittleEndianBitConverter.CopyBytesImpl(System.Int64,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Copies the specified number of bytes from value to buffer, starting at index.
            </summary>
            <param name="value">The value to copy</param>
            <param name="bytes">The number of bytes to copy</param>
            <param name="buffer">The buffer to copy the bytes into</param>
            <param name="index">The index to start at</param>
        </member>
        <member name="M:MiscUtil.Conversion.LittleEndianBitConverter.FromBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Returns a value built from the specified number of bytes from the given buffer,
            starting at index.
            </summary>
            <param name="buffer">The data in byte array format</param>
            <param name="startIndex">The first index to use</param>
            <param name="bytesToConvert">The number of bytes to use</param>
            <returns>The value built from the given bytes</returns>
        </member>
        <member name="P:MiscUtil.Conversion.LittleEndianBitConverter.Endianness">
            <summary>
            Indicates the byte order ("endianess") in which data is converted using this class.
            </summary>
        </member>
        <member name="T:Kavprot.Packets.LLDP.ManagementAddress">
             <summary>
             A Time to Live TLV
            
             [TLV Type Length : 2][Mgmt Addr length : 1][Mgmt Addr Subtype : 1][Mgmt Addr : 1-31]
             [Interface Subtype : 1][Interface number : 4][OID length : 1][OID : 0-128]
            
             </summary>
        </member>
        <member name="F:Kavprot.Packets.LLDP.ManagementAddress.MgmtAddressLengthLength">
            <summary>
            Number of bytes in the AddressLength field
            </summary>
        </member>
        <member name="F:Kavprot.Packets.LLDP.ManagementAddress.InterfaceNumberSubTypeLength">
            <summary>
            Number of bytes in the interface number subtype field
            </summary>
        </member>
        <member name="F:Kavprot.Packets.LLDP.ManagementAddress.InterfaceNumberLength">
            <summary>
            Number of bytes in the interface number field
            </summary>
        </member>
        <member name="F:Kavprot.Packets.LLDP.ManagementAddress.ObjectIdentifierLengthLength">
            <summary>
            Number of bytes in the object identifier length field
            </summary>
        </member>
        <member name="F:Kavprot.Packets.LLDP.ManagementAddress.maxObjectIdentifierLength">
            <summary>
            Maximum number of bytes in the object identifier field
            </summary>
        </member>
        <member name="M:Kavprot.Packets.LLDP.ManagementAddress.#ctor(System.Byte[],System.Int32)">
            <summary>
            Creates a Management Address TLV
            </summary>
            <param name="bytes">
            The LLDP Data unit being modified
            </param>
            <param name="offset">
            The Management Address TLV's offset from the
            origin of the LLDP
            </param>
        </member>
        <member name="M:Kavprot.Packets.LLDP.ManagementAddress.#ctor(Kavprot.Packets.LLDP.NetworkAddress,Kavprot.Packets.LLDP.InterfaceNumbering,System.UInt32,System.String)">
            <summary>
            Creates a Management Address TLV and sets it value
            </summary>
            <param name="managementAddress">
            The Management Address
            </param>
            <param name="interfaceSubType">
            The Interface Numbering Sub Type
            </param>
            <param name="ifNumber">
            The Interface Number
            </param>
            <param name="oid">
            The Object Identifier
            </param>
        </member>
        <member name="M:Kavprot.Packets.LLDP.ManagementAddress.ToString">
            <summary>
            Convert this Management Address TLV to a string.
            </summary>
            <returns>
            A human readable string
            </returns>
        </member>
        <member name="P:Kavprot.Packets.LLDP.ManagementAddress.AddressLength">
            <value>
            The Management Address Length
            </value>
        </member>
        <member name="P:Kavprot.Packets.LLDP.ManagementAddress.AddressSubType">
             <value>
             The Management Address Subtype
            
             Forward to the MgmtAddress instance
             </value>
        </member>
        <member name="P:Kavprot.Packets.LLDP.ManagementAddress.MgmtAddress">
            <value>
            The Management Address
            </value>
        </member>
        <member name="P:Kavprot.Packets.LLDP.ManagementAddress.InterfaceSubType">
            <value>
            Interface Number Sub Type
            </value>
        </member>
        <member name="P:Kavprot.Packets.LLDP.ManagementAddress.InterfaceNumber">
            <value>
            Interface Number
            </value>
        </member>
        <member name="P:Kavprot.Packets.LLDP.ManagementAddress.ObjIdLength">
            <value>
            Object ID Length
            </value>
        </member>
        <member name="P:Kavprot.Packets.LLDP.ManagementAddress.ObjectIdentifier">
            <value>
            Object ID
            </value>
        </member>
        <member name="T:Kavprot.Packets.Tcp.AlternateChecksumRequest">
            <summary>
            AlternateChecksumRequest Option
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Tcp.AlternateChecksumRequest.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Creates an Alternate Checksum Request Option
             Used to negotiate an alternative checksum algorithm in a connection
            </summary>
            <param name="bytes">
            A <see cref="!:System.Byte[]"/>
            </param>
            <param name="offset">
            A <see cref="T:System.Int32"/>
            </param>
            <param name="length">
            A <see cref="T:System.Int32"/>
            </param>
            <remarks>
            References:
             http://datatracker.ietf.org/doc/rfc1146/
            </remarks>
        </member>
        <member name="M:Kavprot.Packets.Tcp.AlternateChecksumRequest.ToString">
            <summary>
            Returns the Option info as a string
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Tcp.AlternateChecksumRequest.Checksum">
            <summary>
            The Checksum
            </summary>
        </member>
        <member name="T:Kavprot.Packets.PacketOrByteArraySegment">
            <summary>
            Encapsulates and ensures that we have either a Packet OR
            a ByteArraySegment but not both
            </summary>
        </member>
        <member name="M:Kavprot.Packets.PacketOrByteArraySegment.AppendToMemoryStream(System.IO.MemoryStream)">
            <summary>
            Appends to the MemoryStream either the byte[] represented by TheByteArray, or
            if ThePacket is non-null, the Packet.Bytes will be appended to the memory stream
            which will append ThePacket's header and any encapsulated packets it contains
            </summary>
            <param name="ms">
            A <see cref="T:System.IO.MemoryStream"/>
            </param>
        </member>
        <member name="P:Kavprot.Packets.PacketOrByteArraySegment.Type">
            <value>
            Whether or not this container contains a packet, a byte[] or neither
            </value>
        </member>
        <member name="T:Kavprot.Packets.LLDP.CapabilityOptions">
            <summary>
            The System Capabilities options
            </summary>
        </member>
        <member name="F:Kavprot.Packets.LLDP.CapabilityOptions.Other">
            <summary>
            An Other Type of System
            </summary>
        </member>
        <member name="F:Kavprot.Packets.LLDP.CapabilityOptions.Repeater">
            <summary>A Repeater</summary>
            <remarks>See IETF RFC 2108</remarks>
        </member>
        <member name="F:Kavprot.Packets.LLDP.CapabilityOptions.Bridge">
            <summary>A Bridge</summary>
            <remarks>IETF RFC 2674</remarks>
        </member>
        <member name="F:Kavprot.Packets.LLDP.CapabilityOptions.WLanAP">
            <summary>A WLAN Access Point</summary>
            <remarks>IEEE 802.11 MIB</remarks>
        </member>
        <member name="F:Kavprot.Packets.LLDP.CapabilityOptions.Router">
            <summary>A Router</summary>
            <remarks>IETF RFC 1812</remarks>
        </member>
        <member name="F:Kavprot.Packets.LLDP.CapabilityOptions.Telephone">
            <summary>A Telephone</summary>
            <remarks>IETF RFC 2011 </remarks>
        </member>
        <member name="F:Kavprot.Packets.LLDP.CapabilityOptions.DocsisCableDevice">
             <summary>A DOCSIS Cable Device</summary>
             <remarks>
             See IETF RFC 2669
             See IETF RFC 2670
            </remarks>
        </member>
        <member name="F:Kavprot.Packets.LLDP.CapabilityOptions.StationOnly">
            <summary>A Station with no other capabilities</summary>
            <remarks>IETF RFC 2011</remarks>
        </member>
        <member name="T:Kavprot.Packets.LLDP.AddressFamily">
            <summary>
            The IANA (Internet Assigned Numbers Authority) Address Family
            </summary>
            <remarks>Source http://www.iana.org/assignments/address-family-numbers/</remarks>
        </member>
        <member name="F:Kavprot.Packets.LLDP.AddressFamily.IPv4">
            <summary>IP version 4</summary>
        </member>
        <member name="F:Kavprot.Packets.LLDP.AddressFamily.IPv6">
            <summary>IP version 6</summary>
        </member>
        <member name="F:Kavprot.Packets.LLDP.AddressFamily.NSAP">
            <summary>NSAP</summary>
        </member>
        <member name="F:Kavprot.Packets.LLDP.AddressFamily.HDLC">
            <summary>HDLC</summary>
        </member>
        <member name="F:Kavprot.Packets.LLDP.AddressFamily.BBN1822">
            <summary>BBN 1822</summary>
        </member>
        <member name="F:Kavprot.Packets.LLDP.AddressFamily.Eth802">
            <summary>802 (includes all 802 media plus Ethernet "canonical format")</summary>
        </member>
        <member name="F:Kavprot.Packets.LLDP.AddressFamily.E163">
            <summary>E.163</summary>
        </member>
        <member name="T:Kavprot.Packets.IpVersion">
             <summary> Code constants for internet protocol versions.
            
             </summary>
        </member>
        <member name="F:Kavprot.Packets.IpVersion.IPv4">
            <summary> Internet protocol version 4.</summary>
        </member>
        <member name="F:Kavprot.Packets.IpVersion.IPv6">
            <summary> Internet protocol version 6.</summary>
        </member>
        <member name="T:Kavprot.Packets.IPProtocolType">
            <summary>
            The protocol encapsulated inside of the IP packet
            </summary>
        </member>
        <member name="F:Kavprot.Packets.IPProtocolType.IP">
            <summary> Dummy protocol for TCP. </summary>
        </member>
        <member name="F:Kavprot.Packets.IPProtocolType.HOPOPTS">
            <summary> IPv6 Hop-by-Hop options. </summary>
        </member>
        <member name="F:Kavprot.Packets.IPProtocolType.ICMP">
            <summary> Internet Control Message Protocol. </summary>
        </member>
        <member name="F:Kavprot.Packets.IPProtocolType.IGMP">
            <summary> Internet Group Management Protocol.</summary>
        </member>
        <member name="F:Kavprot.Packets.IPProtocolType.IPIP">
            <summary> IPIP tunnels (older KA9Q tunnels use 94). </summary>
        </member>
        <member name="F:Kavprot.Packets.IPProtocolType.TCP">
            <summary> Transmission Control Protocol. </summary>
        </member>
        <member name="F:Kavprot.Packets.IPProtocolType.EGP">
            <summary> Exterior Gateway Protocol. </summary>
        </member>
        <member name="F:Kavprot.Packets.IPProtocolType.PUP">
            <summary> PUP protocol. </summary>
        </member>
        <member name="F:Kavprot.Packets.IPProtocolType.UDP">
            <summary> User Datagram Protocol. </summary>
        </member>
        <member name="F:Kavprot.Packets.IPProtocolType.IDP">
            <summary> XNS IDP protocol. </summary>
        </member>
        <member name="F:Kavprot.Packets.IPProtocolType.TP">
            <summary> SO Transport Protocol Class 4. </summary>
        </member>
        <member name="F:Kavprot.Packets.IPProtocolType.IPV6">
            <summary> IPv6 header. </summary>
        </member>
        <member name="F:Kavprot.Packets.IPProtocolType.ROUTING">
            <summary> IPv6 routing header. </summary>
        </member>
        <member name="F:Kavprot.Packets.IPProtocolType.FRAGMENT">
            <summary> IPv6 fragmentation header. </summary>
        </member>
        <member name="F:Kavprot.Packets.IPProtocolType.RSVP">
            <summary> Reservation Protocol. </summary>
        </member>
        <member name="F:Kavprot.Packets.IPProtocolType.GRE">
            <summary> General Routing Encapsulation. </summary>
        </member>
        <member name="F:Kavprot.Packets.IPProtocolType.ESP">
            <summary> encapsulating security payload. </summary>
        </member>
        <member name="F:Kavprot.Packets.IPProtocolType.AH">
            <summary> authentication header. </summary>
        </member>
        <member name="F:Kavprot.Packets.IPProtocolType.ICMPV6">
            <summary> ICMPv6. </summary>
        </member>
        <member name="F:Kavprot.Packets.IPProtocolType.NONE">
            <summary> IPv6 no next header. </summary>
        </member>
        <member name="F:Kavprot.Packets.IPProtocolType.DSTOPTS">
            <summary> IPv6 destination options. </summary>
        </member>
        <member name="F:Kavprot.Packets.IPProtocolType.MTP">
            <summary> Multicast Transport Protocol. </summary>
        </member>
        <member name="F:Kavprot.Packets.IPProtocolType.ENCAP">
            <summary> Encapsulation Header. </summary>
        </member>
        <member name="F:Kavprot.Packets.IPProtocolType.PIM">
            <summary> Protocol Independent Multicast. </summary>
        </member>
        <member name="F:Kavprot.Packets.IPProtocolType.COMP">
            <summary> Compression Header Protocol. </summary>
        </member>
        <member name="F:Kavprot.Packets.IPProtocolType.RAW">
            <summary> Raw IP packets. </summary>
        </member>
        <member name="F:Kavprot.Packets.IPProtocolType.MASK">
            <summary> IP protocol mask.</summary>
        </member>
        <member name="T:Kavprot.Packets.Utils.RandomUtils">
            <summary>
            Random utility methods
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Utils.RandomUtils.GetIPAddress(Kavprot.Packets.IpVersion)">
            <summary>
            Generate a random ip address
            </summary>
            <param name="version">
            A <see cref="T:Kavprot.Packets.IpVersion"/>
            </param>
            <returns>
            A <see cref="T:System.Net.IPAddress"/>
            </returns>
        </member>
        <!-- Commentaire XML incorrect ignoré pour le membre "M:Kavprot.Packets.Utils.RandomUtils.LongestStringLength(System.Collections.Generic.List{System.String})" -->
        <member name="T:Kavprot.Packets.StringOutputType">
            <summary>
            The available types of strings that the ToString(StringOutputType) can handle.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.StringOutputType.Normal">
            <summary>
            Outputs the packet info on a single line
            </summary>
        </member>
        <member name="F:Kavprot.Packets.StringOutputType.Colored">
            <summary>
            Outputs the packet info on a single line with coloring
            </summary>
        </member>
        <member name="F:Kavprot.Packets.StringOutputType.Verbose">
            <summary>
            Outputs the detailed packet info
            </summary>
        </member>
        <member name="F:Kavprot.Packets.StringOutputType.VerboseColored">
            <summary>
            Outputs the detailed packet info with coloring
            </summary>
        </member>
        <member name="T:Kavprot.Packets.LLDP.TLVTypes">
            <summary>
            The TLV Types
            </summary>
            <remarks>
            See IETF RFC 802.1AB for more info
            </remarks>
        </member>
        <member name="F:Kavprot.Packets.LLDP.TLVTypes.EndOfLLDPU">
            <summary>Signifies the end of a LLDPU</summary>
            <description>
            The End Of LLDPDU TLV is a 2-octet, all-zero
            TLV that is used to mark the end of the TLV
            sequence in LLDPDUs
            </description>
            <remarks>Source: IETF RFC 802.1AB</remarks>
        </member>
        <member name="F:Kavprot.Packets.LLDP.TLVTypes.ChassisID">
            <summary>A Chassis Identifier</summary>
            <description>
            A mandatory TLV that identifies the chassis
            containing the IEEE 802 LAN station
            associated with the transmitting LLDP agent
            </description>
            <remarks>Source: IETF RFC 802.1AB</remarks>
        </member>
        <member name="F:Kavprot.Packets.LLDP.TLVTypes.PortID">
            <summary>A Port Identifier</summary>
            <description>
            A mandatory TLV that identifies the
            port component of the MSAP identifier associated
            with the transmitting LLDP agent.
            </description>
            <remarks>Source: IETF RFC 802.1AB</remarks>
        </member>
        <member name="F:Kavprot.Packets.LLDP.TLVTypes.TimeToLive">
             <summary>Specifies the Time to Live</summary>
             <description>
             Indicates the number of seconds that the
             recipient LLDP agent is to regard the information
             associated with this MSAP identifier to be valid
            
             A value of 0 signals that this source is no longer
             available and all information associated with it
             should be deleted.
             </description>
             <remarks>Source: IETF RFC 802.1AB</remarks>
        </member>
        <member name="F:Kavprot.Packets.LLDP.TLVTypes.PortDescription">
            <summary>A Description of the Port</summary>
            <description>
            The port description field shall contain an
            alpha-numeric string that indicates the port’s
            description.
            </description>
            <remarks>Source: IETF RFC 802.1AB</remarks>
        </member>
        <member name="F:Kavprot.Packets.LLDP.TLVTypes.SystemName">
            <summary>The System's Assigned Name</summary>
            <description>
            The System Name TLV allows network management
            to advertise the system’s assigned name.
            </description>
            <remarks>Source: IETF RFC 802.1AB</remarks>
        </member>
        <member name="F:Kavprot.Packets.LLDP.TLVTypes.SystemDescription">
            <summary>A Description of the System</summary>
            <description>
            The System Description TLV allows network
            management to advertise the system’s description
            </description>
            <remarks>Source: IETF RFC 802.1AB</remarks>
        </member>
        <member name="F:Kavprot.Packets.LLDP.TLVTypes.SystemCapabilities">
            <summary>A bitmap containing the System's capabilities</summary>
            <description>
            The System Capabilities TLV is an optional TLV
            that identifies the primary function(s) of the
            system and whether or not these primary functions
            are enabled.
            </description>
            <remarks>Source: IETF RFC 802.1AB</remarks>
        </member>
        <member name="F:Kavprot.Packets.LLDP.TLVTypes.ManagementAddress">
            <summary>The Management Address</summary>
            <description>
            The Management Address TLV identifies an address
            associated with the local LLDP agent that may be
            used to reach higher layer entities to assist
            discovery by network management.
            </description>
            <remarks>Source: IETF RFC 802.1AB</remarks>
        </member>
        <member name="F:Kavprot.Packets.LLDP.TLVTypes.OrganizationSpecific">
            <summary>A vendor-specifid TLV</summary>
            <description>
            This TLV category is provided to allow different
            organizations, such as IEEE 802.1, IEEE 802.3, IETF,
            as well as individual software and equipment vendors,
            to define TLVs that advertise information to remote
            entities attached to the same media.
            </description>
            <remarks>Source: IETF RFC 802.1AB</remarks>
        </member>
        <member name="T:Kavprot.Packets.LLDP.PortID">
            <summary>
            A Port ID TLV
            </summary>
        </member>
        <member name="M:Kavprot.Packets.LLDP.PortID.#ctor(System.Byte[],System.Int32)">
            <summary>
            Creates a Port ID TLV
            </summary>
            <param name="bytes">
            </param>
            <param name="offset">
            The Port ID TLV's offset from the
            origin of the LLDP
            </param>
        </member>
        <member name="M:Kavprot.Packets.LLDP.PortID.#ctor(Kavprot.Packets.LLDP.PortSubTypes,System.Object)">
            <summary>
            Creates a Port ID TLV and sets it value
            </summary>
            <param name="subType">
            The Port ID SubType
            </param>
            <param name="subTypeValue">
            The subtype's value
            </param>
        </member>
        <member name="M:Kavprot.Packets.LLDP.PortID.#ctor(Kavprot.Packets.LLDP.NetworkAddress)">
            <summary>
            Construct a PortID from a NetworkAddress
            </summary>
            <param name="networkAddress">
            A <see cref="T:Kavprot.Packets.LLDP.NetworkAddress"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.LLDP.PortID.EmptyTLVDataInit">
            <summary>
            Helper method to reduce duplication in type specific constructors
            </summary>
        </member>
        <member name="M:Kavprot.Packets.LLDP.PortID.ToString">
            <summary>
            Convert this Port ID TLV to a string.
            </summary>
            <returns>
            A human readable string
            </returns>
        </member>
        <member name="P:Kavprot.Packets.LLDP.PortID.SubType">
            <value>
            The type of the TLV subtype
            </value>
        </member>
        <member name="P:Kavprot.Packets.LLDP.PortID.SubTypeValue">
            <value>
            The TLV subtype value
            </value>
        </member>
        <member name="P:Kavprot.Packets.LLDP.PortID.DataOffset">
            <summary>
            Offset to the value field
            </summary>
        </member>
        <member name="P:Kavprot.Packets.LLDP.PortID.DataLength">
            <summary>
            Size of the value field
            </summary>
        </member>
        <member name="T:Kavprot.Packets.LLDP.OrganizationSpecific">
             <summary>
             An Organization Specific TLV
            
             [TLV Type Length : 2][Organizationally Unique Identifier OUI : 3]
             [Organizationally Defined Subtype : 1][Organizationally Defined Information String : 0 - 507]
             </summary>
        </member>
        <member name="M:Kavprot.Packets.LLDP.OrganizationSpecific.#ctor(System.Byte[],System.Int32)">
            <summary>
            Creates an Organization Specific TLV
            </summary>
            <param name="bytes">
            The LLDP Data unit being modified
            </param>
            <param name="offset">
            The Organization Specific TLV's offset from the
            origin of the LLDP
            </param>
        </member>
        <member name="M:Kavprot.Packets.LLDP.OrganizationSpecific.#ctor(System.Byte[],System.Int32,System.Byte[])">
            <summary>
            Creates an Organization Specific TLV and sets it value
            </summary>
            <param name="oui">
            An Organizationally Unique Identifier
            </param>
            <param name="subType">
            An Organizationally Defined SubType
            </param>
            <param name="infoString">
            An Organizationally Defined Information String
            </param>
        </member>
        <member name="M:Kavprot.Packets.LLDP.OrganizationSpecific.ToString">
            <summary>
            Convert this Organization Specific TLV to a string.
            </summary>
            <returns>
            A human readable string
            </returns>
        </member>
        <member name="P:Kavprot.Packets.LLDP.OrganizationSpecific.OrganizationUniqueID">
            <summary>
            An Organizationally Unique Identifier
            </summary>
        </member>
        <member name="P:Kavprot.Packets.LLDP.OrganizationSpecific.OrganizationDefinedSubType">
            <summary>
            An Organizationally Defined SubType
            </summary>
        </member>
        <member name="P:Kavprot.Packets.LLDP.OrganizationSpecific.OrganizationDefinedInfoString">
            <summary>
            An Organizationally Defined Information String
            </summary>
        </member>
        <member name="T:Kavprot.Packets.IPv6Fields">
            <summary>
            A struct containing length and position information about IPv6 Fields.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.IPv6Fields.VersionTrafficClassFlowLabelLength">
            <summary>
            The IP Version, Traffic Class, and Flow Label field length. These must be in one
            field due to boundary crossings.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.IPv6Fields.PayloadLengthLength">
            <summary>
            The payload length field length.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.IPv6Fields.NextHeaderLength">
            <summary>
            The next header field length, identifies protocol encapsulated by the packet
            </summary>
        </member>
        <member name="F:Kavprot.Packets.IPv6Fields.HopLimitLength">
            <summary>
            The hop limit field length.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.IPv6Fields.AddressLength">
            <summary>
            Address field length
            </summary>
        </member>
        <member name="F:Kavprot.Packets.IPv6Fields.VersionTrafficClassFlowLabelPosition">
            <summary>
            The byte position of the field line in the IPv6 header.
            This is where the IP version, Traffic Class, and Flow Label fields are.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.IPv6Fields.PayloadLengthPosition">
            <summary>
            The byte position of the payload length field.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.IPv6Fields.NextHeaderPosition">
            <summary>
            The byte position of the next header field. (Replaces the ipv4 protocol field)
            </summary>
        </member>
        <member name="F:Kavprot.Packets.IPv6Fields.HopLimitPosition">
            <summary>
            The byte position of the hop limit field.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.IPv6Fields.SourceAddressPosition">
            <summary>
            The byte position of the source address field.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.IPv6Fields.DestinationAddressPosition">
            <summary>
            The byte position of the destination address field.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.IPv6Fields.HeaderLength">
            <summary>
            The byte length of the IPv6 Header
            </summary>
        </member>
        <member name="M:Kavprot.Packets.IPv6Fields.#cctor">
            <summary>
            Commutes the field positions.
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Tcp.WindowScaleFactor">
            <summary>
            Window Scale Factor Option
             Expands the definition of the TCP window to 32 bits
            </summary>
            <remarks>
            References:
             http://datatracker.ietf.org/doc/rfc1323/
            </remarks>
        </member>
        <member name="M:Kavprot.Packets.Tcp.WindowScaleFactor.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Creates a Window Scale Factor Option
            </summary>
            <param name="bytes">
            A <see cref="!:System.Byte[]"/>
            </param>
            <param name="offset">
            A <see cref="T:System.Int32"/>
            </param>
            <param name="length">
            A <see cref="T:System.Int32"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Tcp.WindowScaleFactor.ToString">
            <summary>
            Returns the Option info as a string
             The multiplier is equal to a value of 1 left-shifted by the scale factor
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Tcp.WindowScaleFactor.ScaleFactor">
            <summary>
            The Window Scale Factor
             used as a multiplier to the window value
             The multiplier is equal to 1 left-shifted by the ScaleFactor
             So a scale factor of 7 would equal 1 &lt;&lt; 7 = 128
            </summary>
        </member>
        <member name="T:Kavprot.Packets.PPPFields">
            <summary>
            The fields in a PPP packet
            See http://en.wikipedia.org/wiki/Point-to-Point_Protocol
            </summary>
        </member>
        <member name="F:Kavprot.Packets.PPPFields.ProtocolLength">
            <summary>
            Length of the Protocol field in bytes, the field is of type
            PPPProtocol
            </summary>
        </member>
        <member name="F:Kavprot.Packets.PPPFields.ProtocolPosition">
            <summary>
            Offset from the start of the PPP packet where the Protocol field is located
            </summary>
        </member>
        <member name="F:Kavprot.Packets.PPPFields.HeaderLength">
            <summary>
            The length of the header
            </summary>
        </member>
        <member name="T:Kavprot.Packets.ICMPv6Types">
            <summary>
            ICMPv6 types, see http://en.wikipedia.org/wiki/ICMPv6 and
            http://www.iana.org/assignments/icmpv6-parameters
            </summary>
        </member>
        <member name="T:Kavprot.Packets.ICMPv4Fields">
            <summary>
            ICMP protocol field encoding information.
            See http://en.wikipedia.org/wiki/ICMPv6
            </summary>
        </member>
        <member name="F:Kavprot.Packets.ICMPv4Fields.TypeCodeLength">
            <summary> Length of the ICMP message type code in bytes.</summary>
        </member>
        <member name="F:Kavprot.Packets.ICMPv4Fields.ChecksumLength">
            <summary> Length of the ICMP header checksum in bytes.</summary>
        </member>
        <member name="F:Kavprot.Packets.ICMPv4Fields.IDLength">
            <summary> Length of the ICMP ID field in bytes.</summary>
        </member>
        <member name="F:Kavprot.Packets.ICMPv4Fields.SequenceLength">
            <summary> Length of the ICMP Sequence field in bytes </summary>
        </member>
        <member name="F:Kavprot.Packets.ICMPv4Fields.TypeCodePosition">
            <summary> Position of the ICMP message type/code.</summary>
        </member>
        <member name="F:Kavprot.Packets.ICMPv4Fields.ChecksumPosition">
            <summary> Position of the ICMP header checksum.</summary>
        </member>
        <member name="F:Kavprot.Packets.ICMPv4Fields.IDPosition">
            <summary> Position of the ICMP ID field </summary>
        </member>
        <member name="F:Kavprot.Packets.ICMPv4Fields.SequencePosition">
            <summary> Position of the Sequence field </summary>
        </member>
        <member name="F:Kavprot.Packets.ICMPv4Fields.HeaderLength">
            <summary> Length in bytes of an ICMP header.</summary>
        </member>
        <member name="T:Kavprot.Packets.Utils.Crc32">
            <summary>Implements a 32-bits cyclic redundancy check (CRC) hash algorithm.</summary>
            <remarks>This class is not intended to be used for security purposes. For security applications use MD5, SHA1, SHA256, SHA384, 
            or SHA512 in the System.Security.Cryptography namespace.</remarks>
        </member>
        <member name="F:Kavprot.Packets.Utils.Crc32.DefaultPolynomial">
            <summary>Gets the default polynomial (used in WinZip, Ethernet, etc.)</summary>
            <remarks>The default polynomial is a bit-reflected version of the standard polynomial 0x04C11DB7 used by WinZip, Ethernet, etc.</remarks>
        </member>
        <member name="M:Kavprot.Packets.Utils.Crc32.#ctor">
            <summary>Creates a CRC32 object using the <see cref="F:Kavprot.Packets.Utils.Crc32.DefaultPolynomial"/>.</summary>
        </member>
        <member name="M:Kavprot.Packets.Utils.Crc32.#ctor(System.UInt32)">
            <summary>Creates a CRC32 object using the specified polynomial.</summary>
            <remarks>The polynomial should be supplied in its bit-reflected form. <see cref="F:Kavprot.Packets.Utils.Crc32.DefaultPolynomial"/>.</remarks>
        </member>
        <member name="M:Kavprot.Packets.Utils.Crc32.Compute(System.String)">
            <summary>Computes the CRC32 value for the given ASCII string using the <see cref="F:Kavprot.Packets.Utils.Crc32.DefaultPolynomial"/>.</summary>
        </member>
        <member name="M:Kavprot.Packets.Utils.Crc32.Compute(System.IO.Stream)">
            <summary>Computes the CRC32 value for the given input stream using the <see cref="F:Kavprot.Packets.Utils.Crc32.DefaultPolynomial"/>.</summary>
        </member>
        <member name="M:Kavprot.Packets.Utils.Crc32.Compute(System.Byte[])">
            <summary>Computes the CRC32 value for the input data using the <see cref="F:Kavprot.Packets.Utils.Crc32.DefaultPolynomial"/>.</summary>
        </member>
        <member name="M:Kavprot.Packets.Utils.Crc32.Compute(System.Byte[],System.Int32,System.Int32)">
            <summary>Computes the hash value for the input data using the <see cref="F:Kavprot.Packets.Utils.Crc32.DefaultPolynomial"/>.</summary>
        </member>
        <member name="M:Kavprot.Packets.Utils.Crc32.ComputeHash(System.String)">
            <summary>Computes the hash value for the given ASCII string.</summary>
            <remarks>The computation preserves the internal state between the calls, so it can be used for computation of a stream data.</remarks>
        </member>
        <member name="M:Kavprot.Packets.Utils.Crc32.ComputeHash(System.IO.Stream)">
            <summary>Computes the hash value for the given input stream.</summary>
            <remarks>The computation preserves the internal state between the calls, so it can be used for computation of a stream data.</remarks>
        </member>
        <member name="M:Kavprot.Packets.Utils.Crc32.ComputeHash(System.Byte[])">
            <summary>Computes the hash value for the input data.</summary>
            <remarks>The computation preserves the internal state between the calls, so it can be used for computation of a stream data.</remarks>
        </member>
        <member name="M:Kavprot.Packets.Utils.Crc32.ComputeHash(System.Byte[],System.Int32,System.Int32)">
            <summary>Computes the hash value for the input data.</summary>
            <remarks>The computation preserves the internal state between the calls, so it can be used for computation of a stream data.</remarks>
        </member>
        <member name="M:Kavprot.Packets.Utils.Crc32.Initialize">
            <summary>Initializes an implementation of HashAlgorithm.</summary>
        </member>
        <member name="M:Kavprot.Packets.Utils.Crc32.HashCore(System.Byte[],System.Int32,System.Int32)">
            <summary>Routes data written to the object into the hash algorithm for computing the hash.</summary>
        </member>
        <member name="M:Kavprot.Packets.Utils.Crc32.HashFinal">
            <summary>Finalizes the hash computation after the last data is processed by the cryptographic stream object.</summary>
        </member>
        <member name="T:Kavprot.Packets.Tcp.EchoReply">
            <summary>
            Echo Reply Option
             Marked obsolete in the TCP spec Echo Reply Option has been
             replaced by the TSOPT (Timestamp Option)
            </summary>
            <remarks>
            References:
             http://datatracker.ietf.org/doc/rfc1072/
            </remarks>
        </member>
        <member name="M:Kavprot.Packets.Tcp.EchoReply.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Creates an Echo Reply Option
            </summary>
            <param name="bytes">
            A <see cref="!:System.Byte[]"/>
            </param>
            <param name="offset">
            A <see cref="T:System.Int32"/>
            </param>
            <param name="length">
            A <see cref="T:System.Int32"/>
            </param>
        </member>
        <member name="T:Kavprot.Packets.PPPPacket">
            <summary>
            PPP packet
            See http://en.wikipedia.org/wiki/Point-to-Point_Protocol
            </summary>
        </member>
        <member name="M:Kavprot.Packets.PPPPacket.#ctor(Kavprot.Packets.PPPoECode,System.UInt16)">
            <summary>
            Construct a new PPPPacket from source and destination mac addresses
            </summary>
        </member>
        <member name="M:Kavprot.Packets.PPPPacket.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Constructor
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.PPPPacket.ToString(Kavprot.Packets.StringOutputType)">
            <summary cref="M:Kavprot.Packets.Packet.ToString(Kavprot.Packets.StringOutputType)"/>
        </member>
        <member name="M:Kavprot.Packets.PPPPacket.GetEncapsulated(Kavprot.Packets.Packet)">
            <summary>
            Returns the encapsulated PPPPacket of the Packet p or null if
            there is no encapsulated packet
            </summary>
            <param name="p">
            A <see cref="T:Kavprot.Packets.Packet"/>
            </param>
            <returns>
            A <see cref="T:Kavprot.Packets.PPPPacket"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.PPPPacket.RandomPacket">
            <summary>
            Generate a random PPPoEPacket
            </summary>
            <returns>
            A <see cref="T:Kavprot.Packets.PPPoEPacket"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.PPPPacket.Protocol">
            <summary>
            See http://www.iana.org/assignments/ppp-numbers
            </summary>
        </member>
        <member name="P:Kavprot.Packets.PPPPacket.Color">
            <summary> Fetch ascii escape sequence of the color associated with this packet type.</summary>
        </member>
        <member name="T:Kavprot.Packets.LLDP.TLVTypeLength">
            <summary>
            Tlv type and length are 2 bytes
            See http://en.wikipedia.org/wiki/Link_Layer_Discovery_Protocol#Frame_structure
            </summary>
        </member>
        <member name="F:Kavprot.Packets.LLDP.TLVTypeLength.TypeLengthLength">
            <summary>
            Length in bytes of the tlv type and length fields
            </summary>
        </member>
        <member name="M:Kavprot.Packets.LLDP.TLVTypeLength.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Construct a TLVTypeLength for a TLV
            </summary>
            <param name="byteArraySegment">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
        </member>
        <member name="P:Kavprot.Packets.LLDP.TLVTypeLength.Type">
            <value>
            The TLV Value's Type
            </value>
        </member>
        <member name="P:Kavprot.Packets.LLDP.TLVTypeLength.Length">
            <value>
            The TLV Value's Length
            NOTE: Value is the length of the TLV Value only, does not include the length
                  of the type and length fields
            </value>
        </member>
        <member name="P:Kavprot.Packets.LLDP.TLVTypeLength.TypeAndLength">
            <value>
            A unsigned short representing the concatenated Type and Length
            </value>
        </member>
        <member name="T:Kavprot.Packets.LLDP.PortSubTypes">
            <summary>
            The Port ID TLV subtypes
            </summary>
        </member>
        <member name="F:Kavprot.Packets.LLDP.PortSubTypes.InterfaceAlias">
            <summary>An Interface Alias identifier</summary>
            <remarks>See IETF RFC 2863</remarks>
        </member>
        <member name="F:Kavprot.Packets.LLDP.PortSubTypes.PortComponent">
            <summary>A Port Component identifier</summary>
            <remarks>See IETF RFC 2737</remarks>
        </member>
        <member name="F:Kavprot.Packets.LLDP.PortSubTypes.MACAddress">
            <summary>A MAC (Media Access Control) Address identifier</summary>
            <remarks>See IEEE Std 802</remarks>
        </member>
        <member name="F:Kavprot.Packets.LLDP.PortSubTypes.NetworkAddress">
            <summary>A Network Address (IP Address) Identifier</summary>
            <remarks>See IEEE Std 802</remarks>
        </member>
        <member name="F:Kavprot.Packets.LLDP.PortSubTypes.InterfaceName">
            <summary>An Interface Name identifier</summary>
            <remarks>See IEEE Std 802</remarks>
        </member>
        <member name="F:Kavprot.Packets.LLDP.PortSubTypes.AgentCircuitID">
            <summary>An Agent Circiut ID identifier</summary>
            <remarks>See IETF RFC 3046</remarks>
        </member>
        <member name="F:Kavprot.Packets.LLDP.PortSubTypes.LocallyAssigned">
            <summary>A Locally Assigned identifier</summary>
            <remarks>See IETF RFC 3046</remarks>
        </member>
        <member name="T:Kavprot.Packets.IPv6Packet">
             <summary>
             IPv6 packet
            
             References
             ----------
             http://tools.ietf.org/html/rfc2460
             http://en.wikipedia.org/wiki/IPv6
             </summary>
        </member>
        <member name="F:Kavprot.Packets.IPv6Packet.HeaderMinimumLength">
            <value>
            Minimum number of bytes in an IPv6 header
            </value>
        </member>
        <member name="F:Kavprot.Packets.IPv6Packet.ipVersion">
            <value>
            The version of the IP protocol. The '6' in IPv6 indicates the version of the protocol
            </value>
        </member>
        <member name="M:Kavprot.Packets.IPv6Packet.#ctor(System.Net.IPAddress,System.Net.IPAddress)">
            <summary>
            Create an IPv6 packet from values
            </summary>
            <param name="SourceAddress">
            A <see cref="T:System.Net.IPAddress"/>
            </param>
            <param name="DestinationAddress">
            A <see cref="T:System.Net.IPAddress"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.IPv6Packet.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Constructor
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.IPv6Packet.AttachPseudoIPHeader(System.Byte[])">
             <summary>
             Prepend to the given byte[] origHeader the portion of the IPv6 header used for
             generating an tcp checksum
            
             http://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_checksum_using_IPv6
             http://tools.ietf.org/html/rfc2460#page-27
             </summary>
             <param name="origHeader">
             A <see cref="T:System.Byte"/>
             </param>
             <returns>
             A <see cref="T:System.Byte"/>
             </returns>
        </member>
        <member name="M:Kavprot.Packets.IPv6Packet.ToString(Kavprot.Packets.StringOutputType)">
            <summary cref="M:Kavprot.Packets.Packet.ToString(Kavprot.Packets.StringOutputType)"/>
        </member>
        <member name="M:Kavprot.Packets.IPv6Packet.RandomPacket">
            <summary>
            Generate a random packet
            </summary>
            <returns>
            A <see cref="T:Kavprot.Packets.Packet"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.IPv6Packet.Version">
            <summary>
            The version field of the IPv6 Packet.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.IPv6Packet.TrafficClass">
            <summary>
            The traffic class field of the IPv6 Packet.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.IPv6Packet.FlowLabel">
            <summary>
            The flow label field of the IPv6 Packet.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.IPv6Packet.PayloadLength">
            <summary>
            The payload lengeth field of the IPv6 Packet
            NOTE: Differs from the IPv4 'Total length' field that includes the length of the header as
                  payload length is ONLY the size of the payload.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.IPv6Packet.HeaderLength">
            <value>
            Backwards compatibility property for IPv4.HeaderLength
            NOTE: This field is the number of 32bit words
            </value>
        </member>
        <member name="P:Kavprot.Packets.IPv6Packet.TotalLength">
            <value>
            Backwards compatibility property for IPv4.TotalLength
            </value>
        </member>
        <member name="P:Kavprot.Packets.IPv6Packet.NextHeader">
             <summary>
             Identifies the protocol encapsulated by this packet
            
             Replaces IPv4's 'protocol' field, has compatible values
             </summary>
        </member>
        <member name="P:Kavprot.Packets.IPv6Packet.Protocol">
            <value>
            The protocol of the packet encapsulated in this ip packet
            </value>
        </member>
        <member name="P:Kavprot.Packets.IPv6Packet.HopLimit">
             <summary>
             The hop limit field of the IPv6 Packet.
             NOTE: Replaces the 'time to live' field of IPv4
            
             8-bit value
             </summary>
        </member>
        <member name="P:Kavprot.Packets.IPv6Packet.TimeToLive">
            <value>
            Helper alias for 'HopLimit'
            </value>
        </member>
        <member name="P:Kavprot.Packets.IPv6Packet.SourceAddress">
            <summary>
            The source address field of the IPv6 Packet.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.IPv6Packet.DestinationAddress">
            <summary>
            The destination address field of the IPv6 Packet.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.IPv6Packet.Color">
            <summary> Fetch ascii escape sequence of the color associated with this packet type.</summary>
        </member>
        <member name="T:Kavprot.Packets.ICMPv4Packet">
            <summary>
            An ICMP packet
            See http://en.wikipedia.org/wiki/Internet_Control_Message_Protocol
            </summary>
        </member>
        <member name="M:Kavprot.Packets.ICMPv4Packet.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Constructor
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.ICMPv4Packet.#ctor(Kavprot.Packets.Utils.ByteArraySegment,Kavprot.Packets.Packet)">
            <summary>
            Construct with parent packet
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
            <param name="ParentPacket">
            A <see cref="T:Kavprot.Packets.Packet"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.ICMPv4Packet.ToString(Kavprot.Packets.StringOutputType)">
            <summary cref="M:Kavprot.Packets.Packet.ToString(Kavprot.Packets.StringOutputType)"/>
        </member>
        <member name="M:Kavprot.Packets.ICMPv4Packet.GetEncapsulated(Kavprot.Packets.Packet)">
            <summary>
            Returns the ICMPv4Packet inside of Packet p or null if
            there is no encapsulated ICMPv4Packet
            </summary>
            <param name="p">
            A <see cref="T:Kavprot.Packets.Packet"/>
            </param>
            <returns>
            A <see cref="T:Kavprot.Packets.ICMPv4Packet"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.ICMPv4Packet.TypeCode">
            <value>
            The Type/Code enum value
            </value>
        </member>
        <member name="P:Kavprot.Packets.ICMPv4Packet.Checksum">
            <value>
            Checksum value
            </value>
        </member>
        <member name="P:Kavprot.Packets.ICMPv4Packet.ID">
            <summary>
            ID field
            </summary>
        </member>
        <member name="P:Kavprot.Packets.ICMPv4Packet.Sequence">
            <summary>
            Sequence field
            </summary>
        </member>
        <member name="P:Kavprot.Packets.ICMPv4Packet.Data">
            <summary>
            Contents of the ICMP packet
            </summary>
        </member>
        <member name="P:Kavprot.Packets.ICMPv4Packet.Color">
            <summary> Fetch ascii escape sequence of the color associated with this packet type.</summary>
        </member>
        <member name="T:Kavprot.Packets.PPPProtocol">
            <summary>
            Indicates the protocol encapsulated by the PPP packet
            See http://www.iana.org/assignments/ppp-numbers
            </summary>
        </member>
        <member name="F:Kavprot.Packets.PPPProtocol.Padding">
            <summary> Padding </summary>
        </member>
        <member name="F:Kavprot.Packets.PPPProtocol.IPv4">
            <summary> IPv4 </summary>
        </member>
        <member name="F:Kavprot.Packets.PPPProtocol.IPv6">
            <summary> IPv6 </summary>
        </member>
        <member name="T:Kavprot.Packets.TLVCollection">
             <summary>
             Custom collection for TLV types
            
             Special behavior includes:
             - Preventing an EndOfLLDPDU tlv from being added out of place
             - Checking and throwing exceptions if one-per-LLDP packet TLVs are added multiple times
             </summary>
        </member>
        <member name="M:Kavprot.Packets.TLVCollection.InsertItem(System.Int32,Kavprot.Packets.LLDP.TLV)">
             <summary>
             Override to:
             - Prevent duplicate end tlvs from being added
             - Ensure that an end tlv is present
             - Replace any automatically added end tlvs with the user provided tlv
            
             </summary>
             <param name="index">
             A <see cref="T:System.Int32"/>
             </param>
             <param name="item">
             A <see cref="T:Kavprot.Packets.LLDP.TLV"/>
             </param>
        </member>
        <member name="T:Kavprot.Packets.LinuxSLLFields">
            <summary>
            Lengths and offsets to the fields in the LinuxSLL packet
            See http://github.com/mcr/libpcap/blob/master/pcap/sll.h
            </summary>
        </member>
        <member name="F:Kavprot.Packets.LinuxSLLFields.PacketTypeLength">
            <summary>
            Length of the packet type field
            </summary>
        </member>
        <member name="F:Kavprot.Packets.LinuxSLLFields.LinkLayerAddressTypeLength">
            <summary>
            Link layer address type
            </summary>
        </member>
        <member name="F:Kavprot.Packets.LinuxSLLFields.LinkLayerAddressLengthLength">
            <summary>
            Link layer address length
            </summary>
        </member>
        <member name="F:Kavprot.Packets.LinuxSLLFields.LinkLayerAddressMaximumLength">
            <summary>
            The link layer address field length
            NOTE: the actual link layer address MAY be shorter than this
            </summary>
        </member>
        <member name="F:Kavprot.Packets.LinuxSLLFields.SLLHeaderLength">
            <summary>
            Number of bytes in a SLL header
            </summary>
        </member>
        <member name="F:Kavprot.Packets.LinuxSLLFields.EthernetProtocolTypeLength">
            <summary>
            Length of the ethernet protocol field
            </summary>
        </member>
        <member name="F:Kavprot.Packets.LinuxSLLFields.PacketTypePosition">
            <summary>
            Position of the packet type field
            </summary>
        </member>
        <member name="F:Kavprot.Packets.LinuxSLLFields.LinkLayerAddressTypePosition">
            <summary>
            Position of the link layer address type field
            </summary>
        </member>
        <member name="F:Kavprot.Packets.LinuxSLLFields.LinkLayerAddressLengthPosition">
            <summary>
            Positino of the link layer address length field
            </summary>
        </member>
        <member name="F:Kavprot.Packets.LinuxSLLFields.LinkLayerAddressPosition">
            <summary>
            Position of the link layer address field
            </summary>
        </member>
        <member name="F:Kavprot.Packets.LinuxSLLFields.EthernetProtocolTypePosition">
            <summary>
            Position of the ethernet protocol type field
            </summary>
        </member>
        <member name="T:Kavprot.Packets.LinkLayers">
            <summary> Link-layer type codes.
            <p>
            Taken from libpcap/bpf/net/bpf.h and pcap/net/bpf.h.
            </p>
            <p>
            The link-layer type is used to determine what data-structure the
            IP protocol bits will be encapsulated inside of.
            </p>
            <p>
            On a 10/100mbps network, packets are encapsulated inside of ethernet.
            14-byte ethernet headers which contain MAC addresses and an ethernet type
            field.
            </p>
            <p>
            On ethernet over ppp, the link-layer type is raw, and packets
            are not encapsulated in any ethernet header.
            </p>
            </summary>
        </member>
        <member name="F:Kavprot.Packets.LinkLayers.Null">
            <summary> no link-layer encapsulation </summary>
        </member>
        <member name="F:Kavprot.Packets.LinkLayers.Ethernet">
            <summary> Ethernet (10Mb) </summary>
        </member>
        <member name="F:Kavprot.Packets.LinkLayers.ExperimentalEthernet3MB">
            <summary> Experimental Ethernet (3Mb) </summary>
        </member>
        <member name="F:Kavprot.Packets.LinkLayers.AmateurRadioAX25">
            <summary> Amateur Radio AX.25 </summary>
        </member>
        <member name="F:Kavprot.Packets.LinkLayers.ProteonProNetTokenRing">
            <summary> Proteon ProNET Token Ring </summary>
        </member>
        <member name="F:Kavprot.Packets.LinkLayers.Chaos">
            <summary> Chaos </summary>
        </member>
        <member name="F:Kavprot.Packets.LinkLayers.Ieee802">
            <summary> IEEE 802 Networks </summary>
        </member>
        <member name="F:Kavprot.Packets.LinkLayers.ArcNet">
            <summary> ARCNET </summary>
        </member>
        <member name="F:Kavprot.Packets.LinkLayers.Slip">
            <summary> Serial Line IP </summary>
        </member>
        <member name="F:Kavprot.Packets.LinkLayers.Ppp">
            <summary> Point-to-point Protocol </summary>
        </member>
        <member name="F:Kavprot.Packets.LinkLayers.Fddi">
            <summary> FDDI </summary>
        </member>
        <member name="F:Kavprot.Packets.LinkLayers.AtmRfc1483">
            <summary> LLC/SNAP encapsulated atm </summary>
        </member>
        <member name="F:Kavprot.Packets.LinkLayers.Raw">
            <summary> raw IP </summary>
        </member>
        <member name="F:Kavprot.Packets.LinkLayers.SlipBSD">
            <summary> BSD Slip.</summary>
        </member>
        <member name="F:Kavprot.Packets.LinkLayers.PppBSD">
            <summary> BSD PPP.</summary>
        </member>
        <member name="F:Kavprot.Packets.LinkLayers.AtmClip">
            <summary> IP over ATM.</summary>
        </member>
        <member name="F:Kavprot.Packets.LinkLayers.PppSerial">
            <summary> PPP over HDLC.</summary>
        </member>
        <member name="F:Kavprot.Packets.LinkLayers.CiscoHDLC">
            <summary> Cisco HDLC.</summary>
        </member>
        <member name="F:Kavprot.Packets.LinkLayers.Ieee80211">
            <summary> IEEE 802.11 wireless.</summary>
        </member>
        <member name="F:Kavprot.Packets.LinkLayers.Loop">
            <summary> OpenBSD loopback.</summary>
        </member>
        <member name="F:Kavprot.Packets.LinkLayers.LinuxSLL">
            <summary> Linux cooked sockets.</summary>
        </member>
        <member name="F:Kavprot.Packets.LinkLayers.Ieee80211_Radio">
            <summary>
            Header for 802.11 plus a number of bits of link-layer information
            including radio information, used by some recent BSD drivers as
            well as the madwifi Atheros driver for Linux.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.LinkLayers.PerPacketInformation">
            <summary>
            Per Packet Information encapsulated packets.
            DLT_ requested by Gianluca Varenni &lt;gianluca.varenni@cacetech.com&gt;.
            See http://www.cacetech.com/documents/PPI%20Header%20format%201.0.7.pdf
            </summary>
        </member>
        <member name="T:Kavprot.Packets.ARPFields">
             <summary> IP protocol field encoding information.
            
             </summary>
             FIXME: These fields are partially broken because they assume the offset for
             several fields and the offset is actually based on the accumulated offset
             into the structure determined by the fields that indicate sizes
        </member>
        <member name="F:Kavprot.Packets.ARPFields.EthernetProtocolType">
            <summary> Type code for ethernet addresses.</summary>
        </member>
        <member name="F:Kavprot.Packets.ARPFields.IPv4ProtocolType">
            <summary> Type code for MAC addresses.</summary>
        </member>
        <member name="F:Kavprot.Packets.ARPFields.OperationLength">
            <summary> Operation type length in bytes.</summary>
        </member>
        <member name="F:Kavprot.Packets.ARPFields.AddressTypeLength">
            <summary>
            The length of the address type fields in bytes,
            eg. the length of hardware type or protocol type
            </summary>
        </member>
        <member name="F:Kavprot.Packets.ARPFields.AddressLengthLength">
            <summary>
            The length of the address length fields in bytes.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.ARPFields.HardwareAddressTypePosition">
            <summary> Position of the hardware address type.</summary>
        </member>
        <member name="F:Kavprot.Packets.ARPFields.ProtocolAddressTypePosition">
            <summary> Position of the protocol address type.</summary>
        </member>
        <member name="F:Kavprot.Packets.ARPFields.HardwareAddressLengthPosition">
            <summary> Position of the hardware address length.</summary>
        </member>
        <member name="F:Kavprot.Packets.ARPFields.ProtocolAddressLengthPosition">
            <summary> Position of the protocol address length.</summary>
        </member>
        <member name="F:Kavprot.Packets.ARPFields.OperationPosition">
            <summary> Position of the operation type.</summary>
        </member>
        <member name="F:Kavprot.Packets.ARPFields.SenderHardwareAddressPosition">
            <summary> Position of the sender hardware address.</summary>
        </member>
        <member name="F:Kavprot.Packets.ARPFields.SenderProtocolAddressPosition">
            <summary> Position of the sender protocol address.</summary>
        </member>
        <member name="F:Kavprot.Packets.ARPFields.TargetHardwareAddressPosition">
            <summary> Position of the target hardware address.</summary>
        </member>
        <member name="F:Kavprot.Packets.ARPFields.TargetProtocolAddressPosition">
            <summary> Position of the target protocol address.</summary>
        </member>
        <member name="F:Kavprot.Packets.ARPFields.HeaderLength">
            <summary> Total length in bytes of an ARP header.</summary>
        </member>
        <member name="T:Kavprot.Packets.Tcp.Echo">
            <summary>
            An Echo Option
             throws an exception because Echo Options
             are obsolete as per their spec
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Tcp.Echo.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Creates an Echo Option
            </summary>
            <param name="bytes">
            A <see cref="!:System.Byte[]"/>
            </param>
            <param name="offset">
            A <see cref="T:System.Int32"/>
            </param>
            <param name="length">
            A <see cref="T:System.Int32"/>
            </param>
        </member>
        <member name="T:Kavprot.Packets.Tcp.ChecksumAlgorighmType">
            <summary>
            Specifies the different types of algorithms that the
             Alternative Checksum option are allowed to use
            </summary>
            <remarks>
            References:
             http://datatracker.ietf.org/doc/rfc1146/
            </remarks>
        </member>
        <member name="F:Kavprot.Packets.Tcp.ChecksumAlgorighmType.TCPChecksum">
            <summary>Standard TCP Checksum Algorithm</summary>
        </member>
        <member name="F:Kavprot.Packets.Tcp.ChecksumAlgorighmType.EightBitFletchersAlgorithm">
            <summary>8-bit Fletchers Algorighm</summary>
        </member>
        <member name="F:Kavprot.Packets.Tcp.ChecksumAlgorighmType.SixteenBitFletchersAlgorithm">
            <summary>16-bit Fletchers Algorithm</summary>
        </member>
        <member name="F:Kavprot.Packets.Tcp.ChecksumAlgorighmType.RedundantChecksumAvoidance">
            <summary>Redundant Checksum Avoidance</summary>
        </member>
        <member name="T:MiscUtil.Conversion.BigEndianBitConverter">
            <summary>
            Implementation of EndianBitConverter which converts to/from big-endian
            byte arrays.
            </summary>
        </member>
        <member name="M:MiscUtil.Conversion.BigEndianBitConverter.IsLittleEndian">
            <summary>
            Indicates the byte order ("endianess") in which data is converted using this class.
            </summary>
            <remarks>
            Different computer architectures store data using different byte orders. "Big-endian"
            means the most significant byte is on the left end of a word. "Little-endian" means the
            most significant byte is on the right end of a word.
            </remarks>
            <returns>true if this converter is little-endian, false otherwise.</returns>
        </member>
        <member name="M:MiscUtil.Conversion.BigEndianBitConverter.CopyBytesImpl(System.Int64,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Copies the specified number of bytes from value to buffer, starting at index.
            </summary>
            <param name="value">The value to copy</param>
            <param name="bytes">The number of bytes to copy</param>
            <param name="buffer">The buffer to copy the bytes into</param>
            <param name="index">The index to start at</param>
        </member>
        <member name="M:MiscUtil.Conversion.BigEndianBitConverter.FromBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Returns a value built from the specified number of bytes from the given buffer,
            starting at index.
            </summary>
            <param name="buffer">The data in byte array format</param>
            <param name="startIndex">The first index to use</param>
            <param name="bytesToConvert">The number of bytes to use</param>
            <returns>The value built from the given bytes</returns>
        </member>
        <member name="P:MiscUtil.Conversion.BigEndianBitConverter.Endianness">
            <summary>
            Indicates the byte order ("endianess") in which data is converted using this class.
            </summary>
        </member>
        <member name="T:Kavprot.Packets.LLDP.PortDescription">
            <summary>
            A Port Description TLV
            </summary>
        </member>
        <member name="M:Kavprot.Packets.LLDP.PortDescription.#ctor(System.Byte[],System.Int32)">
            <summary>
            Creates a Port Description TLV
            </summary>
            <param name="bytes">
            </param>
            <param name="offset">
            The Port Description TLV's offset from the
            origin of the LLDP
            </param>
        </member>
        <member name="M:Kavprot.Packets.LLDP.PortDescription.#ctor(System.String)">
            <summary>
            Creates a Port Description TLV and sets it value
            </summary>
            <param name="description">
            A textual description of the port
            </param>
        </member>
        <member name="P:Kavprot.Packets.LLDP.PortDescription.Description">
            <value>
            A textual Description of the port
            </value>
        </member>
        <member name="T:Kavprot.Packets.LLDP.ChassisSubTypes">
            <summary>
            The Chassis ID TLV subtypes
            </summary>
        </member>
        <member name="F:Kavprot.Packets.LLDP.ChassisSubTypes.ChassisComponent">
            <summary>A Chassis Component identifier</summary>
            <remarks>See IETF RFC 2737</remarks>
        </member>
        <member name="F:Kavprot.Packets.LLDP.ChassisSubTypes.InterfaceAlias">
            <summary>An Interface Alias identifier</summary>
            <remarks>See IETF RFC 2863</remarks>
        </member>
        <member name="F:Kavprot.Packets.LLDP.ChassisSubTypes.PortComponent">
            <summary>A Port Component identifier</summary>
            <remarks>See IETF RFC 2737</remarks>
        </member>
        <member name="F:Kavprot.Packets.LLDP.ChassisSubTypes.MACAddress">
            <summary>A MAC (Media Access Control) Address identifier</summary>
            <remarks>See IEEE Std 802</remarks>
        </member>
        <member name="F:Kavprot.Packets.LLDP.ChassisSubTypes.NetworkAddress">
            <summary>A Network Address (IP Address) Identifier</summary>
            <remarks>See IEEE Std 802</remarks>
        </member>
        <member name="F:Kavprot.Packets.LLDP.ChassisSubTypes.InterfaceName">
            <summary>An Interface Name identifier</summary>
            <remarks>See IEEE Std 802</remarks>
        </member>
        <member name="F:Kavprot.Packets.LLDP.ChassisSubTypes.LocallyAssigned">
            <summary>A Locally Assigned identifier</summary>
        </member>
        <member name="T:System.Linq.Enumerable">
            <summary>
            Provides a set of static (Shared in Visual Basic) methods for 
            querying objects that implement <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.AsEnumerable``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the input typed as <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Empty``1">
            <summary>
            Returns an empty <see cref="T:System.Collections.Generic.IEnumerable`1"/> that has the 
            specified type argument.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Cast``1(System.Collections.IEnumerable)">
            <summary>
            Converts the elements of an <see cref="T:System.Collections.IEnumerable"/> to the 
            specified type.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.OfType``1(System.Collections.IEnumerable)">
            <summary>
            Filters the elements of an <see cref="T:System.Collections.IEnumerable"/> based on a specified type.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Range(System.Int32,System.Int32)">
            <summary>
            Generates a sequence of integral numbers within a specified range.
            </summary>
            <param name="start">The value of the first integer in the sequence.</param>
            <param name="count">The number of sequential integers to generate.</param>
        </member>
        <member name="M:System.Linq.Enumerable.Repeat``1(``0,System.Int32)">
            <summary>
            Generates a sequence that contains one repeated value.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Filters a sequence of values based on a predicate.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})">
            <summary>
            Filters a sequence of values based on a predicate. 
            Each element's index is used in the logic of the predicate function.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Projects each element of a sequence into a new form.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,``1})">
            <summary>
            Projects each element of a sequence into a new form by 
            incorporating the element's index.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            Projects each element of a sequence to an <see cref="T:System.Collections.Generic.IEnumerable`1"/> 
            and flattens the resulting sequences into one sequence.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            Projects each element of a sequence to an <see cref="T:System.Collections.Generic.IEnumerable`1"/>, 
            and flattens the resulting sequences into one sequence. The 
            index of each source element is used in the projected form of 
            that element.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})">
            <summary>
            Projects each element of a sequence to an <see cref="T:System.Collections.Generic.IEnumerable`1"/>, 
            flattens the resulting sequences into one sequence, and invokes 
            a result selector function on each element therein.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})">
            <summary>
            Projects each element of a sequence to an <see cref="T:System.Collections.Generic.IEnumerable`1"/>, 
            flattens the resulting sequences into one sequence, and invokes 
            a result selector function on each element therein. The index of 
            each source element is used in the intermediate projected form 
            of that element.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Returns elements from a sequence as long as a specified condition is true.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})">
            <summary>
            Returns elements from a sequence as long as a specified condition is true.
            The element's index is used in the logic of the predicate function.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.FirstImpl``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0})">
            <summary>
            Base implementation of First operator.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.First``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the first element of a sequence.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.First``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Returns the first element in a sequence that satisfies a specified condition.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the first element of a sequence, or a default value if 
            the sequence contains no elements.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Returns the first element of the sequence that satisfies a 
            condition or a default value if no such element is found.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.LastImpl``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0})">
            <summary>
            Base implementation of Last operator.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Last``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the last element of a sequence.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Last``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Returns the last element of a sequence that satisfies a 
            specified condition.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the last element of a sequence, or a default value if 
            the sequence contains no elements.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Returns the last element of a sequence that satisfies a 
            condition or a default value if no such element is found.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.SingleImpl``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0})">
            <summary>
            Base implementation of Single operator.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Single``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the only element of a sequence, and throws an exception 
            if there is not exactly one element in the sequence.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Single``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Returns the only element of a sequence that satisfies a 
            specified condition, and throws an exception if more than one 
            such element exists.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.SingleOrDefault``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the only element of a sequence, or a default value if 
            the sequence is empty; this method throws an exception if there 
            is more than one element in the sequence.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.SingleOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Returns the only element of a sequence that satisfies a 
            specified condition or a default value if no such element 
            exists; this method throws an exception if more than one element 
            satisfies the condition.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.ElementAt``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Returns the element at a specified index in a sequence.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.ElementAtOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Returns the element at a specified index in a sequence or a 
            default value if the index is out of range.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Reverse``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Inverts the order of the elements in a sequence.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Take``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Returns a specified number of contiguous elements from the start 
            of a sequence.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Skip``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Bypasses a specified number of elements in a sequence and then 
            returns the remaining elements.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.SkipWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Bypasses elements in a sequence as long as a specified condition 
            is true and then returns the remaining elements.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.SkipWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})">
            <summary>
            Bypasses elements in a sequence as long as a specified condition 
            is true and then returns the remaining elements. The element's 
            index is used in the logic of the predicate function.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Count``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the number of elements in a sequence.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Count``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Returns a number that represents how many elements in the 
            specified sequence satisfy a condition.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.LongCount``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns an <see cref="T:System.Int64"/> that represents the total number 
            of elements in a sequence.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.LongCount``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Returns an <see cref="T:System.Int64"/> that represents how many elements 
            in a sequence satisfy a condition.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Concat``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Concatenates two sequences.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.ToList``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a <see cref="T:System.Collections.Generic.List`1"/> from an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.ToArray``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates an array from an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Distinct``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns distinct elements from a sequence by using the default 
            equality comparer to compare values.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Distinct``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Returns distinct elements from a sequence by using a specified 
            <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare values.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.ToLookup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Creates a <see cref="T:System.Linq.Lookup`2"/> from an 
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> according to a specified key 
            selector function.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.ToLookup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates a <see cref="T:System.Linq.Lookup`2"/> from an 
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> according to a specified key 
            selector function and a key comparer.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.ToLookup``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})">
            <summary>
            Creates a <see cref="T:System.Linq.Lookup`2"/> from an 
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> according to specified key 
            and element selector functions.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.ToLookup``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates a <see cref="T:System.Linq.Lookup`2"/> from an 
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> according to a specified key 
            selector function, a comparer and an element selector function.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Groups the elements of a sequence according to a specified key 
            selector function.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Groups the elements of a sequence according to a specified key 
            selector function and compares the keys by using a specified 
            comparer.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})">
            <summary>
            Groups the elements of a sequence according to a specified key 
            selector function and projects the elements for each group by 
            using a specified function.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Groups the elements of a sequence according to a specified key 
            selector function and creates a result value from each group and 
            its key.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2})">
            <summary>
            Groups the elements of a sequence according to a key selector 
            function. The keys are compared by using a comparer and each 
            group's elements are projected by using a specified function.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Groups the elements of a sequence according to a specified key 
            selector function and creates a result value from each group and 
            its key. The elements of each group are projected by using a 
            specified function.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3})">
            <summary>
            Groups the elements of a sequence according to a specified key 
            selector function and creates a result value from each group and 
            its key. The keys are compared by using a specified comparer.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Groups the elements of a sequence according to a specified key 
            selector function and creates a result value from each group and 
            its key. Key values are compared by using a specified comparer, 
            and the elements of each group are projected by using a 
            specified function.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Aggregate``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``0})">
            <summary>
            Applies an accumulator function over a sequence.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Aggregate``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1})">
            <summary>
            Applies an accumulator function over a sequence. The specified 
            seed value is used as the initial accumulator value.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Aggregate``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})">
            <summary>
            Applies an accumulator function over a sequence. The specified 
            seed value is used as the initial accumulator value, and the 
            specified function is used to select the result value.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Union``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Produces the set union of two sequences by using the default 
            equality comparer.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Union``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Produces the set union of two sequences by using a specified 
            <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.DefaultIfEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the elements of the specified sequence or the type 
            parameter's default value in a singleton collection if the 
            sequence is empty.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.DefaultIfEmpty``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Returns the elements of the specified sequence or the specified 
            value in a singleton collection if the sequence is empty.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.All``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Determines whether all elements of a sequence satisfy a condition.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines whether a sequence contains any elements.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Determines whether any element of a sequence satisfies a 
            condition.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Determines whether a sequence contains a specified element by 
            using the default equality comparer.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Determines whether a sequence contains a specified element by 
            using a specified <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines whether two sequences are equal by comparing the 
            elements by using the default equality comparer for their type.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Determines whether two sequences are equal by comparing their 
            elements by using a specified <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.MinMaxImpl``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,System.Boolean})">
            <summary>
            Base implementation for Min/Max operator.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.MinMaxImpl``1(System.Collections.Generic.IEnumerable{System.Nullable{``0}},System.Nullable{``0},System.Func{System.Nullable{``0},System.Nullable{``0},System.Boolean})">
            <summary>
            Base implementation for Min/Max operator for nullable types.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the minimum value in a generic sequence.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Min``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Invokes a transform function on each element of a generic 
            sequence and returns the minimum resulting value.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the maximum value in a generic sequence.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Max``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Invokes a transform function on each element of a generic 
            sequence and returns the maximum resulting value.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Renumerable``1(System.Collections.Generic.IEnumerator{``0})">
            <summary>
            Makes an enumerator seen as enumerable once more.
            </summary>
            <remarks>
            The supplied enumerator must have been started. The first element
            returned is the element the enumerator was on when passed in.
            DO NOT use this method if the caller must be a generator. It is
            mostly safe among aggregate operations.
            </remarks>
        </member>
        <member name="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Sorts the elements of a sequence in ascending order according to a key.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
            Sorts the elements of a sequence in ascending order by using a 
            specified comparer.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Sorts the elements of a sequence in descending order according to a key.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
             Sorts the elements of a sequence in descending order by using a 
            specified comparer. 
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Performs a subsequent ordering of the elements in a sequence in 
            ascending order according to a key.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
            Performs a subsequent ordering of the elements in a sequence in 
            ascending order by using a specified comparer.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Performs a subsequent ordering of the elements in a sequence in 
            descending order, according to a key.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
            Performs a subsequent ordering of the elements in a sequence in 
            descending order by using a specified comparer.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.IntersectExceptImpl``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0},System.Boolean)">
            <summary>
            Base implementation for Intersect and Except operators.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Intersect``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Produces the set intersection of two sequences by using the 
            default equality comparer to compare values.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Intersect``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Produces the set intersection of two sequences by using the 
            specified <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare values.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Produces the set difference of two sequences by using the 
            default equality comparer to compare values.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Produces the set difference of two sequences by using the 
            specified <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> to compare values.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.ToDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Creates a <see cref="T:System.Collections.Generic.Dictionary`2"/> from an 
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> according to a specified key 
            selector function.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.ToDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates a <see cref="T:System.Collections.Generic.Dictionary`2"/> from an 
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> according to a specified key 
            selector function and key comparer.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.ToDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})">
            <summary>
            Creates a <see cref="T:System.Collections.Generic.Dictionary`2"/> from an 
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> according to specified key 
            selector and element selector functions.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.ToDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Creates a <see cref="T:System.Collections.Generic.Dictionary`2"/> from an 
            <see cref="T:System.Collections.Generic.IEnumerable`1"/> according to a specified key 
            selector function, a comparer, and an element selector function.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3})">
            <summary>
            Correlates the elements of two sequences based on matching keys. 
            The default equality comparer is used to compare keys.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3},System.Collections.Generic.IEqualityComparer{``2})">
            <summary>
            Correlates the elements of two sequences based on matching keys. 
            The default equality comparer is used to compare keys. A 
            specified <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> is used to compare keys.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3})">
            <summary>
            Correlates the elements of two sequences based on equality of 
            keys and groups the results. The default equality comparer is 
            used to compare keys.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3},System.Collections.Generic.IEqualityComparer{``2})">
            <summary>
            Correlates the elements of two sequences based on equality of 
            keys and groups the results. The default equality comparer is 
            used to compare keys. A specified <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> 
            is used to compare keys.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Computes the sum of a sequence of nullable <see cref="T:System.Int32"/> values.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})">
            <summary>
            Computes the sum of a sequence of nullable <see cref="T:System.Int32"/> 
            values that are obtained by invoking a transform function on 
            each element of the input sequence.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Computes the average of a sequence of nullable <see cref="T:System.Int32"/> values.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})">
            <summary>
            Computes the average of a sequence of nullable <see cref="T:System.Int32"/> values 
            that are obtained by invoking a transform function on each 
            element of the input sequence.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})">
            <summary>
            Computes the sum of a sequence of <see cref="T:System.Int32"/> values.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})">
            <summary>
            Computes the sum of a sequence of <see cref="T:System.Int32"/> 
            values that are obtained by invoking a transform function on 
            each element of the input sequence.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})">
            <summary>
            Computes the average of a sequence of <see cref="T:System.Int32"/> values.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})">
            <summary>
            Computes the average of a sequence of <see cref="T:System.Int32"/> values 
            that are obtained by invoking a transform function on each 
            element of the input sequence.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})">
            <summary>
            Returns the minimum value in a sequence of nullable 
            <see cref="T:System.Int32"/> values.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})">
            <summary>
            Invokes a transform function on each element of a sequence and 
            returns the minimum nullable <see cref="T:System.Int32"/> value.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})">
            <summary>
            Returns the maximum value in a sequence of nullable 
            <see cref="T:System.Int32"/> values.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})">
            <summary>
            Invokes a transform function on each element of a sequence and 
            returns the maximum nullable <see cref="T:System.Int32"/> value.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            Computes the sum of a sequence of nullable <see cref="T:System.Int64"/> values.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})">
            <summary>
            Computes the sum of a sequence of nullable <see cref="T:System.Int64"/> 
            values that are obtained by invoking a transform function on 
            each element of the input sequence.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Int64})">
            <summary>
            Computes the average of a sequence of nullable <see cref="T:System.Int64"/> values.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})">
            <summary>
            Computes the average of a sequence of nullable <see cref="T:System.Int64"/> values 
            that are obtained by invoking a transform function on each 
            element of the input sequence.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})">
            <summary>
            Computes the sum of a sequence of <see cref="T:System.Int64"/> values.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})">
            <summary>
            Computes the sum of a sequence of <see cref="T:System.Int64"/> 
            values that are obtained by invoking a transform function on 
            each element of the input sequence.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})">
            <summary>
            Computes the average of a sequence of <see cref="T:System.Int64"/> values.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})">
            <summary>
            Computes the average of a sequence of <see cref="T:System.Int64"/> values 
            that are obtained by invoking a transform function on each 
            element of the input sequence.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})">
            <summary>
            Returns the minimum value in a sequence of nullable 
            <see cref="T:System.Int64"/> values.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})">
            <summary>
            Invokes a transform function on each element of a sequence and 
            returns the minimum nullable <see cref="T:System.Int64"/> value.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})">
            <summary>
            Returns the maximum value in a sequence of nullable 
            <see cref="T:System.Int64"/> values.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})">
            <summary>
            Invokes a transform function on each element of a sequence and 
            returns the maximum nullable <see cref="T:System.Int64"/> value.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Computes the sum of a sequence of nullable <see cref="T:System.Single"/> values.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})">
            <summary>
            Computes the sum of a sequence of nullable <see cref="T:System.Single"/> 
            values that are obtained by invoking a transform function on 
            each element of the input sequence.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Computes the average of a sequence of nullable <see cref="T:System.Single"/> values.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})">
            <summary>
            Computes the average of a sequence of nullable <see cref="T:System.Single"/> values 
            that are obtained by invoking a transform function on each 
            element of the input sequence.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})">
            <summary>
            Computes the sum of a sequence of <see cref="T:System.Single"/> values.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})">
            <summary>
            Computes the sum of a sequence of <see cref="T:System.Single"/> 
            values that are obtained by invoking a transform function on 
            each element of the input sequence.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})">
            <summary>
            Computes the average of a sequence of <see cref="T:System.Single"/> values.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})">
            <summary>
            Computes the average of a sequence of <see cref="T:System.Single"/> values 
            that are obtained by invoking a transform function on each 
            element of the input sequence.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})">
            <summary>
            Returns the minimum value in a sequence of nullable 
            <see cref="T:System.Single"/> values.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})">
            <summary>
            Invokes a transform function on each element of a sequence and 
            returns the minimum nullable <see cref="T:System.Single"/> value.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})">
            <summary>
            Returns the maximum value in a sequence of nullable 
            <see cref="T:System.Single"/> values.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})">
            <summary>
            Invokes a transform function on each element of a sequence and 
            returns the maximum nullable <see cref="T:System.Single"/> value.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Computes the sum of a sequence of nullable <see cref="T:System.Double"/> values.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})">
            <summary>
            Computes the sum of a sequence of nullable <see cref="T:System.Double"/> 
            values that are obtained by invoking a transform function on 
            each element of the input sequence.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Computes the average of a sequence of nullable <see cref="T:System.Double"/> values.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})">
            <summary>
            Computes the average of a sequence of nullable <see cref="T:System.Double"/> values 
            that are obtained by invoking a transform function on each 
            element of the input sequence.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})">
            <summary>
            Computes the sum of a sequence of <see cref="T:System.Double"/> values.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})">
            <summary>
            Computes the sum of a sequence of <see cref="T:System.Double"/> 
            values that are obtained by invoking a transform function on 
            each element of the input sequence.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})">
            <summary>
            Computes the average of a sequence of <see cref="T:System.Double"/> values.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})">
            <summary>
            Computes the average of a sequence of <see cref="T:System.Double"/> values 
            that are obtained by invoking a transform function on each 
            element of the input sequence.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})">
            <summary>
            Returns the minimum value in a sequence of nullable 
            <see cref="T:System.Double"/> values.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})">
            <summary>
            Invokes a transform function on each element of a sequence and 
            returns the minimum nullable <see cref="T:System.Double"/> value.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})">
            <summary>
            Returns the maximum value in a sequence of nullable 
            <see cref="T:System.Double"/> values.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})">
            <summary>
            Invokes a transform function on each element of a sequence and 
            returns the maximum nullable <see cref="T:System.Double"/> value.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Decimal})">
            <summary>
            Computes the sum of a sequence of nullable <see cref="T:System.Decimal"/> values.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})">
            <summary>
            Computes the sum of a sequence of nullable <see cref="T:System.Decimal"/> 
            values that are obtained by invoking a transform function on 
            each element of the input sequence.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Decimal})">
            <summary>
            Computes the average of a sequence of nullable <see cref="T:System.Decimal"/> values.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})">
            <summary>
            Computes the average of a sequence of nullable <see cref="T:System.Decimal"/> values 
            that are obtained by invoking a transform function on each 
            element of the input sequence.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})">
            <summary>
            Computes the sum of a sequence of <see cref="T:System.Decimal"/> values.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})">
            <summary>
            Computes the sum of a sequence of <see cref="T:System.Decimal"/> 
            values that are obtained by invoking a transform function on 
            each element of the input sequence.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})">
            <summary>
            Computes the average of a sequence of <see cref="T:System.Decimal"/> values.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})">
            <summary>
            Computes the average of a sequence of <see cref="T:System.Decimal"/> values 
            that are obtained by invoking a transform function on each 
            element of the input sequence.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})">
            <summary>
            Returns the minimum value in a sequence of nullable 
            <see cref="T:System.Decimal"/> values.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})">
            <summary>
            Invokes a transform function on each element of a sequence and 
            returns the minimum nullable <see cref="T:System.Decimal"/> value.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})">
            <summary>
            Returns the maximum value in a sequence of nullable 
            <see cref="T:System.Decimal"/> values.
            </summary>
        </member>
        <member name="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})">
            <summary>
            Invokes a transform function on each element of a sequence and 
            returns the maximum nullable <see cref="T:System.Decimal"/> value.
            </summary>
        </member>
        <member name="T:System.Linq.IGrouping`2">
            <summary>
            Represents a collection of objects that have a common key.
            </summary>
        </member>
        <member name="P:System.Linq.IGrouping`2.Key">
            <summary>
            Gets the key of the <see cref="T:System.Linq.IGrouping`2"/>.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.ExtensionAttribute">
            <remarks>
            This attribute allows us to define extension methods without 
            requiring .NET Framework 3.5. For more information, see the section,
            <a href="http://msdn.microsoft.com/en-us/magazine/cc163317.aspx#S7">Extension Methods in .NET Framework 2.0 Apps</a>,
            of <a href="http://msdn.microsoft.com/en-us/magazine/cc163317.aspx">Basic Instincts: Extension Methods</a>
            column in <a href="http://msdn.microsoft.com/msdnmag/">MSDN Magazine</a>, 
            issue <a href="http://msdn.microsoft.com/en-us/magazine/cc135410.aspx">Nov 2007</a>.
            </remarks>
        </member>
        <member name="T:System.Linq.ILookup`2">
            <summary>
            Defines an indexer, size property, and Boolean search method for 
            data structures that map keys to <see cref="T:System.Collections.Generic.IEnumerable`1"/> 
            sequences of values.
            </summary>
        </member>
        <member name="T:System.Linq.IOrderedEnumerable`1">
            <summary>
            Represents a sorted sequence.
            </summary>
        </member>
        <member name="M:System.Linq.IOrderedEnumerable`1.CreateOrderedEnumerable``1(System.Func{`0,``0},System.Collections.Generic.IComparer{``0},System.Boolean)">
            <summary>
            Performs a subsequent ordering on the elements of an 
            <see cref="T:System.Linq.IOrderedEnumerable`1"/> according to a key.
            </summary>
        </member>
        <member name="T:System.Linq.Lookup`2">
            <summary>
            Represents a collection of keys each mapped to one or more values.
            </summary>
        </member>
        <member name="M:System.Linq.Lookup`2.Contains(`0)">
            <summary>
            Determines whether a specified key is in the <see cref="T:System.Linq.Lookup`2"/>.
            </summary>
        </member>
        <member name="M:System.Linq.Lookup`2.ApplyResultSelector``1(System.Func{`0,System.Collections.Generic.IEnumerable{`1},``0})">
            <summary>
            Applies a transform function to each key and its associated 
            values and returns the results.
            </summary>
        </member>
        <member name="M:System.Linq.Lookup`2.GetEnumerator">
            <summary>
            Returns a generic enumerator that iterates through the <see cref="T:System.Linq.Lookup`2"/>.
            </summary>
        </member>
        <member name="P:System.Linq.Lookup`2.Count">
            <summary>
            Gets the number of key/value collection pairs in the <see cref="T:System.Linq.Lookup`2"/>.
            </summary>
        </member>
        <member name="P:System.Linq.Lookup`2.Item(`0)">
            <summary>
            Gets the collection of values indexed by the specified key.
            </summary>
        </member>
        <member name="M:LinqBridge.OrderedEnumerable`2.TagPosition(`0,System.Int32)">
            <remarks>
            See <a href="http://code.google.com/p/linqbridge/issues/detail?id=11">issue #11</a>
            for why this method is needed and cannot be expressed as a 
            lambda at the call site.
            </remarks>
        </member>
        <member name="M:LinqBridge.OrderedEnumerable`2.GetFirst(LinqBridge.Tuple{`0,System.Int32})">
            <remarks>
            See <a href="http://code.google.com/p/linqbridge/issues/detail?id=11">issue #11</a>
            for why this method is needed and cannot be expressed as a 
            lambda at the call site.
            </remarks>
        </member>
        <member name="T:Kavprot.Packets.ARPPacket">
            <summary>
            An ARP protocol packet.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.ARPPacket.#ctor(Kavprot.Packets.ARPOperation,System.Net.NetworkInformation.PhysicalAddress,System.Net.IPAddress,System.Net.NetworkInformation.PhysicalAddress,System.Net.IPAddress)">
            <summary>
            Create an ARPPacket from values
            </summary>
            <param name="Operation">
            A <see cref="T:Kavprot.Packets.ARPOperation"/>
            </param>
            <param name="TargetHardwareAddress">
            A <see cref="T:System.Net.NetworkInformation.PhysicalAddress"/>
            </param>
            <param name="TargetProtocolAddress">
            A <see cref="T:System.Net.IPAddress"/>
            </param>
            <param name="SenderHardwareAddress">
            A <see cref="T:System.Net.NetworkInformation.PhysicalAddress"/>
            </param>
            <param name="SenderProtocolAddress">
            A <see cref="T:System.Net.IPAddress"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.ARPPacket.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Constructor
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.ARPPacket.ToString(Kavprot.Packets.StringOutputType)">
            <summary cref="M:Kavprot.Packets.Packet.ToString(Kavprot.Packets.StringOutputType)"/>
        </member>
        <member name="M:Kavprot.Packets.ARPPacket.GetEncapsulated(Kavprot.Packets.Packet)">
            <summary>
            Returns the encapsulated ARPPacket of the Packet p or null if
            there is no encapsulated packet
            </summary>
            <param name="p">
            A <see cref="T:Kavprot.Packets.Packet"/>
            </param>
            <returns>
            A <see cref="T:Kavprot.Packets.ARPPacket"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.ARPPacket.HardwareAddressType">
            <value>
            Also known as HardwareType
            </value>
        </member>
        <member name="P:Kavprot.Packets.ARPPacket.ProtocolAddressType">
            <value>
            Also known as ProtocolType
            </value>
        </member>
        <member name="P:Kavprot.Packets.ARPPacket.HardwareAddressLength">
            <value>
            Hardware address length field
            </value>
        </member>
        <member name="P:Kavprot.Packets.ARPPacket.ProtocolAddressLength">
            <value>
            Protocol address length field
            </value>
        </member>
        <member name="P:Kavprot.Packets.ARPPacket.Operation">
            <summary> Fetch the operation code.
            Usually one of ARPFields.{ARP_OP_REQ_CODE, ARP_OP_REP_CODE}.
            </summary>
            <summary> Sets the operation code.
            Usually one of ARPFields.{ARP_OP_REQ_CODE, ARP_OP_REP_CODE}.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.ARPPacket.SenderProtocolAddress">
            <value>
            Upper layer protocol address of the sender, arp is used for IPv4, IPv6 uses NDP
            </value>
        </member>
        <member name="P:Kavprot.Packets.ARPPacket.TargetProtocolAddress">
            <value>
            Upper layer protocol address of the target, arp is used for IPv4, IPv6 uses NDP
            </value>
        </member>
        <member name="P:Kavprot.Packets.ARPPacket.SenderHardwareAddress">
            <value>
            Sender hardware address, usually an ethernet mac address
            </value>
        </member>
        <member name="P:Kavprot.Packets.ARPPacket.TargetHardwareAddress">
            <value>
            Target hardware address, usually an ethernet mac address
            </value>
        </member>
        <member name="P:Kavprot.Packets.ARPPacket.Color">
            <summary> Fetch ascii escape sequence of the color associated with this packet type.</summary>
        </member>
        <member name="T:Kavprot.Packets.RawPacket">
            <summary>
            Raw packet as loaded from a pcap device or file
            </summary>
        </member>
        <member name="M:Kavprot.Packets.RawPacket.#ctor(Kavprot.Packets.LinkLayers,Kavprot.Packets.PosixTimeval,System.Byte[])">
            <summary>
            Constructor
            </summary>
            <param name="LinkLayerType">
            A <see cref="T:Kavprot.Packets.LinkLayers"/>
            </param>
            <param name="Timeval">
            A <see cref="T:Kavprot.Packets.PosixTimeval"/>
            </param>
            <param name="Data">
            A <see cref="T:System.Byte"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.RawPacket.ToString">
            <summary>
            ToString() override
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.RawPacket.LinkLayerType">
            <value>
            Link layer from which this packet was captured
            </value>
        </member>
        <member name="P:Kavprot.Packets.RawPacket.Timeval">
            <value>
            The unix timeval when the packet was created
            </value>
        </member>
        <member name="P:Kavprot.Packets.RawPacket.Data">
            <summary> Fetch data portion of the packet.</summary>
        </member>
        <member name="T:Kavprot.Packets.PosixTimeval">
            <summary> POSIX.4 timeval</summary>
        </member>
        <member name="M:Kavprot.Packets.PosixTimeval.op_LessThan(Kavprot.Packets.PosixTimeval,Kavprot.Packets.PosixTimeval)">
            <summary>
            Operator &lt; overload
            </summary>
            <param name="a">
            A <see cref="T:Kavprot.Packets.PosixTimeval"/>
            </param>
            <param name="b">
            A <see cref="T:Kavprot.Packets.PosixTimeval"/>
            </param>
            <returns>
            A <see cref="T:System.Boolean"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.PosixTimeval.op_GreaterThan(Kavprot.Packets.PosixTimeval,Kavprot.Packets.PosixTimeval)">
            <summary>
            Operator &gt; overload
            </summary>
            <param name="a">
            A <see cref="T:Kavprot.Packets.PosixTimeval"/>
            </param>
            <param name="b">
            A <see cref="T:Kavprot.Packets.PosixTimeval"/>
            </param>
            <returns>
            A <see cref="T:System.Boolean"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.PosixTimeval.op_LessThanOrEqual(Kavprot.Packets.PosixTimeval,Kavprot.Packets.PosixTimeval)">
            <summary>
            Operator &lt;=
            </summary>
            <param name="a">
            A <see cref="T:Kavprot.Packets.PosixTimeval"/>
            </param>
            <param name="b">
            A <see cref="T:Kavprot.Packets.PosixTimeval"/>
            </param>
            <returns>
            A <see cref="T:System.Boolean"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.PosixTimeval.op_GreaterThanOrEqual(Kavprot.Packets.PosixTimeval,Kavprot.Packets.PosixTimeval)">
            <summary>
            Operator &gt;=
            </summary>
            <param name="a">
            A <see cref="T:Kavprot.Packets.PosixTimeval"/>
            </param>
            <param name="b">
            A <see cref="T:Kavprot.Packets.PosixTimeval"/>
            </param>
            <returns>
            A <see cref="T:System.Boolean"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.PosixTimeval.op_Equality(Kavprot.Packets.PosixTimeval,Kavprot.Packets.PosixTimeval)">
            <summary>
            Operator ==
            </summary>
            <param name="a">
            A <see cref="T:Kavprot.Packets.PosixTimeval"/>
            </param>
            <param name="b">
            A <see cref="T:Kavprot.Packets.PosixTimeval"/>
            </param>
            <returns>
            A <see cref="T:System.Boolean"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.PosixTimeval.op_Inequality(Kavprot.Packets.PosixTimeval,Kavprot.Packets.PosixTimeval)">
            <summary>
            Operator !=
            </summary>
            <param name="a">
            A <see cref="T:Kavprot.Packets.PosixTimeval"/>
            </param>
            <param name="b">
            A <see cref="T:Kavprot.Packets.PosixTimeval"/>
            </param>
            <returns>
            A <see cref="T:System.Boolean"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.PosixTimeval.Equals(System.Object)">
            <summary>
            Equals override
            </summary>
            <param name="obj">
            A <see cref="T:System.Object"/>
            </param>
            <returns>
            A <see cref="T:System.Boolean"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.PosixTimeval.GetHashCode">
            <summary>
            GetHashCode override
            </summary>
            <returns>
            A <see cref="T:System.Int32"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.PosixTimeval.#ctor(System.UInt64,System.UInt64)">
            <summary>
            Constructor with Seconds and MicroSeconds fields
            </summary>
            <param name="Seconds">
            A <see cref="T:System.UInt64"/>
            </param>
            <param name="MicroSeconds">
            A <see cref="T:System.UInt64"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.PosixTimeval.#ctor">
            <summary>
            Construct a PosixTimeval using the current UTC time
            </summary>
        </member>
        <member name="M:Kavprot.Packets.PosixTimeval.ToString">
            <summary>
            Convert the timeval to a string like 'SECONDS.MICROSECONDSs'
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.PosixTimeval.Seconds">
            <value>
            Number of seconds in the timeval
            </value>
        </member>
        <member name="P:Kavprot.Packets.PosixTimeval.MicroSeconds">
            <value>
            Number of microseconds in the timeval
            </value>
        </member>
        <member name="P:Kavprot.Packets.PosixTimeval.Date">
            <summary> The timeval as a DateTime in Utc </summary>
        </member>
        <member name="T:Kavprot.Packets.IPProtocol">
            <summary>
            String representation of an IP protocol value
            </summary>
        </member>
        <member name="M:Kavprot.Packets.IPProtocol.getDescription(System.Int32)">
            <summary> Fetch a protocol description.</summary>
            <param name="code">the code associated with the message.
            </param>
            <returns> a message describing the significance of the IP protocol.
            </returns>
        </member>
        <member name="F:Kavprot.Packets.IPProtocol.messages">
            <summary> 'Human-readable' IP protocol descriptions.</summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.RadioTapType">
            <summary>
             NOTE: Might be out-of-date information since it mentions Ethereal
             NOTE: ethereal does NOT handle the following:
             IEEE80211_RADIOTAP_FHSS:
             IEEE80211_RADIOTAP_LOCK_QUALITY:
             IEEE80211_RADIOTAP_TX_ATTENUATION:
             IEEE80211_RADIOTAP_DB_TX_ATTENUATION:
             </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioTapType.Tsft">
             <summary>
             IEEE80211_RADIOTAP_TSFT              u_int64_t       microseconds
            
                 Value in microseconds of the MAC's 64-bit 802.11 Time
                 Synchronization Function timer when the first bit of the
                 MPDU arrived at the MAC. For received frames, only.
            
             </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioTapType.Flags">
             <summary>
             IEEE80211_RADIOTAP_FLAGS             u_int8_t        bitmap
            
                 Properties of transmitted and received frames. See flags
                 defined below.
             </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioTapType.Rate">
             <summary>
             IEEE80211_RADIOTAP_RATE              u_int8_t        500kb/s
            
                 Tx/Rx data rate
             </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioTapType.Channel">
            <summary>
             IEEE80211_RADIOTAP_CHANNEL           2 x u_int16_t   MHz, bitmap
            
                 Tx/Rx frequency in MHz, followed by flags (see below).
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioTapType.Fhss">
             <summary>
             IEEE80211_RADIOTAP_FHSS              u_int16_t       see below
            
                 For frequency-hopping radios, the hop set (first byte)
                 and pattern (second byte).
             </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioTapType.DbmAntennaSignal">
             <summary>
             IEEE80211_RADIOTAP_DBM_ANTSIGNAL     int8_t          decibels from
                                                                  one milliwatt (dBm)
            
                 RF signal power at the antenna, decibel difference from
                 one milliwatt.
             </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioTapType.DbmAntennaNoise">
             <summary>
             IEEE80211_RADIOTAP_DBM_ANTNOISE      int8_t          decibels from
                                                                  one milliwatt (dBm)
            
                 RF noise power at the antenna, decibel difference from one
                 milliwatt.
             </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioTapType.LockQuality">
             <summary>
             IEEE80211_RADIOTAP_LOCK_QUALITY     u_int16_t       unitless
            
                 Quality of Barker code lock. Unitless. Monotonically
                 nondecreasing with "better" lock strength. Called "Signal
                 Quality" in datasheets.  (Is there a standard way to measure
                 this?)
             </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioTapType.TxAttenuation">
             <summary>
             IEEE80211_RADIOTAP_TX_ATTENUATION    u_int16_t       unitless
            
                 Transmit power expressed as unitless distance from max
                 power set at factory calibration.  0 is max power.
                 Monotonically nondecreasing with lower power levels.
             </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioTapType.DbTxAttenuation">
             <summary>
             IEEE80211_RADIOTAP_DB_TX_ATTENUATION u_int16_t       decibels (dB)
            
                 Transmit power expressed as decibel distance from max power
                 set at factory calibration.  0 is max power.  Monotonically
                 nondecreasing with lower power levels.
             </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioTapType.DbmTxPower">
             <summary>
             IEEE80211_RADIOTAP_DBM_TX_POWER      int8_t          decibels from
                                                                  one milliwatt (dBm)
            
                 Transmit power expressed as dBm (decibels from a 1 milliwatt
                 reference). This is the absolute power level measured at
                 the antenna port.
             </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioTapType.Antenna">
             <summary>
             IEEE80211_RADIOTAP_ANTENNA           u_int8_t        antenna index
            
                 Unitless indication of the Rx/Tx antenna for this packet.
                 The first antenna is antenna 0.
             </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioTapType.DbAntennaSignal">
             <summary>
             IEEE80211_RADIOTAP_DB_ANTSIGNAL      u_int8_t        decibel (dB)
            
                 RF signal power at the antenna, decibel difference from an
                 arbitrary, fixed reference.
             </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioTapType.DbAntennaNoise">
             <summary>
             IEEE80211_RADIOTAP_DB_ANTNOISE       u_int8_t        decibel (dB)
            
                 RF noise power at the antenna, decibel difference from an
                 arbitrary, fixed reference point.
             </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioTapType.RxFlags">
            <summary>
            IEEE80211_RADIOTAP_RX_FLAGS       u_int16_t         bitmap
            
                Properties of received frames.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioTapType.Extended">
            <summary>
            Indicates that the flags bitmaps have been extended
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.ProbeResponseFrame">
            <summary>
            Probe response frames are sent by Access Points in response to probe requests by stations.
            An access point may respond to a probe request if it hosts a network with parameters compatible with those
            requested by the station.
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.ManagementFrame">
            <summary>
            Format of a CTS or an ACK frame
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.MacFrame">
            <summary>
            Base class of all 802.11 frame types
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.MacFrame.SetAddress(System.Int32,System.Net.NetworkInformation.PhysicalAddress)">
            <summary>
            Writes the address into the specified address position.
            </summary>
            <remarks>The number of valid address positions in a MAC frame is determined by
            the type of frame. There are between 1 and 4 address fields in MAC frames</remarks>
            <param name="addressIndex">Zero based address to look up</param>
            <param name="address"></param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.MacFrame.SetAddressByOffset(System.Int32,System.Net.NetworkInformation.PhysicalAddress)">
            <summary>
            Writes the provided address into the backing <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            starting at the provided offset.
            </summary>
            <param name="offset">
            The position where the address should start to be copied
            </param>
            <param name="address">
            Address.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.MacFrame.GetAddress(System.Int32)">
            <summary>
            Gets the address. There can be up to four addresses in a MacFrame depending on its type.
            </summary>
            <returns>
            The address.
            </returns>
            <param name='addressIndex'>
            Address index.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.MacFrame.GetAddressByOffset(System.Int32)">
            <summary>
            Gets an address by offset.
            </summary>
            <returns>
            The address as the specified index.
            </returns>
            <param name='offset'>
            The offset into the packet buffer at which to start parsing the address.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.MacFrame.UpdateFrameCheckSequence">
            <summary>
            Recalculates and updates the frame check sequence.
            </summary>
            <remarks>After calling this method the FCS will be valud regardless of what the packet contains.</remarks>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.MacFrame.GetAvailablePayloadLength">
            <summary>
            Returns the number of bytes of payload data currently available in
            the buffer.
            </summary>
            <remarks>This method is used to work out how much space there is for the payload in the
            underlying ByteArraySegment. To find out the length of
            actual payload assigned to the packet use PayloadData.Length.</remarks>
            <value>
            The number of bytes of space available after the header for payload data.
            </value>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.MacFrame.ParsePacketWithFcs(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Parses the <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/> into a MacFrame.
            </summary>
            <returns>
            The parsed MacFrame or null if it could not be parsed.
            </returns>
            <param name="bas">
            The bytes of the packet. bas.Offset should point to the first byte in the mac frame.
            </param>
            <remarks>If the provided bytes dont contain the FCS then call <see cref="M:Kavprot.Packets.Ieee80211.MacFrame.ParsePacket(Kavprot.Packets.Utils.ByteArraySegment)"/> instead. The presence of the 
            FCS is usually determined by configuration of the device used to capture the packets.</remarks>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.MacFrame.ParsePacket(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Parses the <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/> into a MacFrame.
            </summary>
            <returns>
            The parsed MacFrame or null if it could not be parsed.
            </returns>
            <param name="bas">
            The bytes of the packet. bas.Offset should point to the first byte in the mac frame.
            </param>
            <remarks>If the provided bytes contain the FCS then call <see cref="M:Kavprot.Packets.Ieee80211.MacFrame.ParsePacketWithFcs(Kavprot.Packets.Utils.ByteArraySegment)"/> instead. The presence of the 
            FCS is usually determined by configuration of the device used to capture the packets.</remarks>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.MacFrame.PerformFcsCheck(System.Byte[],System.Int32,System.Int32,System.UInt32)">
            <summary>
            Calculates the FCS value for the provided bytes and compates it to the FCS value passed to the method.
            </summary>
            <returns>
            true if the FCS for the provided bytes matches the FCS passed in, false if not.
            </returns>
            <param name="data">
            The byte array for which the FCS will be calculated.
            </param>
            <param name="offset">
            The offset into data of the first byte to be covered by the FCS.
            </param>
            <param name="length">
            The number of bytes to calculate the FCS for.
            </param>
            <param name="fcs">
            The FCS to compare to the one calculated for the provided data.
            </param>
            <remarks>This method can be used to check the validity of a packet before attempting to parse it with either 
            <see cref="M:Kavprot.Packets.Ieee80211.MacFrame.ParsePacket(Kavprot.Packets.Utils.ByteArraySegment)"/> or <see cref="M:Kavprot.Packets.Ieee80211.MacFrame.ParsePacketWithFcs(Kavprot.Packets.Utils.ByteArraySegment)"/>. Attempting to parse a corrupted buffer
            using these methods could cause unexpected exceptions.</remarks>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.MacFrame.ToString">
            <summary>
            ToString() override
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.MacFrame.GetAddressString">
            <summary>
            Returns a string with a description of the addresses used in the packet.
            This is used as a compoent of the string returned by ToString().
            </summary>
            <returns>
            The address string.
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.MacFrame.FrameControlBytes">
            <summary>
            Frame control bytes are the first two bytes of the frame
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.MacFrame.FrameControl">
            <summary>
            Frame control field
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.MacFrame.DurationBytes">
            <summary>
            Duration bytes are the third and fourth bytes of the frame
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.MacFrame.Duration">
            <summary>
            Gets or sets the duration value. The value represents the number of microseconds
            the the wireless medium is expected to remain busy.
            </summary>
            <value>
            The duration field value
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.MacFrame.FrameCheckSequence">
            <summary>
            Frame check sequence, the last thing in the 802.11 mac packet
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.MacFrame.FrameSize">
            <summary>
            Length of the frame header.
            
            This does not include the FCS, it represents only the header bytes that would
            would preceed any payload.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.MacFrame.FCSValid">
            <summary>
            FCSs the valid.
            </summary>
            <returns>
            The valid.
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.MacFrame.AppendFcs">
            <summary>
            Gets or sets a value indicating whether this <see cref="T:Kavprot.Packets.Ieee80211.MacFrame"/> should include an FCS at the end
            of the array returned by Bytes.
            </summary>
            <value>
            <c>true</c> if append FCS should be appended; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.MacFrame.BytesHighPerformance">
            <value>
            The option to return a ByteArraySegment means that this method
            is higher performance as the data can start at an offset other than
            the first byte.
            </value>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.ManagementFrame.GetAddressString">
            <summary>
            Returns a string with a description of the addresses used in the packet.
            This is used as a compoent of the string returned by ToString().
            </summary>
            <returns>
            The address string.
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.ManagementFrame.DestinationAddress">
            <summary>
            DestinationAddress
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.ManagementFrame.SourceAddress">
            <summary>
            SourceAddress
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.ManagementFrame.BssId">
            <summary>
            BssID
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.ManagementFrame.SequenceControlBytes">
            <summary>
            Frame control bytes are the first two bytes of the frame
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.ManagementFrame.SequenceControl">
            <summary>
            Sequence control field
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.ProbeResponseFrame.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Constructor
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.ProbeResponseFrame.#ctor(System.Net.NetworkInformation.PhysicalAddress,System.Net.NetworkInformation.PhysicalAddress,System.Net.NetworkInformation.PhysicalAddress,Kavprot.Packets.Ieee80211.InformationElementList)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.ProbeResponseFrame"/> class.
            </summary>
            <param name="SourceAddress">
            Source address.
            </param>
            <param name="DestinationAddress">
            Destination address.
            </param>
            <param name="BssId">
            Bss identifier (Mac address of the access point).
            </param>
            <param name="InformationElements">
            Information elements.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.ProbeResponseFrame.UpdateCalculatedValues">
            <summary>
            Writes the current packet properties to the backing ByteArraySegment.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.ProbeResponseFrame.Timestamp">
            <summary>
            Gets or sets the timestamp. The timestamp is used by a station to ensure that it
            is using the most up to date parameters for the network.
            </summary>
            <value>
            The timestamp.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.ProbeResponseFrame.BeaconInterval">
            <summary>
            Gets or sets the beacon interval. This is the minimum time between beacon frames from the access point.
            </summary>
            <value>
            The beacon interval.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.ProbeResponseFrame.CapabilityInformationBytes">
            <summary>
            Frame control bytes are the first two bytes of the frame
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.ProbeResponseFrame.CapabilityInformation">
            <summary>
            Get or set the capability information field that defines the capabilities of the network.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.ProbeResponseFrame.InformationElements">
            <summary>
            Gets or sets the information elements included in the frame.
            </summary>
            <value>
            The information elements.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.ProbeResponseFrame.FrameSize">
            <summary>
            Length of the frame header.
            
            This does not include the FCS, it represents only the header bytes that would
            would preceed any payload.
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.InformationElement">
            <summary>
            Information element, a variable-length component of management frames
            </summary>
            <exception cref="T:System.ArgumentException">
            Is thrown when an argument passed to a method is invalid.
            </exception>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.InformationElement.ElementIdLength">
            <summary>
            The length in bytes of the Information Element id field.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.InformationElement.ElementLengthLength">
            <summary>
            The length in bytes of the Information Element length field.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.InformationElement.ElementIdPosition">
            <summary>
            The index of the id field in an Information Element.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.InformationElement.ElementLengthPosition">
            <summary>
            The index of the length field in an Information Element.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.InformationElement.ElementValuePosition">
            <summary>
            The index of the first byte of the value field in an Information Element.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.InformationElement.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.InformationElement"/> class.
            </summary>
            <param name="bas">
            The bytes of the information element. The Offset property should point to the first byte of the element, the Id byte
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.InformationElement.#ctor(Kavprot.Packets.Ieee80211.InformationElement.ElementId,System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.InformationElement"/> class.
            </summary>
            <param name="id">
            Identifier.
            </param>
            <param name="value">
            Value.
            </param>
            <exception cref="T:System.ArgumentException">
            Is thrown when an argument passed to a method is invalid.
            </exception>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.InformationElement.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:Kavprot.Packets.Ieee80211.InformationElement"/>.
            </summary>
            <param name="obj">
            The <see cref="T:System.Object"/> to compare with the current <see cref="T:Kavprot.Packets.Ieee80211.InformationElement"/>.
            </param>
            <returns>
            <c>true</c> if the specified <see cref="T:System.Object"/> is equal to the current
            <see cref="T:Kavprot.Packets.Ieee80211.InformationElement"/>; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.InformationElement.GetHashCode">
            <summary>
            Serves as a hash function for a <see cref="T:Kavprot.Packets.Ieee80211.InformationElement"/> object.
            </summary>
            <returns>
            A hash code for this instance that is suitable for use in hashing algorithms and data structures such as
            a hash table.
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.InformationElement.Id">
            <summary>
            Gets or sets the identifier.
            </summary>
            <value>
            The identifier.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.InformationElement.ValueLength">
            <summary>
            Gets the length.
            </summary>
            <value>
            The length.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.InformationElement.ElementLength">
            <summary>
            Gets the length of the element including the Id and Length field
            </summary>
            <value>
            The length of the element.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.InformationElement.Value">
            <summary>
            Gets or sets the value of the element
            </summary>
            <value>
            The value.
            </value>
            <exception cref="T:System.ArgumentException">
            Is thrown when the value is too large. Values are limited to a maximum size 255 bytes due the single
            byte length field.
            </exception>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.InformationElement.Bytes">
            <summary>
            Gets the bytes.
            </summary>
            <value>
            The bytes.
            </value>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.InformationElement.ElementId">
            <summary>
            Types of information elements
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.InformationElement.ElementId.ServiceSetIdentity">
            <summary>
            Assign an identifier to the service set
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.InformationElement.ElementId.SupportedRates">
            <summary>
            Specifies the data rates supported by the network
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.InformationElement.ElementId.FhParamterSet">
            <summary>
            Provides the parameters necessary to join a frequency-hopping 802.11 network
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.InformationElement.ElementId.DsParameterSet">
            <summary>
            Direct-sequence 802.11 networks have one parameter, the channel number of the network
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.InformationElement.ElementId.CfParameterSet">
            <summary>
            Contention-free parameter. Transmitted in Becons by access points that support
            contention-free operation.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.InformationElement.ElementId.TrafficIndicationMap">
            <summary>
            Indicates which stations have buffered traffic waiting to be picked up
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.InformationElement.ElementId.IbssParameterSet">
            <summary>
            Indicates the number of time units (TUs) between ATIM frames in an IBSS.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.InformationElement.ElementId.Country">
            <summary>
            Specifies regulatory constraints stations must adhere to based on the country the network is operating in.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.InformationElement.ElementId.HoppingParametersPattern">
            <summary>
            Specifies the hopping pattern of timeslots used in frequency hopping physical layers.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.InformationElement.ElementId.HoppingPatternTable">
            <summary>
            Specifies the hopping pattern table used in frequency hopping physical layers.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.InformationElement.ElementId.Request">
            <summary>
            Specifies the Ids of the information elements being requested in a <see cref="T:Kavprot.Packets.Ieee80211.ProbeRequestFrame"/>.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.InformationElement.ElementId.ChallengeText">
            <summary>
            Specifies the encrypted challenge text that stations must decrypt as part of the authentication process.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.InformationElement.ElementId.PowerContstraint">
            <summary>
            Specifies the difference between the regulatory maximum transmit power and any local constraint.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.InformationElement.ElementId.PowerCapability">
            <summary>
            Specifies the minimum and maximum transmit power a station is capable of.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.InformationElement.ElementId.TransmitPowerControlRequest">
            <summary>
            Used to request radio link management information. This type of information element never has an associated value.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.InformationElement.ElementId.TransmitPowerControlReport">
            <summary>
            Radio link managment report used by stations to tune their transmission power.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.InformationElement.ElementId.SupportedChannels">
            <summary>
            Specifies local constraints on the channels in use.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.InformationElement.ElementId.ChannelSwitchAnnouncement">
            <summary>
            Announces an impending change of channel for the network.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.InformationElement.ElementId.MeasurementRequest">
            <summary>
            Requests a report on the state of the radio channel.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.InformationElement.ElementId.MeasurementReport">
            <summary>
            A report of on the status of the radio channel.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.InformationElement.ElementId.Quiet">
            <summary>
            Specifies the scheduling of temporary quiet periods on the channel.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.InformationElement.ElementId.IbssDfs">
            <summary>
            Specifies the details the Dynamic Frequency Selection (DFS) algorithm in use in the IBSS.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.InformationElement.ElementId.ErpInformation">
            <summary>
            Indicates whether or not the Extended Rate PHY is in use on the network at that time.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.InformationElement.ElementId.HighThroughputCapabilities">
            <summary>
            Specifies a stations high throughput capabilities.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.InformationElement.ElementId.RobustSecurityNetwork">
            <summary>
            Specifies details of the Robust Security Network encryption in use on the network.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.InformationElement.ElementId.ExtendedSupportedRates">
            <summary>
            Specifies more data rates supported by the network. This is identical to the Supported Rates element but it allows for a longer value.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.InformationElement.ElementId.HighThroughputInformation">
            <summary>
            Specified how high throughput capable stations will be operated in the network.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.InformationElement.ElementId.WifiProtectedAccess">
            <summary>
            Specifies details of the WiFi Protected Access encryption in use on the network.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.InformationElement.ElementId.VendorSpecific">
            <summary>
            Non standard information element implemented by the hardware vendor.
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.BlockAcknowledgmentFrame">
            <summary>
            Format of the 802.11 block acknowledgment frame.
            http://en.wikipedia.org/wiki/Block_acknowledgement
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.BlockAcknowledgmentFrame.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Constructor
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.BlockAcknowledgmentFrame.#ctor(System.Net.NetworkInformation.PhysicalAddress,System.Net.NetworkInformation.PhysicalAddress,System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.BlockAcknowledgmentFrame"/> class.
            </summary>
            <param name="TransmitterAddress">
            Transmitter address.
            </param>
            <param name="ReceiverAddress">
            Receiver address.
            </param>
            <param name="BlockAckBitmap">
            The Block ack bitmap signalling the receive status of the MSDUs.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.BlockAcknowledgmentFrame.UpdateCalculatedValues">
            <summary>
            Writes the current packet properties to the backing ByteArraySegment.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.BlockAcknowledgmentFrame.GetAddressString">
            <summary>
            Returns a string with a description of the addresses used in the packet.
            This is used as a compoent of the string returned by ToString().
            </summary>
            <returns>
            The address string.
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.BlockAcknowledgmentFrame.ReceiverAddress">
            <summary>
            Receiver address
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.BlockAcknowledgmentFrame.TransmitterAddress">
            <summary>
            Transmitter address
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.BlockAcknowledgmentFrame.BlockAckRequestControlBytes">
            <summary>
            Gets or sets the block ack request control bytes.
            </summary>
            <value>
            The block ack request control bytes.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.BlockAcknowledgmentFrame.BlockAcknowledgmentControl">
            <summary>
            Block acknowledgment control field
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.BlockAcknowledgmentFrame.BlockAckStartingSequenceControl">
            <summary>
            Gets or sets the block ack starting sequence control.
            </summary>
            <value>
            The block ack starting sequence control.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.BlockAcknowledgmentFrame.BlockAckBitmap">
            <summary>
            Gets or sets the block ack bitmap used to indicate the receive status of the MPDUs.
            </summary>
            <value>
            The block ack bitmap.
            </value>
            <exception cref="T:System.ArgumentException">
            Is thrown when the bitmap is of an incorrect lenght. The bitmap must be either 8 or 64 btyes longs depending on whether or not
            it is compressed.
            </exception>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.BlockAcknowledgmentFrame.FrameSize">
            <summary>
            Length of the frame
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.FrameControlField">
            <summary>
            Every 802.11 frame has a control field that contains information about the frame including
            the 802.11 protocol version, frame type, and various indicators, such as whether WEP is on,
            power management is active.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.FrameControlField.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.FrameControlField"/> class.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.FrameControlField.#ctor(System.UInt16)">
            <summary>
            Constructor
            </summary>
            <param name="field">
            A <see cref="T:System.UInt16"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.FrameControlField.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:Kavprot.Packets.Ieee80211.FrameControlField"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:Kavprot.Packets.Ieee80211.FrameControlField"/>.
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.FrameControlField.ProtocolVersion">
            <summary>
            Protocol version
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.FrameControlField.Type">
            <summary>
            Gets the type of the frame.
            </summary>
            <value>
            The type.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.FrameControlField.SubType">
            <summary>
            Helps to identify the type of WLAN frame, control data and management are
            the various frame types defined in IEEE 802.11
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.FrameControlField.ToDS">
            <summary>
            Is set to 1 when the frame is sent to Distribution System (DS)
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.FrameControlField.FromDS">
            <summary>
            Is set to 1 when the frame is received from the Distribution System (DS)
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.FrameControlField.MoreFragments">
            <summary>
            More Fragment is set to 1 when there are more fragments belonging to the same
            frame following the current fragment
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.FrameControlField.Retry">
            <summary>
            Indicates that this fragment is a retransmission of a previously transmitted fragment.
            (For receiver to recognize duplicate transmissions of frames)
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.FrameControlField.PowerManagement">
            <summary>
             Indicates the power management mode that the station will be in after the transmission of the frame
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.FrameControlField.MoreData">
            <summary>
            Indicates that there are more frames buffered for this station
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.FrameControlField.Wep">
            <summary>
            Indicates that the frame body is encrypted according to the WEP (wired equivalent privacy) algorithm
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.FrameControlField.Order">
            <summary>
            Bit is set when the "strict ordering" delivery method is employed. Frames and
            fragments are not always sent in order as it causes a transmission performance penalty.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.FrameControlField.Field">
            <summary>
            Gets or sets the field.
            </summary>
            <value>
            The field.
            </value>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.FrameControlField.FrameTypes">
            <summary>
            Specifies the main frame type: Control, Management or Data.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameTypes.Management">
            <summary>
            Management frame.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameTypes.Control">
            <summary>
            Control frame.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameTypes.Data">
            <summary>
            Data frame.
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes">
            <summary>
            Sepcifies the frame types down to the sub type level.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.ManagementAssociationRequest">
            <summary>
            Association request
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.ManagementAssociationResponse">
            <summary>
            Association response
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.ManagementReassociationRequest">
            <summary>
            Reassociation request
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.ManagementReassociationResponse">
            <summary>
            Reassociation response
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.ManagementProbeRequest">
            <summary>
            Probe request
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.ManagementProbeResponse">
            <summary>
            Probe response
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.ManagementReserved0">
            <summary>
            Reserved 0
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.ManagementReserved1">
            <summary>
            Reserved 1
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.ManagementBeacon">
            <summary>
            Beacon
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.ManagementATIM">
            <summary>
            ATIM
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.ManagementDisassociation">
            <summary>
            Disassociation
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.ManagementAuthentication">
            <summary>
            Authentication
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.ManagementDeauthentication">
            <summary>
            Deauthentication
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.ManagementAction">
            <summary>
            Reserved 2
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.ManagementReserved3">
            <summary>
            Reserved 3
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.ControlBlockAcknowledgmentRequest">
            <summary>
            Blck Acknowledgment Request (QOS)
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.ControlBlockAcknowledgment">
            <summary>
            Blck Acknowledgment (QOS)
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.ControlPSPoll">
            <summary>
            PS poll
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.ControlRTS">
            <summary>
            RTS
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.ControlCTS">
            <summary>
            CTS
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.ControlACK">
            <summary>
            ACK
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.ControlCFEnd">
            <summary>
            CF-End
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.ControlCFEndCFACK">
            <summary>
            CF-End CF-Ack
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.Data">
            <summary>
            Data
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.DataCFACK">
            <summary>
            CF-ACK
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.DataCFPoll">
            <summary>
            CF-Poll
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.DataCFAckCFPoll">
            <summary>
            CF-Ack CF-Poll
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.DataNullFunctionNoData">
            <summary>
            Null function no data
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.DataCFAckNoData">
            <summary>
            CF-Ack No data
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.DataCFPollNoData">
            <summary>
            CF-Poll no data
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.DataCFAckCFPollNoData">
            <summary>
            CF-Ack CF-Poll no data
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.QosData">
            <summary>
            Constant qos data.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.QosDataAndCFAck">
            <summary>
            Constant qos data and CF ack.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.QosDataAndCFPoll">
            <summary>
            Constant qos data and CF poll.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.QosDataAndCFAckAndCFPoll">
            <summary>
            Constant qos data and CF ack and CF poll.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.QosNullData">
            <summary>
            Constant qos null data.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.QosCFAck">
            <summary>
            Constant qos CF ack.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.QosCFPoll">
            <summary>
            Constant qos CF poll.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FrameControlField.FrameSubTypes.QosCFAckAndCFPoll">
            <summary>
            Constant qos CF ack and CF poll.
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.BlockAcknowledgmentControlField">
            <summary>
            Block acknowledgment control field.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.BlockAcknowledgmentControlField.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.BlockAcknowledgmentControlField"/> class.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.BlockAcknowledgmentControlField.#ctor(System.UInt16)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.BlockAcknowledgmentControlField"/> class.
            </summary>
            <param name="field">
            Field.
            </param>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.BlockAcknowledgmentControlField.Policy">
            <summary>
            The block acknowledgement policy in use
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.BlockAcknowledgmentControlField.MultiTid">
            <summary>
            True if the acknowledgement can ack multi traffic ids
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.BlockAcknowledgmentControlField.CompressedBitmap">
            <summary>
            True if the frame is using a compressed acknowledgement bitmap.
            
            Newer standards used a compressed bitmap reducing its size
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.BlockAcknowledgmentControlField.Tid">
            <summary>
            The traffic id being ack'd
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.BlockAcknowledgmentControlField.Field">
            <summary>
            Gets or sets the field. This provides direct access to the bytes that back all the other properties in the field.
            </summary>
            <value>
            The field.
            </value>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.BlockAcknowledgmentControlField.AcknowledgementPolicy">
            <summary>
            The available block acknowledgement policies.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.BlockAcknowledgmentControlField.AcknowledgementPolicy.Delayed">
            <summary>
            The acknowledgement does not have to be sent immediately after the request
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.BlockAcknowledgmentControlField.AcknowledgementPolicy.Immediate">
            <summary>
            The acknowledgement must be sent immediately after the request
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.AuthenticationStatusCode">
            <summary>
            The potential results of authentication or association operations.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.AuthenticationStatusCode.Success">
            <summary>
            Constant success.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.AuthenticationStatusCode.UnspecifiedFailure">
            <summary>
            Constant unspecified failure.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.AuthenticationStatusCode.RequestedCapabilityUnsupportable">
            <summary>
            Constant requested capability unsupportable.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.AuthenticationStatusCode.UnidentifiablePriorAssociation">
            <summary>
            Constant unidentifiable prior association.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.AuthenticationStatusCode.NonStandardUnspecifiedDenial">
            <summary>
            Constant non standard unspecified denial.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.AuthenticationStatusCode.AuthenticationAlgorithmNotSupported">
            <summary>
            Constant authentication algorithm not supported.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.AuthenticationStatusCode.UnexpectedSequenecNumber">
            <summary>
            Constant unexpected sequenec number.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.AuthenticationStatusCode.ResponseToChallengeFailed">
            <summary>
            Constant response to challenge failed.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.AuthenticationStatusCode.NextFrameOutsideExpectedWindow">
            <summary>
            Constant next frame outside expected window.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.AuthenticationStatusCode.AccessPointResourceConstrained">
            <summary>
            Constant access point resource constrained.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.AuthenticationStatusCode.StationDoesntSupportDataRates">
            <summary>
            Constant station doesnt support data rates.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.AuthenticationStatusCode.StationDoesntSupportPreamble">
            <summary>
            Constant station doesnt support preamble.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.AuthenticationStatusCode.StationDoesntSupportPbccModulation">
            <summary>
            Constant station doesnt support pbcc modulation.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.AuthenticationStatusCode.StationDoesntSupportChannelAgility">
            <summary>
            Constant station doesnt support channel agility.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.AuthenticationStatusCode.SpectrumManagementRequired">
            <summary>
            Constant spectrum management required.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.AuthenticationStatusCode.UnacceptablePowerCapabilityValue">
            <summary>
            Constant unacceptable power capability value.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.AuthenticationStatusCode.UnacceptableSupportedChannelsValue">
            <summary>
            Constant unacceptable supported channels value.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.AuthenticationStatusCode.StationDoesntSupportShortTimeSlot">
            <summary>
            Constant station doesnt support short time slot.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.AuthenticationStatusCode.StationDoesntSupportDsssOfdm">
            <summary>
            Constant station doesnt support dsss ofdm.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.AuthenticationStatusCode.InvalidInformationElement">
            <summary>
            Constant invalid information element.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.AuthenticationStatusCode.InvalidGroupCipher">
            <summary>
            Constant invalid group cipher.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.AuthenticationStatusCode.InvalidPairwiseCipher">
            <summary>
            Constant invalid pairwise cipher.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.AuthenticationStatusCode.InvalidAuthenticationAndKeyManagementProtocol">
            <summary>
            Constant invalid authentication and key management protocol.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.AuthenticationStatusCode.UnsupportedRsnInformationElementVersion">
            <summary>
            Constant unsupported rsn information element version.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.AuthenticationStatusCode.UnsupportedRsnIeCapabilities">
            <summary>
            Constant unsupported rsn ie capabilities.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.AuthenticationStatusCode.CipherSuitePolicyRejection">
            <summary>
            Constant cipher suite policy rejection.
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.AssociationRequestFrame">
            <summary>
            Format of an 802.11 management association frame.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.AssociationRequestFrame.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Constructor
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.AssociationRequestFrame.#ctor(System.Net.NetworkInformation.PhysicalAddress,System.Net.NetworkInformation.PhysicalAddress,System.Net.NetworkInformation.PhysicalAddress,Kavprot.Packets.Ieee80211.InformationElementList)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.AssociationRequestFrame"/> class.
            </summary>
            <param name="SourceAddress">
            Source address.
            </param>
            <param name="DestinationAddress">
            Destination address.
            </param>
            <param name="BssId">
            Bss identifier (MAC Address of Access Point).
            </param>
            <param name="InformationElements">
            Information elements.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.AssociationRequestFrame.UpdateCalculatedValues">
            <summary>
            Writes the current packet properties to the backing ByteArraySegment.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.AssociationRequestFrame.CapabilityInformationBytes">
            <summary>
            Frame control bytes are the first two bytes of the frame
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.AssociationRequestFrame.CapabilityInformation">
            <summary>
            Gets or sets the capability information.
            </summary>
            <value>
            The capability information.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.AssociationRequestFrame.ListenInterval">
            <summary>
            Gets or sets the listen interval.
            </summary>
            <value>
            The listen interval.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.AssociationRequestFrame.InformationElements">
            <summary>
            Gets or sets the information elements.
            </summary>
            <value>
            The information elements.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.AssociationRequestFrame.FrameSize">
            <summary>
            Gets the size of the frame.
            </summary>
            <value>
            The size of the frame.
            </value>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.ActionFrame">
            <summary>
            Format of an 802.11 management action frame. These frames are used by the 802.11e (QoS) and 802.11n standards to request actions of stations.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.ActionFrame.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Constructor
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.ActionFrame.#ctor(System.Net.NetworkInformation.PhysicalAddress,System.Net.NetworkInformation.PhysicalAddress,System.Net.NetworkInformation.PhysicalAddress)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.ActionFrame"/> class.
            </summary>
            <param name="SourceAddress">
            Source address.
            </param>
            <param name="DestinationAddress">
            Destination address.
            </param>
            <param name="BssId">
            Bss identifier.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.ActionFrame.UpdateCalculatedValues">
            <summary>
            Writes the current packet properties to the backing ByteArraySegment.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.ActionFrame.FrameSize">
            <summary>
            Gets the size of the frame in bytes
            </summary>
            <value>
            The size of the frame.
            </value>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.ReasonCode">
            <summary>
            Specifies the reasons why a station may have been disassociated or deauthenticated by an access point.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.ReasonCode.None">
            <summary>
            No reason was given.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.ReasonCode.Unspecified">
            <summary>
            The reason was not specified.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.ReasonCode.AuthNoLongerValid">
            <summary>
            The previous authentication was no longer valid.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.ReasonCode.Leaving">
            <summary>
            The station is leaving (or has left) the IBSS or ESS.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.ReasonCode.Inactivity">
            <summary>
            The station has been disassociated due to inactivity.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.ReasonCode.OutOfResources">
            <summary>
            The access point is unable to handle anymore associated stations.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.ReasonCode.NeedAuthentication">
            <summary>
            The station needs to be authenticated.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.ReasonCode.NeedAssociation">
            <summary>
            The station needs to be associated.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.ReasonCode.LeavingToRoam">
            <summary>
            The station is leaving the BSS.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.ReasonCode.AssociationInvalid">
            <summary>
            Association is invalid because the station is not authenticated.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.ReasonCode.BadPower">
            <summary>
            The Power Capability information is unacceptable.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.ReasonCode.BadChannels">
            <summary>
            The Supported Channels information is unacceptable.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.ReasonCode.InvalidInformationElement">
            <summary>
            An invalid information element has been provided.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.ReasonCode.MessageIntegrityCheckFailure">
            <summary>
            The message integrity check failed.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.ReasonCode.FourwayHandshakeTimeout">
            <summary>
            The 4way handshake has timed out.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.ReasonCode.GroupKeyHandshakeTimeout">
            <summary>
            The Group Key handshake has timed out.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.ReasonCode.FourwayHandshakeInvalid">
            <summary>
            An information element in the 4way handshake differs from in previous management frames.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.ReasonCode.GroupCipherInvalid">
            <summary>
            The group cipher is invalid.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.ReasonCode.PairwiseCipherInvalid">
            <summary>
            The pairwise cipher is invalid.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.ReasonCode.AuthenticationKeyManagmentProtocolInvalid">
            <summary>
            The Authentication Key Managment Protocol is invalid.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.ReasonCode.RsnVersionUnsupported">
            <summary>
            The provided RSN information element version is unsupported.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.ReasonCode.RsnCapabilitiesInvalid">
            <summary>
            The provided RSN information element capabilities are invalid.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.ReasonCode.Ieee8021XFailure">
            <summary>
            There has been an IEEE 802.1X authentication failure.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.ReasonCode.CipherRejected">
            <summary>
            The cipher suite has been rejected due to the security policy.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.ReasonCode.QosUnspecified">
            <summary>
            The station has been disassociated due to an unspecified QoS related reason.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.ReasonCode.QosOutOfResources">
            <summary>
            The access point lacks sufficient bandwidth for the station.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.ReasonCode.PoorChannelConditions">
            <summary>
            An excessive number of frames have failed to be acknowledged due to poor channel conditions.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.ReasonCode.InvalidTxop">
            <summary>
            The station is transmitting outside the limits of its TXOPs.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.ReasonCode.RequestedLeaving">
            <summary>
            Disassociation was requested by the station as it is leaving the BSS.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.ReasonCode.RequestedNoUse">
            <summary>
            Disassociation was requested by the station as it is no longer wants to use the mechanism.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.ReasonCode.RequestedNeedsSetup">
            <summary>
            Disassociation was requested by the station as it requires setup to use the mechanism.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.ReasonCode.RequestedDueToTimeout">
            <summary>
            Disassociation was requested by the station due to a timeout.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.ReasonCode.CipherUnsupported">
            <summary>
            The station does not support the cipher suite.
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.NullDataFrame">
            <summary>
            Null data frames are like normal data frames except they carry no payload. They are primarily used for control purposes
            such as power management or telling an Access Point to buffer packets while a station scans other channels.
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.DataFrame">
            <summary>
            Data frame.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DataFrame.AssignDefaultAddresses">
            <summary>
            Assigns the default MAC address of 00-00-00-00-00-00 to all address fields.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DataFrame.ReadAddresses">
            <summary>
            Reads the addresses from the backing ByteArraySegment into the the address properties.
            </summary>
            <remarks>
            The <see cref="T:Kavprot.Packets.Ieee80211.FrameControlField"/> ToDS and FromDS properties dictate
            which of the 4 possible address fields is read into which address property.
            </remarks>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DataFrame.WriteAddressBytes">
            <summary>
            Writes the address properties into the backing <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>.
            </summary>
            <remarks>
            The address position into which a particular address property is written is determined by the 
            value of <see cref="T:Kavprot.Packets.Ieee80211.FrameControlField"/> ToDS and FromDS properties.
            </remarks>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DataFrame.GetAddressString">
            <summary>
            Returns a string with a description of the addresses used in the packet.
            This is used as a compoent of the string returned by ToString().
            </summary>
            <returns>
            The address string.
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.DataFrame.SourceAddress">
            <summary>
            SourceAddress
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.DataFrame.DestinationAddress">
            <summary>
            DestinationAddress
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.DataFrame.ReceiverAddress">
            <summary>
            ReceiverAddress
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.DataFrame.TransmitterAddress">
            <summary>
            TransmitterAddress
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.DataFrame.BssId">
            <summary>
            BssID
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.DataFrame.SequenceControlBytes">
            <summary>
            Frame control bytes are the first two bytes of the frame
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.DataFrame.SequenceControl">
            <summary>
            Sequence control field
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.NullDataFrame.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.NullDataFrame"/> class.
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.NullDataFrame.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.NullDataFrame"/> class.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.NullDataFrame.UpdateCalculatedValues">
            <summary>
            Writes the current packet properties to the backing ByteArraySegment.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.NullDataFrame.FrameSize">
            <summary>
            Length of the frame header.
            
            This does not include the FCS, it represents only the header bytes that would
            would preceed any payload.
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.AssociationResponseFrame">
            <summary>
            Format of an 802.11 management association response frame.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.AssociationResponseFrame.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Constructor
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.AssociationResponseFrame.#ctor(System.Net.NetworkInformation.PhysicalAddress,System.Net.NetworkInformation.PhysicalAddress,System.Net.NetworkInformation.PhysicalAddress,Kavprot.Packets.Ieee80211.InformationElementList)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.AssociationResponseFrame"/> class.
            </summary>
            <param name="SourceAddress">
            Source address.
            </param>
            <param name="DestinationAddress">
            Destination address.
            </param>
            <param name="BssId">
            Bss identifier (MAC Address of Access Point).
            </param>
            <param name="InformationElements">
            Information elements.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.AssociationResponseFrame.UpdateCalculatedValues">
            <summary>
            Writes the current packet properties to the backing ByteArraySegment.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.AssociationResponseFrame.CapabilityInformationBytes">
            <summary>
            The raw capability information bytes
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.AssociationResponseFrame.CapabilityInformation">
            <summary>
            The capability information field that describes the networks capabilities.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.AssociationResponseFrame.StatusCode">
            <summary>
            Value indicating the success or failure of the association.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.AssociationResponseFrame.AssociationId">
            <summary>
            The id assigned to the station by the access point to assist in management and control functions.
            
            Although this is a 16bit field only 14 of the bits are used to represent the id. Therefore the available values
            for this field are inthe range 1-2,007.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.AssociationResponseFrame.InformationElements">
            <summary>
            The information elements included in the frame
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.AssociationResponseFrame.FrameSize">
            <summary>
            Gets the size of the frame.
            </summary>
            <value>
            The size of the frame.
            </value>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.RadioTapChannelFlags">
            <summary>
            Channel flags
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioTapChannelFlags.Turbo">
            <summary>Turbo channel</summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioTapChannelFlags.Cck">
            <summary>CCK channel</summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioTapChannelFlags.Ofdm">
            <summary>OFDM channel</summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioTapChannelFlags.Channel2Ghz">
            <summary>2 GHz spectrum channel</summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioTapChannelFlags.Channel5Ghz">
            <summary>5 GHz spectrum channel</summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioTapChannelFlags.Passive">
            <summary>Only passive scan allowed</summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioTapChannelFlags.DynamicCckOfdm">
            <summary>Dynamic CCK-OFDM channel</summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioTapChannelFlags.Gfsk">
            <summary>GFSK channel (FHSS PHY)</summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioTapChannelFlags.StaticTurbo">
            <summary>11a static turbo channel only</summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.ProbeRequestFrame">
            <summary>
            Probe request frames are used by stations to scan the area for existing networks.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.ProbeRequestFrame.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Constructor
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.ProbeRequestFrame.#ctor(System.Net.NetworkInformation.PhysicalAddress,System.Net.NetworkInformation.PhysicalAddress,System.Net.NetworkInformation.PhysicalAddress,Kavprot.Packets.Ieee80211.InformationElementList)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.ProbeRequestFrame"/> class.
            </summary>
            <param name="SourceAddress">
            Source address.
            </param>
            <param name="DestinationAddress">
            Destination address.
            </param>
            <param name="BssId">
            Bss identifier (Mac Address of the Access Point).
            </param>
            <param name="InformationElements">
            Information elements.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.ProbeRequestFrame.UpdateCalculatedValues">
            <summary>
            Writes the current packet properties to the backing ByteArraySegment.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.ProbeRequestFrame.FrameSize">
            <summary>
            Length of the frame header.
            
            This does not include the FCS, it represents only the header bytes that would
            would preceed any payload.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.ProbeRequestFrame.InformationElements">
            <summary>
            Gets or sets the information elements included in the frame.
            </summary>
            <value>
            The information elements.
            </value>
            <remarks>Probe request frames normally contain information elements for <see cref="F:Kavprot.Packets.Ieee80211.InformationElement.ElementId.ServiceSetIdentity"/>, 
            <see cref="F:Kavprot.Packets.Ieee80211.InformationElement.ElementId.SupportedRates"/> and <see cref="F:Kavprot.Packets.Ieee80211.InformationElement.ElementId.ExtendedSupportedRates"/> in that order.</remarks>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.DisassociationFrame">
            <summary>
            Disassociation frame.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DisassociationFrame.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Constructor
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DisassociationFrame.#ctor(System.Net.NetworkInformation.PhysicalAddress,System.Net.NetworkInformation.PhysicalAddress,System.Net.NetworkInformation.PhysicalAddress)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.DisassociationFrame"/> class.
            </summary>
            <param name="SourceAddress">
            Source address.
            </param>
            <param name="DestinationAddress">
            Destination address.
            </param>
            <param name="BssId">
            Bss identifier (MAC Address of the Access Point).
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DisassociationFrame.UpdateCalculatedValues">
            <summary>
            Writes the current packet properties to the backing ByteArraySegment.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.DisassociationFrame.Reason">
            <summary>
            Gets or sets the reason for disassociation.
            </summary>
            <value>
            The reason.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.DisassociationFrame.FrameSize">
            <summary>
            Gets the size of the frame.
            </summary>
            <value>
            The size of the frame.
            </value>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.CapabilityInformationField">
            <summary>
            Capability information field.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.CapabilityInformationField.GetBitFieldValue(System.UInt16)">
            <summary>
            Returns true if the bit is set false if not.
            </summary>
            <param name="index">0 indexed position of the bit</param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.CapabilityInformationField.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.CapabilityInformationField"/> class.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.CapabilityInformationField.#ctor(System.UInt16)">
            <summary>
            Constructor
            </summary>
            <param name="field">
            A <see cref="T:System.UInt16"/>
            </param>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.CapabilityInformationField.IsEss">
            <summary>
            Is set to 1 when the beacon frame is representing an ESS (as opposed to an IBSS)
            
            This field and IsIbss should be mutually exclusive
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.CapabilityInformationField.IsIbss">
            <summary>
            Is set to 1 when the beacon frame is representing an IBSS (as opposed to an ESS)
            
            This field and IsEss should be mutually exclusive
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.CapabilityInformationField.CfPollable">
            <summary>
            Gets or sets a value indicating whether this
            <see cref="T:Kavprot.Packets.Ieee80211.CapabilityInformationField"/> cf pollable.
            </summary>
            <value>
            <c>true</c> if cf pollable; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.CapabilityInformationField.CfPollRequest">
            <summary>
            Gets or sets a value indicating whether this
            <see cref="T:Kavprot.Packets.Ieee80211.CapabilityInformationField"/> cf poll request.
            </summary>
            <value>
            <c>true</c> if cf poll request; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.CapabilityInformationField.Privacy">
            <summary>
            Gets or sets a value indicating whether this
            <see cref="T:Kavprot.Packets.Ieee80211.CapabilityInformationField"/> is privacy.
            </summary>
            <value>
            <c>true</c> if privacy; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.CapabilityInformationField.ShortPreamble">
            <summary>
            Gets or sets a value indicating whether this
            <see cref="T:Kavprot.Packets.Ieee80211.CapabilityInformationField"/> short preamble.
            </summary>
            <value>
            <c>true</c> if short preamble; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.CapabilityInformationField.Pbcc">
            <summary>
            Gets or sets a value indicating whether this
            <see cref="T:Kavprot.Packets.Ieee80211.CapabilityInformationField"/> is pbcc.
            </summary>
            <value>
            <c>true</c> if pbcc; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.CapabilityInformationField.ChannelAgility">
            <summary>
            Gets or sets a value indicating whether this
            <see cref="T:Kavprot.Packets.Ieee80211.CapabilityInformationField"/> channel agility.
            </summary>
            <value>
            <c>true</c> if channel agility; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.CapabilityInformationField.ShortTimeSlot">
            <summary>
            Gets or sets a value indicating whether this
            <see cref="T:Kavprot.Packets.Ieee80211.CapabilityInformationField"/> short time slot.
            </summary>
            <value>
            <c>true</c> if short time slot; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.CapabilityInformationField.DssOfdm">
            <summary>
            Gets or sets a value indicating whether this
            <see cref="T:Kavprot.Packets.Ieee80211.CapabilityInformationField"/> dss ofdm.
            </summary>
            <value>
            <c>true</c> if dss ofdm; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.CapabilityInformationField.Field">
            <summary>
            Gets or sets the field.
            </summary>
            <value>
            The field.
            </value>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.BeaconFrame">
            <summary>
            Format of an 802.11 management beacon frame.
            
            Beacon frames are used to annouce the existance of a wireless network. If an
            access point has been configured to not broadcast its SSID then it may not transmit
            beacon frames.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.BeaconFrame.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Constructor
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.BeaconFrame.#ctor(System.Net.NetworkInformation.PhysicalAddress,System.Net.NetworkInformation.PhysicalAddress,Kavprot.Packets.Ieee80211.InformationElementList)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.BeaconFrame"/> class.
            </summary>
            <param name="SourceAddress">
            Source address.
            </param>
            <param name="BssId">
            Bss identifier (MAC Address of the Access Point).
            </param>
            <param name="InformationElements">
            Information elements.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.BeaconFrame.UpdateCalculatedValues">
            <summary>
            Writes the current packet properties to the backing ByteArraySegment.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.BeaconFrame.Timestamp">
            <summary>
            The number of microseconds the networks master timekeeper has been active.
            
            Used for synchronisation between stations in an IBSS. When it reaches the maximum value the timestamp will wrap (not very likely).
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.BeaconFrame.BeaconInterval">
            <summary>
            The number of "time units" between beacon frames.
            
            A time unit is 1,024 microseconds. This interval is usually set to 100 which equates to approximately 100 milliseconds or 0.1 seconds.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.BeaconFrame.CapabilityInformationBytes">
            <summary>
            Frame control bytes are the first two bytes of the frame
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.BeaconFrame.CapabilityInformation">
            <summary>
            Defines the capabilities of the network.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.BeaconFrame.FrameSize">
            <summary>
            Gets the size of the frame.
            </summary>
            <value>
            The size of the frame.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.BeaconFrame.InformationElements">
            <summary>
            The information elements included in the frame
            
            Most (but not all) beacons frames will contain an Information element that contains the SSID.
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.PpiHeaderFields">
             <summary>
             As defined by Airpcap.h
            
             NOTE: PresentPosition may not be the only position present
             as this the field can be extended if the high bit is set
             </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.PpiHeaderFields.FirstFieldPosition">
            <summary>Position of the first iField Header</summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.PpiHeaderFields.DataLinkTypeLength">
            <summary>Length of the Data Link Type</summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.PpiHeaderFields.DataLinkTypePosition">
            <summary>The data link type position.</summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.PpiHeaderFields.FlagsLength">
            <summary>Length of the Flags field</summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.PpiHeaderFields.FlagsPosition">
            <summary>Position of the Flags field</summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.PpiHeaderFields.LengthLength">
            <summary>Length of the length field</summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.PpiHeaderFields.LengthPosition">
            <summary>Position of the length field</summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.PpiHeaderFields.VersionLength">
            <summary>Length of the version field</summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.PpiHeaderFields.VersionPosition">
            <summary>Position of the version field</summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.PpiHeaderFields.PpiPacketHeaderLength">
            <summary>The total length of the ppi packet header</summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.PpiHeaderFields.FieldHeaderLength">
            <summary>The length of the PPI field header</summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.Ppi802_3">
            <summary>
            Contains information specific to 802.3 packets.
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.PpiField">
            <summary>
            Abstract class for all PPI fields
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.PpiField.Parse(System.Int32,System.IO.BinaryReader,System.UInt16)">
            <summary>
            Parse a PPI indicated by type, from a given BinaryReader
            </summary>
            <param name="fieldType">
            A <see cref="T:System.Int32"/>
            </param>
            <param name="br">
            A <see cref="T:System.IO.BinaryReader"/>
            </param>
            <param name="fieldLength">
            The maximum number of bytes that the field to be parsed can encompass.
            </param>
            <returns>
            A <see cref="T:Kavprot.Packets.Ieee80211.PpiField"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiField.FieldType">
            <summary>Type of the field</summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiField.Length">
            <summary>
            Gets the length of the field data.
            </summary>
            <value>
            The length.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiField.Bytes">
            <summary>
            Gets the field bytes. This doesn't include the PPI field header.
            </summary>
            <value>
            The bytes.
            </value>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.Ppi802_3.#ctor(System.IO.BinaryReader)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.Ppi802_3"/> class from the 
            provided stream.
            </summary>
            <remarks>
            The position of the BinaryReader's underlying stream will be advanced to the end
            of the PPI field.
            </remarks>
            <param name="br">
            The stream the field will be read from
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.Ppi802_3.#ctor(Kavprot.Packets.Ieee80211.Ppi802_3.StandardFlags,Kavprot.Packets.Ieee80211.Ppi802_3.ErrorFlags)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.Ppi802_3"/> class.
            </summary>
            <param name="Flags">
            Standard Flags.
            </param>
            <param name="Errors">
            Error Flags.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.Ppi802_3.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.Ppi802_3"/> class.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.Ppi802_3.FieldType">
            <summary>Type of the field</summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.Ppi802_3.Length">
            <summary>
            Gets the length of the field data.
            </summary>
            <value>
            The length.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.Ppi802_3.Flags">
            <summary>
            Gets or sets the standard 802.2 flags.
            </summary>
            <value>
            The standard flags.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.Ppi802_3.Errors">
            <summary>
            Gets or sets the 802.3 error flags.
            </summary>
            <value>
            The error flags.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.Ppi802_3.Bytes">
            <summary>
            Gets the field bytes. This doesn't include the PPI field header.
            </summary>
            <value>
            The bytes.
            </value>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.Ppi802_3.StandardFlags">
            <summary>
            802.3 specific extension flags.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.Ppi802_3.StandardFlags.FcsPresent">
            <summary>
            FCS is present at the end of the packet
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.Ppi802_3.ErrorFlags">
            <summary>
            Flags for errors detected at the time the packet was captured.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.Ppi802_3.ErrorFlags.InvalidFcs">
            <summary>
            The frames FCS is invalid.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.Ppi802_3.ErrorFlags.SequenceError">
            <summary>
            The frame has a sequence error.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.Ppi802_3.ErrorFlags.SymbolError">
            <summary>
            The frame has a symbol error.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.Ppi802_3.ErrorFlags.DataError">
            <summary>
            The frame has a data error.
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.PpiAggregation">
            <summary>
            The PPI Aggregation field is used to identify which physical interface a frame was collected on
            when multiple capture interfaces are in use.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.PpiAggregation.#ctor(System.IO.BinaryReader)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.PpiAggregation"/> class from the 
            provided stream.
            </summary>
            <remarks>
            The position of the BinaryReader's underlying stream will be advanced to the end
            of the PPI field.
            </remarks>
            <param name="br">
            The stream the field will be read from
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.PpiAggregation.#ctor(System.UInt32)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.PpiAggregation"/> class.
            </summary>
            <param name="InterfaceId">
            The interface id.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.PpiAggregation.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.PpiAggregation"/> class.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiAggregation.FieldType">
            <summary>Type of the field</summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiAggregation.Length">
            <summary>
            Gets the length of the field data.
            </summary>
            <value>
            The length.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiAggregation.InterfaceId">
            <summary>
            Zero-based index of the physical interface the packet was captured from.
            </summary>
            <value>
            The interface id.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiAggregation.Bytes">
            <summary>
            Gets the field bytes. This doesn't include the PPI field header.
            </summary>
            <value>
            The bytes.
            </value>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.PpiCaptureInfo">
            <summary>
            The PPI Capture Info field has been assigned a PPI field type but currently has no defined
            field body.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.PpiCaptureInfo.#ctor(System.IO.BinaryReader)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.PpiCaptureInfo"/> class from the 
            provided stream.
            </summary>
            <remarks>
            The position of the BinaryReader's underlying stream will be advanced to the end
            of the PPI field.
            </remarks>
            <param name="br">
            The stream the field will be read from
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.PpiCaptureInfo.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.PpiCaptureInfo"/> class.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiCaptureInfo.FieldType">
            <summary>Type of the field</summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiCaptureInfo.Length">
            <summary>
            Gets the length of the field data.
            </summary>
            <value>
            The length.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiCaptureInfo.Bytes">
            <summary>
            Gets the field bytes. This doesn't include the PPI field header.
            </summary>
            <value>
            The bytes.
            </value>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.PpiCommon">
            <summary>
            The PPI Common field contains fields common to all 802.11 specifications.
            This field is loosely based on the Radio Tap header format.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.PpiCommon.#ctor(System.IO.BinaryReader)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.PpiCommon"/> class from the 
            provided stream.
            </summary>
            <remarks>
            The position of the BinaryReader's underlying stream will be advanced to the end
            of the PPI field.
            </remarks>
            <param name="br">
            The stream the field will be read from
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.PpiCommon.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.PpiCommon"/> class.
            AntennaSignalPower and AntennaSignalNoise are both set to their minimum value of -128.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiCommon.FieldType">
            <summary>Type of the field</summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiCommon.Length">
            <summary>
            Gets the length of the field data.
            </summary>
            <value>
            The length.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiCommon.ChannelFlags">
            <summary>
            Radiotap-formatted channel flags.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiCommon.ChannelFrequency">
            <summary>
            Radiotap-formatted channel frequency, in MHz. 0 indicates an invalid value.
            </summary>
            <value>
            The channel frequency.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiCommon.Flags">
            <summary>
            The common flags.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiCommon.Rate">
            <summary>
            Data rate in multiples of 500 Kbps. 0 indicates an invalid value.
            </summary>
            <value>
            The data rate.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiCommon.TSFTimer">
            <summary>
            Gets or sets the TSF timer.
            </summary>
            <value>
            The TSF Timer value.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiCommon.FhssHopset">
            <summary>
            Gets or sets the Frequency-hopping spread spectrum (FHSS) hopset
            </summary>
            <value>
            The FHSS hopset.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiCommon.FhssPattern">
            <summary>
            Gets or sets the Frequency-hopping spread spectrum (FHSS) pattern.
            </summary>
            <value>
            The FHSS pattern.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiCommon.AntennaSignalPower">
            <summary>
            Gets or sets the RF signal power at antenna.
            </summary>
            <value>
            The antenna signal power.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiCommon.AntennaSignalNoise">
            <summary>
            Gets or sets the RF signal noise at antenna
            </summary>
            <value>
            The antenna signal noise.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiCommon.Bytes">
            <summary>
            Gets the field bytes. This doesn't include the PPI field header.
            </summary>
            <value>
            The bytes.
            </value>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.PpiCommon.CommonFlags">
            <summary>
            Common 802.11 flags.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.PpiCommon.CommonFlags.FcsIncludedInFrame">
            <summary>
            Defines whether or not an FCS is included at the end of the encapsulated 802.11 frame.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.PpiCommon.CommonFlags.TimerSynchFunctionInUse">
            <summary>
            If set the TSF-timer is in milliseconds, if not set the TSF-timer is in microseconds
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.PpiCommon.CommonFlags.FailedFcsCheck">
            <summary>
            Indicates that the FCS on the encapsulated 802.11 frame is invalid
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.PpiCommon.CommonFlags.PhysicalError">
            <summary>
            Indicates that there was some type of physical error when receiving the packet.
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.PpiMacExtensionFlags">
            <summary>
            802.11n MAC Extension flags.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.PpiMacExtensionFlags.GreenField">
            <summary>
            Indicates the use of Greenfield (or HT) mode. In greenfield mode support for 802.11 a/b/g devices is sacrificed for
            increased efficiency.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.PpiMacExtensionFlags.HtIndicator">
            <summary>
            Indicates the High Throughput (HT) mode. If not set channel width is 20MHz, if set it is 40MHz. 
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.PpiMacExtensionFlags.RxSgi">
            <summary>
            Indicates the use of a Short Guard Interval (SGI).
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.PpiMacExtensionFlags.DuplicateRx">
            <summary>
            Indicates the use of HT Duplicate mode.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.PpiMacExtensionFlags.Aggregate">
            <summary>
            Indicates the use of MPDU aggregation.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.PpiMacExtensionFlags.MoreAggregates">
            <summary>
            Indicates the presence of more aggregate frames.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.PpiMacExtensionFlags.AggregateDelimiterCrc">
            <summary>
            Indicates there was a CRC error in the A-MPDU delimiter after this frame.
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.PpiMacExtensions">
            <summary>
            The 802.11n MAC Extension field contains radio information specific to 802.11n.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.PpiMacExtensions.#ctor(System.IO.BinaryReader)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.PpiMacExtensions"/> class from the 
            provided stream.
            </summary>
            <remarks>
            The position of the BinaryReader's underlying stream will be advanced to the end
            of the PPI field.
            </remarks>
            <param name="br">
            The stream the field will be read from
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.PpiMacExtensions.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.PpiMacExtensions"/> class.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiMacExtensions.FieldType">
            <summary>Type of the field</summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiMacExtensions.Length">
            <summary>
            Gets the length of the field data.
            </summary>
            <value>
            The length.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiMacExtensions.Flags">
            <summary>
            Gets or sets the 802.11n MAC extension flags.
            </summary>
            <value>
            The flags.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiMacExtensions.AMpduId">
            <summary>
            Gets or sets the A-MPDU identifier.
            </summary>
            <value>
            the A-MPDU id.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiMacExtensions.DelimiterCount">
            <summary>
            Gets or sets the number of zero-length pad delimiters
            </summary>
            <value>
            The delimiter count.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiMacExtensions.Bytes">
            <summary>
            Gets the field bytes. This doesn't include the PPI field header.
            </summary>
            <value>
            The bytes.
            </value>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.PpiMacPhy">
            <summary>
            The 802.11n MAC + PHY Extension field contains radio information specific to 802.11n.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.PpiMacPhy.#ctor(System.IO.BinaryReader)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.PpiMacPhy"/> class from the 
            provided stream.
            </summary>
            <remarks>
            The position of the BinaryReader's underlying stream will be advanced to the end
            of the PPI field.
            </remarks>
            <param name="br">
            The stream the field will be read from
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.PpiMacPhy.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.PpiMacPhy"/> class.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiMacPhy.FieldType">
            <summary>Type of the field</summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiMacPhy.Length">
            <summary>
            Gets the length of the field data.
            </summary>
            <value>
            The length.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiMacPhy.Flags">
            <summary>
            Gets or sets the 802.11n MAC extension flags.
            </summary>
            <value>
            The flags.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiMacPhy.AMpduId">
            <summary>
            Gets or sets the A-MPDU identifier.
            </summary>
            <value>
            the A-MPDU id.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiMacPhy.DelimiterCount">
            <summary>
            Gets or sets the number of zero-length pad delimiters
            </summary>
            <value>
            The delimiter count.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiMacPhy.ModulationCodingScheme">
            <summary>
            Gets or sets the modulation coding scheme.
            </summary>
            <value>
            The modulation coding scheme.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiMacPhy.SpatialStreamCount">
            <summary>
            Gets or sets the number of spatial streams.
            </summary>
            <value>
            The spatial stream count.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiMacPhy.RssiCombined">
            <summary>
            Gets or sets the combined Received Signal Strength Indication (RSSI) value 
            from all the active antennas and channels.
            </summary>
            <value>
            The combined RSSI.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiMacPhy.RssiAntenna0Control">
            <summary>
            Gets or sets the Received Signal Strength Indication (RSSI) value for the antenna 0, control channel.
            </summary>
            <value>
            The antenna 0 RSSI value.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiMacPhy.RssiAntenna1Control">
            <summary>
            Gets or sets the Received Signal Strength Indication (RSSI) value for the antenna 1, control channel.
            </summary>
            <value>
            The antenna 1 control channel RSSI value.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiMacPhy.RssiAntenna2Control">
            <summary>
            Gets or sets the Received Signal Strength Indication (RSSI) value for the antenna 2, control channel.
            </summary>
            <value>
            The antenna 2 control channel RSSI value.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiMacPhy.RssiAntenna3Control">
            <summary>
            Gets or sets the Received Signal Strength Indication (RSSI) value for the antenna 3, control channel.
            </summary>
            <value>
            The antenna 3 control channel RSSI value.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiMacPhy.RssiAntenna0Ext">
            <summary>
            Gets or sets the Received Signal Strength Indication (RSSI) value for the antenna 0, extension channel
            </summary>
            <value>
            The antenna 0 extension channel RSSI value.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiMacPhy.RssiAntenna1Ext">
            <summary>
            Gets or sets the Received Signal Strength Indication (RSSI) value for the antenna 1, extension channel
            </summary>
            <value>
            The antenna 1 extension channel RSSI value.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiMacPhy.RssiAntenna2Ext">
            <summary>
            Gets or sets the Received Signal Strength Indication (RSSI) value for the antenna 2, extension channel
            </summary>
            <value>
            The antenna 2 extension channel RSSI value.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiMacPhy.RssiAntenna3Ext">
            <summary>
            Gets or sets the Received Signal Strength Indication (RSSI) value for the antenna 3, extension channel
            </summary>
            <value>
            The antenna 3 extension channel RSSI value.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiMacPhy.ExtensionChannelFrequency">
            <summary>
            Gets or sets the extension channel frequency.
            </summary>
            <value>
            The extension channel frequency.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiMacPhy.ExtensionChannelFlags">
            <summary>
            Gets or sets the extension channel flags.
            </summary>
            <value>
            The extension channel flags.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiMacPhy.DBmAntenna0SignalPower">
            <summary>
            Gets or sets the RF signal power at antenna 0.
            </summary>
            <value>
            The signal power.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiMacPhy.DBmAntenna0SignalNoise">
            <summary>
            Gets or sets the RF signal noise at antenna 0.
            </summary>
            <value>
            The signal noise.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiMacPhy.DBmAntenna1SignalPower">
            <summary>
            Gets or sets the RF signal power at antenna 1.
            </summary>
            <value>
            The signal power.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiMacPhy.DBmAntenna1SignalNoise">
            <summary>
            Gets or sets the RF signal noise at antenna 1.
            </summary>
            <value>
            The signal noise.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiMacPhy.DBmAntenna2SignalPower">
            <summary>
            Gets or sets the RF signal power at antenna 2.
            </summary>
            <value>
            The signal power.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiMacPhy.DBmAntenna2SignalNoise">
            <summary>
            Gets or sets the RF signal noise at antenna 2.
            </summary>
            <value>
            The signal noise.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiMacPhy.DBmAntenna3SignalPower">
            <summary>
            Gets or sets the RF signal power at antenna 3.
            </summary>
            <value>
            The signal power.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiMacPhy.DBmAntenna3SignalNoise">
            <summary>
            Gets or sets the RF signal noise at antenna 3.
            </summary>
            <value>
            The signal noise.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiMacPhy.ErrorVectorMagnitude0">
            <summary>
            Gets or sets the error vector magnitude for Chain 0.
            </summary>
            <value>
            The error vector magnitude.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiMacPhy.ErrorVectorMagnitude1">
            <summary>
            Gets or sets the error vector magnitude for Chain 1.
            </summary>
            <value>
            The error vector magnitude.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiMacPhy.ErrorVectorMagnitude2">
            <summary>
            Gets or sets the error vector magnitude for Chain 2.
            </summary>
            <value>
            The error vector magnitude.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiMacPhy.ErrorVectorMagnitude3">
            <summary>
            Gets or sets the error vector magnitude for Chain 3.
            </summary>
            <value>
            The error vector magnitude.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiMacPhy.Bytes">
            <summary>
            Gets the field bytes. This doesn't include the PPI field header.
            </summary>
            <value>
            The bytes.
            </value>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.PpiProcessInfo">
            <summary>
            PPI process info field.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.PpiProcessInfo.#ctor(System.IO.BinaryReader)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.PpiProcessInfo"/> class from the 
            provided stream.
            </summary>
            <remarks>
            The position of the BinaryReader's underlying stream will be advanced to the end
            of the PPI field.
            </remarks>
            <param name="br">
            The stream the field will be read from
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.PpiProcessInfo.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.PpiProcessInfo"/> class.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiProcessInfo.FieldType">
            <summary>Type of the field</summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiProcessInfo.Length">
            <summary>
            Gets the length of the field data.
            </summary>
            <value>
            The length.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiProcessInfo.ProcessId">
            <summary>
            Gets or sets the process identifier.
            </summary>
            <value>
            The process identifier.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiProcessInfo.ThreadId">
            <summary>
            Gets or sets the thread identifier.
            </summary>
            <value>
            The thread identifier.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiProcessInfo.ProcessPath">
            <summary>
            Gets or sets the process path.
            </summary>
            <value>
            The process path.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiProcessInfo.UserId">
            <summary>
            Gets or sets the user identifier.
            </summary>
            <value>
            The user identifier.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiProcessInfo.UserName">
            <summary>
            Gets or sets the user name.
            </summary>
            <value>
            The user name.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiProcessInfo.GroupId">
            <summary>
            Gets or sets the group identifier.
            </summary>
            <value>
            The group identifier.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiProcessInfo.GroupName">
            <summary>
            Gets or sets the group name.
            </summary>
            <value>
            The group name.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiProcessInfo.Bytes">
            <summary>
            Gets the field bytes. This doesn't include the PPI field header.
            </summary>
            <value>
            The bytes.
            </value>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.PpiUnknown">
            <summary>
            The PpiUnknown field class can be used to represent any field types not
            currently supported by Kavprot.Packets. Any unsupported field types encountered during 
            parsing will be stored as PpiUnknown fields.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.PpiUnknown.#ctor(System.Int32,System.IO.BinaryReader,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.PpiUnknown"/> class from the 
            provided stream.
            </summary>
            <remarks>
            The position of the BinaryReader's underlying stream will be advanced to the end
            of the PPI field.
            </remarks>
            <param name="typeNumber">
            The PPI field type number
            </param>
            <param name="br">
            The stream the field will be read from
            </param>
            <param name="length">
            The number of bytes the unknown field contains.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.PpiUnknown.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.PpiUnknown"/> class.
            </summary>
            <param name="typeNumber">
            The PPI field type number.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.PpiUnknown.#ctor(System.Int32,System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.PpiUnknown"/> class.
            </summary>
            <param name="typeNumber">
            The PPI field type number.
            </param>
            <param name="UnknownBytes">
            The field data.
            </param>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiUnknown.FieldType">
            <summary>Type of the field</summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiUnknown.Length">
            <summary>
            Gets the length of the field data.
            </summary>
            <value>
            The length.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiUnknown.Bytes">
            <summary>
            Gets the field bytes. This doesn't include the PPI field header.
            </summary>
            <value>
            The bytes.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiUnknown.UnknownBytes">
            <summary>
            Gets or sets the field data.
            </summary>
            <value>
            The fields values bytes.
            </value>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.PpiSpectrum">
            <summary>
            The PPI Spectrum field is intended to be compatible with the sweep records
            returned by the Wi-Spy spectrum analyzer.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.PpiSpectrum.#ctor(System.IO.BinaryReader)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.PpiSpectrum"/> class from the 
            provided stream.
            </summary>
            <remarks>
            The position of the BinaryReader's underlying stream will be advanced to the end
            of the PPI field.
            </remarks>
            <param name="br">
            The stream the field will be read from
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.PpiSpectrum.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.PpiSpectrum"/> class.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiSpectrum.FieldType">
            <summary>Type of the field</summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiSpectrum.Length">
            <summary>
            Gets the length of the field data.
            </summary>
            <value>
            The length.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiSpectrum.StartingFrequency">
            <summary>
            Gets or sets the starting frequency in kHz.
            </summary>
            <value>
            The starting frequency.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiSpectrum.Resolution">
            <summary>
            Gets or sets the resolution of each sample in Hz.
            </summary>
            <value>
            The resolution in Hz.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiSpectrum.AmplitudeOffset">
            <summary>
            Gets or sets the amplitude offset (in 0.001 dBm)
            </summary>
            <value>
            The amplitude offset.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiSpectrum.AmplitudeResolution">
            <summary>
            Gets or sets the amplitude resolution (in .001 dBm)
            </summary>
            <value>
            The amplitude resolution.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiSpectrum.MaximumRssi">
            <summary>
            Gets or sets the maximum raw RSSI value reported by the device.
            </summary>
            <value>
            The maximum rssi.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiSpectrum.SamplesData">
            <summary>
            Gets or sets the data samples.
            </summary>
            <value>
            The data samples.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiSpectrum.Bytes">
            <summary>
            Gets the field bytes. This doesn't include the PPI field header.
            </summary>
            <value>
            The bytes.
            </value>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.PpiPacket">
            <summary>
            .Net analog of a PpiHeader.h from airpcap
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.PpiPacket.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.PpiPacket"/> class.
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.PpiPacket.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.PpiPacket"/> class.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.PpiPacket.Add(Kavprot.Packets.Ieee80211.PpiField)">
            <summary>
            Add the specified field to the packet.
            </summary>
            <param name='field'>
            the field.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.PpiPacket.Remove(Kavprot.Packets.Ieee80211.PpiField)">
            <summary>
            Removes the specified field from the packet.
            </summary>
            <param name='field'>
            the field.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.PpiPacket.RemoveAll(Kavprot.Packets.Ieee80211.PpiFieldType)">
            <summary>
            Removes all fields of the specified type.
            </summary>
            <param name='type'>
            the field type to be removed.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.PpiPacket.Contains(Kavprot.Packets.Ieee80211.PpiField)">
            <summary>
            Checks whether the specified field is in the packet.
            </summary>
            <param name='field'>
            <c>true</c> if the field is in the packet, <c>false</c> if not.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.PpiPacket.Contains(Kavprot.Packets.Ieee80211.PpiFieldType)">
            <summary>
            Checks whether there is field of the specified type in the packet.
            </summary>
            <param name='type'>
            <c>true</c> if there is a field of the specified type in the packet, <c>false</c> if not.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.PpiPacket.FindFirstByType(Kavprot.Packets.Ieee80211.PpiFieldType)">
            <summary>
            Finds the first field in the packet of the specified type.
            </summary>
            <returns>
            The first field in the packet of the specified type, or <c>null</c> if there is no field of the specified type.
            </returns>
            <param name='type'>
            The type of packet to find.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.PpiPacket.FindByType(Kavprot.Packets.Ieee80211.PpiFieldType)">
            <summary>
            Finds the fields in the packet of the specified type.
            </summary>
            <returns>
            The fields of the specified type, or an empty array of there are no fields of that type.
            </returns>
            <param name='type'>
            The type of packet to find.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.PpiPacket.GetEncapsulated(Kavprot.Packets.Packet)">
            <summary>
            Returns the Ieee80211MacFrame inside of the Packet p or null if
            there is no encapsulated packet
            </summary>
            <param name="p">
            A <see cref="T:Kavprot.Packets.Packet"/>
            </param>
            <returns>
            A <see cref="T:Kavprot.Packets.Ieee80211.MacFrame"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.PpiPacket.ToString(Kavprot.Packets.StringOutputType)">
            <summary cref="M:Kavprot.Packets.Packet.ToString(Kavprot.Packets.StringOutputType)"/>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.PpiPacket.GetEnumerator">
            <summary>
            Gets the enumerator of PPI fields.
            </summary>
            <returns>
            The field enumerator.
            </returns>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.PpiPacket.UpdateCalculatedValues">
            <summary>
            Called to ensure that field values are updated before
            the packet bytes are retrieved
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.PpiPacket.ReadPpiFields">
            <summary>
            Array of PPI fields
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.PpiPacket.ParseEncapsulatedBytes(Kavprot.Packets.Utils.ByteArraySegment,Kavprot.Packets.Ieee80211.PpiCommon)">
            <summary>
            Used by the Ieee80211PpiPacket constructor. 
            </summary>
            <param name="header">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
            <param name="commonField">
            The <see cref="T:Kavprot.Packets.Ieee80211.PpiCommon"/> object in the PPI packet or null if not available
            </param>
            <returns>
            A <see cref="T:Kavprot.Packets.PacketOrByteArraySegment"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiPacket.Length">
            <summary>
            Length of the whole header in bytes
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiPacket.Version">
            <summary>
            Version 0. Only increases for drastic changes, introduction of compatible
            new fields does not count.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiPacket.Flags">
            <summary>
            Gets or sets the PPI header flags.
            </summary>
            <value>
            The PPI header flags.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiPacket.LinkType">
            <summary>
            Gets or sets the type of the link type specified in the PPI packet. This should
            be the link type of the encapsulated packet.
            </summary>
            <value>
            The link type.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiPacket.Count">
            <summary>
            Returns the number of PPI fields in the PPI packet.
            </summary>
            <value>
            The number of fields.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.PpiPacket.Item(System.Int32)">
            <summary>
            Gets the <see cref="T:Kavprot.Packets.Ieee80211.PpiPacket"/> at the specified index.
            </summary>
            <param name="index">
            Index.
            </param>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.PpiPacket.HeaderFlags">
            <summary>
            PPI packet header flags.
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.PpiPacket.HeaderFlags.Alignment32Bit">
            <summary>
            Indicates whether or not the PPI fields are aligned to a 32 bit boundary.
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.CtsFrame">
            <summary>
            Format of a CTS frame
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.CtsFrame.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Constructor
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.CtsFrame.#ctor(System.Net.NetworkInformation.PhysicalAddress)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.CtsFrame"/> class.
            </summary>
            <param name="ReceiverAddress">
            Receiver address.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.CtsFrame.UpdateCalculatedValues">
            <summary>
            Writes the current packet properties to the backing ByteArraySegment.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.CtsFrame.GetAddressString">
            <summary>
            Returns a string with a description of the addresses used in the packet.
            This is used as a compoent of the string returned by ToString().
            </summary>
            <returns>
            The address string.
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.CtsFrame.ReceiverAddress">
            <summary>
            Receiver address
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.CtsFrame.FrameSize">
            <summary>
            Length of the frame
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.PpiFieldType">
            <summary>
             from PPI v 1.0.10
             </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.PpiFieldType.PpiReserved0">
            <summary>
            PpiReserved0
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.PpiFieldType.PpiReserved1">
            <summary>
            PpiReserved1
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.PpiFieldType.PpiCommon">
            <summary>
            PpiCommon
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.PpiFieldType.PpiMacExtensions">
            <summary>
             PpiMacExtensions
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.PpiFieldType.PpiMacPhy">
            <summary>
            PpiMacPhy
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.PpiFieldType.PpiSpectrum">
            <summary>
            PpiSpectrum
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.PpiFieldType.PpiProcessInfo">
            <summary>
            PpiProcessInfo
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.PpiFieldType.PpiCaptureInfo">
            <summary>
            PpiCaptureInfo
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.PpiFieldType.PpiAggregation">
            <summary>
            PpiAggregation
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.PpiFieldType.Ppi802_3">
            <summary>
            Ppi802_3
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.PpiFieldType.PpiReservedAll">
            <summary>
            PpiReservedAll
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.RtsFrame">
            <summary>
            RTS Frame has a ReceiverAddress[6], TransmitterAddress[6] and a FrameCheckSequence[4],
            these fields follow the common FrameControl[2] and DurationId[2] fields
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.RtsFrame.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Constructor
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.RtsFrame.GetAddressString">
            <summary>
            Returns a string with a description of the addresses used in the packet.
            This is used as a compoent of the string returned by ToString().
            </summary>
            <returns>
            The address string.
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.RtsFrame.ReceiverAddress">
            <summary>
            ReceiverAddress
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.RtsFrame.TransmitterAddress">
            <summary>
            TransmitterAddress
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.RtsFrame.FrameSize">
            <summary>
            Length of the frame
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.ChannelRadioTapField">
            <summary>
            Channel field
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.RadioTapField">
            <summary>
            Abstract class for all radio tap fields
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.RadioTapField.Parse(System.Int32,System.IO.BinaryReader)">
            <summary>
            Parse a radio tap field, indicated by bitIndex, from a given BinaryReader
            </summary>
            <param name="bitIndex">
            A <see cref="T:System.Int32"/>
            </param>
            <param name="br">
            A <see cref="T:System.IO.BinaryReader"/>
            </param>
            <returns>
            A <see cref="T:Kavprot.Packets.Ieee80211.RadioTapField"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.RadioTapField.CopyTo(System.Byte[],System.Int32)">
            <summary>
            Copies the field data to the destination buffer at the specified offset.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.RadioTapField.FieldType">
            <summary>Type of the field</summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.RadioTapField.Length">
            <summary>
            Gets the length of the field data.
            </summary>
            <value>
            The length.
            </value>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.ChannelRadioTapField.Flags">
            <summary>
            Channel flags
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.ChannelRadioTapField.ChannelFromFrequencyMHz(System.Int32)">
            <summary>
            Convert a frequency to a channel
            </summary>
            <remarks>There is some overlap between the 802.11b/g channel numbers and the 802.11a channel numbers. This means that while a particular frequncy will only
            ever map to single channel number the same channel number may be returned for more than one frequency. At present this affects channel numbers 8 and 12.</remarks>
            <param name="frequencyMHz">
            A <see cref="T:System.Int32"/>
            </param>
            <returns>
            A <see cref="T:System.Int32"/>
            </returns>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.ChannelRadioTapField.CopyTo(System.Byte[],System.Int32)">
            <summary>
            Copies the field data to the destination buffer at the specified offset.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.ChannelRadioTapField.#ctor(System.IO.BinaryReader)">
            <summary>
            Constructor
            </summary>
            <param name="br">
            A <see cref="T:System.IO.BinaryReader"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.ChannelRadioTapField.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.ChannelRadioTapField"/> class.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.ChannelRadioTapField.#ctor(System.UInt16,Kavprot.Packets.Ieee80211.RadioTapChannelFlags)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.ChannelRadioTapField"/> class.
            </summary>
            <param name="FrequencyMhz">
            Tx/Rx Frequency in MHz.
            </param>
            <param name="Flags">
            Flags.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.ChannelRadioTapField.ToString">
            <summary>
            ToString() override
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.ChannelRadioTapField.FieldType">
            <summary>Type of the field</summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.ChannelRadioTapField.Length">
            <summary>
            Gets the length of the field data.
            </summary>
            <value>
            The length.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.ChannelRadioTapField.FrequencyMHz">
            <summary>
            Frequency in MHz
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.ChannelRadioTapField.Channel">
            <summary>
            Channel number derived from frequency
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.FhssRadioTapField">
            <summary>
            Fhss radio tap field
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.FhssRadioTapField.CopyTo(System.Byte[],System.Int32)">
            <summary>
            Copies the field data to the destination buffer at the specified offset.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.FhssRadioTapField.#ctor(System.IO.BinaryReader)">
            <summary>
            Constructor
            </summary>
            <param name="br">
            A <see cref="T:System.IO.BinaryReader"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.FhssRadioTapField.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.FhssRadioTapField"/> class.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.FhssRadioTapField.#ctor(System.Byte,System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.FhssRadioTapField"/> class.
            </summary>
            <param name="ChannelHoppingSet">
            Channel hopping set.
            </param>
            <param name="Pattern">
            Channel hopping pattern.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.FhssRadioTapField.ToString">
            <summary>
            ToString() override
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.FhssRadioTapField.FieldType">
            <summary>Type of the field</summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.FhssRadioTapField.Length">
            <summary>
            Gets the length of the field data.
            </summary>
            <value>
            The length.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.FhssRadioTapField.ChannelHoppingSet">
            <summary>
            Hop set
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.FhssRadioTapField.Pattern">
            <summary>
            Hop pattern
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.FlagsRadioTapField">
            <summary>
            Radio tap flags
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.FlagsRadioTapField.Flags">
            <summary>
            Flags set
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.FlagsRadioTapField.CopyTo(System.Byte[],System.Int32)">
            <summary>
            Copies the field data to the destination buffer at the specified offset.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.FlagsRadioTapField.#ctor(System.IO.BinaryReader)">
            <summary>
            Constructor
            </summary>
            <param name="br">
            A <see cref="T:System.IO.BinaryReader"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.FlagsRadioTapField.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.FlagsRadioTapField"/> class.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.FlagsRadioTapField.#ctor(Kavprot.Packets.Ieee80211.RadioTapFlags)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.FlagsRadioTapField"/> class.
            </summary>
            <param name="Flags">
            Flags.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.FlagsRadioTapField.ToString">
            <summary>
            ToString() override
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.FlagsRadioTapField.FieldType">
            <summary>Type of the field</summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.FlagsRadioTapField.Length">
            <summary>
            Gets the length of the field data.
            </summary>
            <value>
            The length.
            </value>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.RateRadioTapField">
            <summary>
            Rate field
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.RateRadioTapField.CopyTo(System.Byte[],System.Int32)">
            <summary>
            Copies the field data to the destination buffer at the specified offset.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.RateRadioTapField.#ctor(System.IO.BinaryReader)">
            <summary>
            Constructor
            </summary>
            <param name="br">
            A <see cref="T:System.IO.BinaryReader"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.RateRadioTapField.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.RateRadioTapField"/> class.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.RateRadioTapField.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.RateRadioTapField"/> class.
            </summary>
            <param name="RateMbps">
            Rate mbps.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.RateRadioTapField.ToString">
            <summary>
            ToString() override
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.RateRadioTapField.FieldType">
            <summary>Type of the field</summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.RateRadioTapField.Length">
            <summary>
            Gets the length of the field data.
            </summary>
            <value>
            The length.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.RateRadioTapField.RateMbps">
            <summary>
            Rate in Mbps
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.DbAntennaSignalRadioTapField">
            <summary>
            Db antenna signal
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DbAntennaSignalRadioTapField.CopyTo(System.Byte[],System.Int32)">
            <summary>
            Copies the field data to the destination buffer at the specified offset.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DbAntennaSignalRadioTapField.#ctor(System.IO.BinaryReader)">
            <summary>
            Constructor
            </summary>
            <param name="br">
            A <see cref="T:System.IO.BinaryReader"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DbAntennaSignalRadioTapField.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.DbAntennaSignalRadioTapField"/> class.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DbAntennaSignalRadioTapField.#ctor(System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.DbAntennaSignalRadioTapField"/> class.
            </summary>
            <param name="SignalStrengthdB">
            Signal strength in dB
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DbAntennaSignalRadioTapField.ToString">
            <summary>
            ToString() override
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.DbAntennaSignalRadioTapField.FieldType">
            <summary>Type of the field</summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.DbAntennaSignalRadioTapField.Length">
            <summary>
            Gets the length of the field data.
            </summary>
            <value>
            The length.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.DbAntennaSignalRadioTapField.SignalStrengthdB">
            <summary>
            Signal strength in dB
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.DbAntennaNoiseRadioTapField">
            <summary>
            Antenna noise in dB
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DbAntennaNoiseRadioTapField.CopyTo(System.Byte[],System.Int32)">
            <summary>
            Copies the field data to the destination buffer at the specified offset.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DbAntennaNoiseRadioTapField.#ctor(System.IO.BinaryReader)">
            <summary>
            Constructor
            </summary>
            <param name="br">
            A <see cref="T:System.IO.BinaryReader"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DbAntennaNoiseRadioTapField.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.DbAntennaNoiseRadioTapField"/> class.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DbAntennaNoiseRadioTapField.#ctor(System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.DbAntennaNoiseRadioTapField"/> class.
            </summary>
            <param name="AntennaNoisedB">
            Antenna signal noise in dB.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DbAntennaNoiseRadioTapField.ToString">
            <summary>
            ToString() override
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.DbAntennaNoiseRadioTapField.FieldType">
            <summary>Type of the field</summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.DbAntennaNoiseRadioTapField.Length">
            <summary>
            Gets the length of the field data.
            </summary>
            <value>
            The length.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.DbAntennaNoiseRadioTapField.AntennaNoisedB">
            <summary>
            Antenna noise in dB
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.AntennaRadioTapField">
            <summary>
            Antenna field
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.AntennaRadioTapField.CopyTo(System.Byte[],System.Int32)">
            <summary>
            Copies the field data to the destination buffer at the specified offset.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.AntennaRadioTapField.#ctor(System.IO.BinaryReader)">
            <summary>
            Constructor
            </summary>
            <param name="br">
            A <see cref="T:System.IO.BinaryReader"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.AntennaRadioTapField.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.AntennaRadioTapField"/> class.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.AntennaRadioTapField.#ctor(System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.AntennaRadioTapField"/> class.
            </summary>
            <param name="Antenna">
            Antenna index of the Rx/Tx antenna for this packet. The first antenna is antenna 0.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.AntennaRadioTapField.ToString">
            <summary>
            ToString() override
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.AntennaRadioTapField.FieldType">
            <summary>Type of the field</summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.AntennaRadioTapField.Length">
            <summary>
            Gets the length of the field data.
            </summary>
            <value>
            The length.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.AntennaRadioTapField.Antenna">
            <summary>
            Antenna number
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.DbmAntennaSignalRadioTapField">
            <summary>
            Antenna signal in dBm
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DbmAntennaSignalRadioTapField.CopyTo(System.Byte[],System.Int32)">
            <summary>
            Copies the field data to the destination buffer at the specified offset.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DbmAntennaSignalRadioTapField.#ctor(System.IO.BinaryReader)">
            <summary>
            Constructor
            </summary>
            <param name="br">
            A <see cref="T:System.IO.BinaryReader"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DbmAntennaSignalRadioTapField.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.DbmAntennaSignalRadioTapField"/> class.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DbmAntennaSignalRadioTapField.#ctor(System.SByte)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.DbmAntennaSignalRadioTapField"/> class.
            </summary>
            <param name="AntennaSignalDbm">
            Antenna signal power in dB.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DbmAntennaSignalRadioTapField.ToString">
            <summary>
            ToString() override
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.DbmAntennaSignalRadioTapField.FieldType">
            <summary>Type of the field</summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.DbmAntennaSignalRadioTapField.Length">
            <summary>
            Gets the length of the field data.
            </summary>
            <value>
            The length.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.DbmAntennaSignalRadioTapField.AntennaSignalDbm">
            <summary>
            Antenna signal in dBm
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.DbmAntennaNoiseRadioTapField">
            <summary>
            Antenna noise in dBm
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DbmAntennaNoiseRadioTapField.CopyTo(System.Byte[],System.Int32)">
            <summary>
            Copies the field data to the destination buffer at the specified offset.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DbmAntennaNoiseRadioTapField.#ctor(System.IO.BinaryReader)">
            <summary>
            Constructor
            </summary>
            <param name="br">
            A <see cref="T:System.IO.BinaryReader"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DbmAntennaNoiseRadioTapField.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.DbmAntennaNoiseRadioTapField"/> class.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DbmAntennaNoiseRadioTapField.#ctor(System.SByte)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.DbmAntennaNoiseRadioTapField"/> class.
            </summary>
            <param name="AntennaNoisedBm">
            Antenna noise in dBm.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DbmAntennaNoiseRadioTapField.ToString">
            <summary>
            ToString() override
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.DbmAntennaNoiseRadioTapField.FieldType">
            <summary>Type of the field</summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.DbmAntennaNoiseRadioTapField.Length">
            <summary>
            Gets the length of the field data.
            </summary>
            <value>
            The length.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.DbmAntennaNoiseRadioTapField.AntennaNoisedBm">
            <summary>
            Antenna noise in dBm
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.LockQualityRadioTapField">
            <summary>
            Lock quality
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.LockQualityRadioTapField.CopyTo(System.Byte[],System.Int32)">
            <summary>
            Copies the field data to the destination buffer at the specified offset.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.LockQualityRadioTapField.#ctor(System.IO.BinaryReader)">
            <summary>
            Constructor
            </summary>
            <param name="br">
            A <see cref="T:System.IO.BinaryReader"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.LockQualityRadioTapField.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.LockQualityRadioTapField"/> class.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.LockQualityRadioTapField.#ctor(System.UInt16)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.LockQualityRadioTapField"/> class.
            </summary>
            <param name="SignalQuality">
            Signal quality.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.LockQualityRadioTapField.ToString">
            <summary>
            ToString() override
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.LockQualityRadioTapField.FieldType">
            <summary>Type of the field</summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.LockQualityRadioTapField.Length">
            <summary>
            Gets the length of the field data.
            </summary>
            <value>
            The length.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.LockQualityRadioTapField.SignalQuality">
            <summary>
            Signal quality
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.TsftRadioTapField">
            <summary>
            Tsft radio tap field
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.TsftRadioTapField.CopyTo(System.Byte[],System.Int32)">
            <summary>
            Copies the field data to the destination buffer at the specified offset.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.TsftRadioTapField.#ctor(System.IO.BinaryReader)">
            <summary>
            Constructor
            </summary>
            <param name="br">
            A <see cref="T:System.IO.BinaryReader"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.TsftRadioTapField.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.TsftRadioTapField"/> class.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.TsftRadioTapField.#ctor(System.UInt64)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.TsftRadioTapField"/> class.
            </summary>
            <param name="TimestampUsec">
            Value in microseconds of the Time Synchronization Function timer
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.TsftRadioTapField.ToString">
            <summary>
            ToString() override
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.TsftRadioTapField.FieldType">
            <summary>Type of the field</summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.TsftRadioTapField.Length">
            <summary>
            Gets the length of the field data.
            </summary>
            <value>
            The length.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.TsftRadioTapField.TimestampUsec">
            <summary>
            Timestamp in microseconds
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.RxFlagsRadioTapField">
            <summary>
            Contains properties about the received from.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.RxFlagsRadioTapField.CopyTo(System.Byte[],System.Int32)">
            <summary>
            Copies the field data to the destination buffer at the specified offset.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.RxFlagsRadioTapField.#ctor(System.IO.BinaryReader)">
            <summary>
            Constructor
            </summary>
            <param name="br">
            A <see cref="T:System.IO.BinaryReader"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.RxFlagsRadioTapField.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.RxFlagsRadioTapField"/> class.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.RxFlagsRadioTapField.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.RxFlagsRadioTapField"/> class.
            </summary>
            <param name="PlcpCrcCheckFailed">
            PLCP CRC check failed.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.RxFlagsRadioTapField.ToString">
            <summary>
            ToString() override
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.RxFlagsRadioTapField.FieldType">
            <summary>Type of the field</summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.RxFlagsRadioTapField.Length">
            <summary>
            Gets the length of the field data.
            </summary>
            <value>
            The length.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.RxFlagsRadioTapField.PlcpCrcCheckFailed">
            <summary>
            Gets or sets a value indicating whether the frame failed the PLCP CRC check.
            </summary>
            <value>
            <c>true</c> if the PLCP CRC check failed; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.TxAttenuationRadioTapField">
            <summary>
            Transmit power expressed as unitless distance from max
            power set at factory calibration.  0 is max power.
            Monotonically nondecreasing with lower power levels.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.TxAttenuationRadioTapField.CopyTo(System.Byte[],System.Int32)">
            <summary>
            Copies the field data to the destination buffer at the specified offset.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.TxAttenuationRadioTapField.#ctor(System.IO.BinaryReader)">
            <summary>
            Constructor
            </summary>
            <param name="br">
            A <see cref="T:System.IO.BinaryReader"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.TxAttenuationRadioTapField.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.TxAttenuationRadioTapField"/> class.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.TxAttenuationRadioTapField.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.TxAttenuationRadioTapField"/> class.
            </summary>
            <param name="TxPower">
            Transmit power expressed as unitless distance from max power set at factory calibration. 0 is max power.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.TxAttenuationRadioTapField.ToString">
            <summary>
            ToString() override
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.TxAttenuationRadioTapField.FieldType">
            <summary>Type of the field</summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.TxAttenuationRadioTapField.Length">
            <summary>
            Gets the length of the field data.
            </summary>
            <value>
            The length.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.TxAttenuationRadioTapField.TxPower">
            <summary>
            Transmit power
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.DbTxAttenuationRadioTapField">
            <summary>
            Transmit power expressed as decibel distance from max power
            set at factory calibration.  0 is max power.  Monotonically
            nondecreasing with lower power levels.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DbTxAttenuationRadioTapField.CopyTo(System.Byte[],System.Int32)">
            <summary>
            Copies the field data to the destination buffer at the specified offset.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DbTxAttenuationRadioTapField.#ctor(System.IO.BinaryReader)">
            <summary>
            Constructor
            </summary>
            <param name="br">
            A <see cref="T:System.IO.BinaryReader"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DbTxAttenuationRadioTapField.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.DbTxAttenuationRadioTapField"/> class.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DbTxAttenuationRadioTapField.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.DbTxAttenuationRadioTapField"/> class.
            </summary>
            <param name="TxPowerdB">
            Transmit power expressed as decibel distance from max power set at factory calibration. 0 is max power.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DbTxAttenuationRadioTapField.ToString">
            <summary>
            ToString() override
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.DbTxAttenuationRadioTapField.FieldType">
            <summary>Type of the field</summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.DbTxAttenuationRadioTapField.Length">
            <summary>
            Gets the length of the field data.
            </summary>
            <value>
            The length.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.DbTxAttenuationRadioTapField.TxPowerdB">
            <summary>
            Transmit power 
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.DbmTxPowerRadioTapField">
            <summary>
            Transmit power expressed as dBm (decibels from a 1 milliwatt
            reference). This is the absolute power level measured at
            the antenna port.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DbmTxPowerRadioTapField.CopyTo(System.Byte[],System.Int32)">
            <summary>
            Copies the field data to the destination buffer at the specified offset.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DbmTxPowerRadioTapField.#ctor(System.IO.BinaryReader)">
            <summary>
            Constructor
            </summary>
            <param name="br">
            A <see cref="T:System.IO.BinaryReader"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DbmTxPowerRadioTapField.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.DbmTxPowerRadioTapField"/> class.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DbmTxPowerRadioTapField.#ctor(System.SByte)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.DbmTxPowerRadioTapField"/> class.
            </summary>
            <param name="TxPowerdBm">
            Transmit power expressed as dBm (decibels from a 1 milliwatt reference).
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DbmTxPowerRadioTapField.ToString">
            <summary>
            ToString() override
            </summary>
            <returns>
            A <see cref="T:System.String"/>
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.DbmTxPowerRadioTapField.FieldType">
            <summary>Type of the field</summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.DbmTxPowerRadioTapField.Length">
            <summary>
            Gets the length of the field data.
            </summary>
            <value>
            The length.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.DbmTxPowerRadioTapField.TxPowerdBm">
            <summary>
            Tx power in dBm
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.InformationElementList">
            <summary>
            A <see cref="!:System.Collections.Generic.List"/> of 
            <see cref="T:Kavprot.Packets.Ieee80211.InformationElement">InformationElements</see>.
            </summary>
            <remarks>
            The order and set of Information Elements allowed in a particular 802.11 frame type is dictated
            by the 802.11 standards.
            </remarks>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.InformationElementList.#ctor">
            <summary>
            Initializes an empty <see cref="T:Kavprot.Packets.Ieee80211.InformationElementList"/>.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.InformationElementList.#ctor(Kavprot.Packets.Ieee80211.InformationElementList)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.InformationElementList"/> class.
            </summary>
            <param name="list">
            The elements to be included in the list.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.InformationElementList.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.InformationElementList"/> class.
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/> containing one or more information elements.
            bas.Offset should point to the first byte of the first Information Element. 
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.InformationElementList.FindById(Kavprot.Packets.Ieee80211.InformationElement.ElementId)">
            <summary>
            Finds all <see cref="T:Kavprot.Packets.Ieee80211.InformationElement">InformatonElements</see> in the lists
            with the provided id.
            </summary>
            <returns>
            The <see cref="T:Kavprot.Packets.Ieee80211.InformationElement">InformationElements</see> found, or an empty array if none are found
            </returns>
            <param name="id">
            The Id to search for
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.InformationElementList.FindFirstById(Kavprot.Packets.Ieee80211.InformationElement.ElementId)">
            <summary>
            Finds the first <see cref="T:Kavprot.Packets.Ieee80211.InformationElement"/> in the list
            with the provided id.
            </summary>
            <returns>
            The first element with the provided Id or null if the list contains no relevant elements
            </returns>
            <param name="id">
            The Id to search for
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.InformationElementList.CopyTo(Kavprot.Packets.Utils.ByteArraySegment,System.Int32)">
            <summary>
            Serialises the <see cref="T:Kavprot.Packets.Ieee80211.InformationElement">InformationElements</see>
            in the list into the provided buffer.
            </summary>
            <param name="destination">
            The <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/> to copy the elements into.
            </param>
            <param name="offset">
            The offset into destination at which to start copy the <see cref="T:Kavprot.Packets.Ieee80211.InformationElement">InformationElements</see>
            </param>
            <remarks>Ensure that the destination is large enough to contain serialised elements
            before calling this method</remarks>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.InformationElementList.Length">
            <summary>
            Gets the total length in bytes of the list if its elements were serialised into a byte array
            </summary>
            <value>
            The length
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.InformationElementList.Bytes">
            <summary>
            Gets a Byte[] containing the serialised 
            <see cref="T:Kavprot.Packets.Ieee80211.InformationElement">InformationElements</see>
            </summary>
            <value>
            The serialised <see cref="T:Kavprot.Packets.Ieee80211.InformationElement">InformationElements</see>
            </value>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.BlockAcknowledgmentRequestFrame">
            <summary>
            Block acknowledgment request frame.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.BlockAcknowledgmentRequestFrame.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Constructor
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.BlockAcknowledgmentRequestFrame.#ctor(System.Net.NetworkInformation.PhysicalAddress,System.Net.NetworkInformation.PhysicalAddress)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.BlockAcknowledgmentRequestFrame"/> class.
            </summary>
            <param name="TransmitterAddress">
            Transmitter address.
            </param>
            <param name="ReceiverAddress">
            Receiver address.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.BlockAcknowledgmentRequestFrame.UpdateCalculatedValues">
            <summary>
            Writes the current packet properties to the backing ByteArraySegment.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.BlockAcknowledgmentRequestFrame.GetAddressString">
            <summary>
            Returns a string with a description of the addresses used in the packet.
            This is used as a compoent of the string returned by ToString().
            </summary>
            <returns>
            The address string.
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.BlockAcknowledgmentRequestFrame.ReceiverAddress">
            <summary>
            Receiver address
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.BlockAcknowledgmentRequestFrame.TransmitterAddress">
            <summary>
            Transmitter address
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.BlockAcknowledgmentRequestFrame.BlockAckRequestControlBytes">
            <summary>
            Block acknowledgment control bytes are the first two bytes of the frame
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.BlockAcknowledgmentRequestFrame.BlockAcknowledgmentControl">
            <summary>
            Block acknowledgment control field
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.BlockAcknowledgmentRequestFrame.BlockAckStartingSequenceControl">
            <summary>
            Gets or sets the sequence number of the first MSDU for which this 
            block acknowledgement request frame is sent
            </summary>
            <value>
            The block ack starting sequence control field value
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.BlockAcknowledgmentRequestFrame.BlockAckStartingSequenceControlBytes">
            <summary>
            Gets or sets the block ack starting sequence control.
            </summary>
            <value>
            The block ack starting sequence control.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.BlockAcknowledgmentRequestFrame.FrameSize">
            <summary>
            Length of the frame
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.MacFields">
             <summary>
            
             NOTE: All positions are not defined here because the frame type changes
             whether some address fields are present or not, causing the sequence control
             field to move. In addition the payload size determines where the frame control
             sequence value is as it is after the payload bytes, if any payload is present
             </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.MacFields.SequenceControlPosition">
            <summary>
            Not all MAC Frames contain a sequence control field. The value of this field is only meaningful when they do.
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.ReassociationRequestFrame">
             <summary>
             Reassociation request frame.
            
             Sent when a wireless client is going from one access point to another
             http://en.wikipedia.org/wiki/IEEE_802.11#Frames
             </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.ReassociationRequestFrame.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Constructor
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.ReassociationRequestFrame.#ctor(System.Net.NetworkInformation.PhysicalAddress,System.Net.NetworkInformation.PhysicalAddress,System.Net.NetworkInformation.PhysicalAddress,Kavprot.Packets.Ieee80211.InformationElementList)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.ReassociationRequestFrame"/> class.
            </summary>
            <param name="SourceAddress">
            Source address.
            </param>
            <param name="DestinationAddress">
            Destination address.
            </param>
            <param name="BssId">
            BssId.
            </param>
            <param name="InformationElements">
            Information elements.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.ReassociationRequestFrame.UpdateCalculatedValues">
            <summary>
            Writes the current packet properties to the backing ByteArraySegment.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.ReassociationRequestFrame.CapabilityInformationBytes">
            <summary>
            Frame control bytes are the first two bytes of the frame
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.ReassociationRequestFrame.CapabilityInformation">
            <summary>
            Gets or sets the capability information, the type of network the mobile station wants to join
            </summary>
            <value>
            The capability information.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.ReassociationRequestFrame.ListenInterval">
            <summary>
            Gets or sets the listen interval. This is the number of beacon interval time periods that the access
            point must retain buffered packets for.
            </summary>
            <value>
            The listen interval.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.ReassociationRequestFrame.ListenIntervalBytes">
            <summary>
            Gets or sets the listen interval, the length of buffered frame retention
            </summary>
            <value>
            The listen interval.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.ReassociationRequestFrame.CurrentAccessPointAddress">
            <summary>
            DestinationAddress
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.ReassociationRequestFrame.InformationElements">
            <summary>
            Gets or sets the information elements.
            </summary>
            <value>
            The information elements.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.ReassociationRequestFrame.FrameSize">
            <summary>
            Gets the size of the frame.
            </summary>
            <value>
            The size of the frame.
            </value>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.QosNullDataFrame">
            <summary>
            The Qos null data frame serves the same purpose as <see cref="T:Kavprot.Packets.Ieee80211.NullDataFrame"/> but also includes a
            quality of service control field.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.QosNullDataFrame.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.QosNullDataFrame"/> class.
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.QosNullDataFrame.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.QosNullDataFrame"/> class.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.QosNullDataFrame.UpdateCalculatedValues">
            <summary>
            Writes the current packet properties to the backing ByteArraySegment.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.QosNullDataFrame.QosControl">
            <summary>
            Gets or sets the qos control field.
            </summary>
            <value>
            The qos control field.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.QosNullDataFrame.FrameSize">
            <summary>
            Length of the frame header.
            
            This does not include the FCS, it represents only the header bytes that would
            would preceed any payload.
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.DurationField">
            <summary>
            Duration field.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DurationField.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.DurationField"/> class.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DurationField.#ctor(System.UInt16)">
            <summary>
            Constructor
            </summary>
            <param name="field">
            A <see cref="T:System.UInt16"/>
            </param>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.DurationField.Field">
            <summary>
            This is the raw Duration field
            
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.DeauthenticationFrame">
            <summary>
            Deauthentication frame.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DeauthenticationFrame.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Constructor
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DeauthenticationFrame.#ctor(System.Net.NetworkInformation.PhysicalAddress,System.Net.NetworkInformation.PhysicalAddress,System.Net.NetworkInformation.PhysicalAddress)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.DeauthenticationFrame"/> class.
            </summary>
            <param name="SourceAddress">
            Source address.
            </param>
            <param name="DestinationAddress">
            Destination address.
            </param>
            <param name="BssId">
            Bss identifier (MAC Address of the Access Point).
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DeauthenticationFrame.UpdateCalculatedValues">
            <summary>
            Writes the current packet properties to the backing ByteArraySegment.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.DeauthenticationFrame.Reason">
            <summary>
            Gets the reason for deauthentication.
            </summary>
            <value>
            The reason.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.DeauthenticationFrame.FrameSize">
            <summary>
            Gets the size of the frame.
            </summary>
            <value>
            The size of the frame.
            </value>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.DataDataFrame">
            <summary>
            Data data frame.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DataDataFrame.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.DataDataFrame"/> class.
            </summary>
            <param name="bas">
            Bas.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DataDataFrame.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.DataDataFrame"/> class.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.DataDataFrame.UpdateCalculatedValues">
            <summary>
            Writes the current packet properties to the backing ByteArraySegment.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.DataDataFrame.FrameSize">
            <summary>
            Gets the size of the frame.
            </summary>
            <value>
            The size of the frame.
            </value>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.ContentionFreeEndFrame">
            <summary>
            Contention free end frame.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.ContentionFreeEndFrame.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Constructor
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.ContentionFreeEndFrame.#ctor(System.Net.NetworkInformation.PhysicalAddress,System.Net.NetworkInformation.PhysicalAddress)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.ContentionFreeEndFrame"/> class.
            </summary>
            <param name="ReceiverAddress">
            Receiver address.
            </param>
            <param name="BssId">
            Bss identifier (MAC Address of the Access Point).
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.ContentionFreeEndFrame.UpdateCalculatedValues">
            <summary>
            Writes the current packet properties to the backing ByteArraySegment.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.ContentionFreeEndFrame.GetAddressString">
            <summary>
            Returns a string with a description of the addresses used in the packet.
            This is used as a compoent of the string returned by ToString().
            </summary>
            <returns>
            The address string.
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.ContentionFreeEndFrame.ReceiverAddress">
            <summary>
            Receiver address
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.ContentionFreeEndFrame.BssId">
            <summary>
            BSS ID
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.ContentionFreeEndFrame.FrameSize">
            <summary>
            Length of the frame
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.AuthenticationFrame">
            <summary>
            Format of an 802.11 management authentication frame.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.AuthenticationFrame.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Constructor
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.AuthenticationFrame.#ctor(System.Net.NetworkInformation.PhysicalAddress,System.Net.NetworkInformation.PhysicalAddress,System.Net.NetworkInformation.PhysicalAddress,Kavprot.Packets.Ieee80211.InformationElementList)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.AuthenticationFrame"/> class.
            </summary>
            <param name="SourceAddress">
            Source address.
            </param>
            <param name="DestinationAddress">
            Destination address.
            </param>
            <param name="BssId">
            Bss identifier (MAC Address of Access Point).
            </param>
            <param name="InformationElements">
            Information elements.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.AuthenticationFrame.UpdateCalculatedValues">
            <summary>
            Writes the current packet properties to the backing ByteArraySegment.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.AuthenticationFrame.AuthenticationAlgorithmNumber">
            <summary>
            Number used for selection of authentication algorithm
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.AuthenticationFrame.AuthenticationAlgorithmTransactionSequenceNumber">
            <summary>
            Sequence number to define the step of the authentication algorithm
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.AuthenticationFrame.StatusCode">
            <summary>
            Indicates the success or failure of the authentication operation
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.AuthenticationFrame.InformationElements">
            <summary>
            The information elements included in the frame
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.AuthenticationFrame.FrameSize">
            <summary>
            Gets the size of the frame.
            </summary>
            <value>
            The size of the frame.
            </value>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.AckFrame">
            <summary>
            Format of an ACK frame
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.AckFrame.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Constructor
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.AckFrame.#ctor(System.Net.NetworkInformation.PhysicalAddress)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.AckFrame"/> class.
            </summary>
            <param name="ReceiverAddress">
            Receiver address.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.AckFrame.UpdateCalculatedValues">
            <summary>
            Writes the current packet properties to the backing ByteArraySegment.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.AckFrame.GetAddressString">
            <summary>
            Returns a string with a description of the addresses used in the packet.
            This is used as a compoent of the string returned by ToString().
            </summary>
            <returns>
            The address string.
            </returns>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.AckFrame.ReceiverAddress">
            <summary>
            Receiver address
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.AckFrame.FrameSize">
            <summary>
            Length of the frame
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.SequenceControlField">
            <summary>
            The Sequence control field occurs in management and data frames and is used to 
            relate together fragmented payloads carried in multiple 802.11 frames.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.SequenceControlField.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.SequenceControlField"/> class.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.SequenceControlField.#ctor(System.UInt16)">
            <summary>
            Constructor
            </summary>
            <param name="field">
            A <see cref="T:System.UInt16"/>
            </param>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.SequenceControlField.Field">
            <summary>
            Gets or sets the field that backs all the other properties in the class.
            </summary>
            <value>
            The field.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.SequenceControlField.SequenceNumber">
            <summary>
            Gets or sets the sequence number.
            </summary>
            <value>
            The sequence number.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.SequenceControlField.FragmentNumber">
            <summary>
            Gets or sets the fragment number.
            </summary>
            <value>
            The fragment number.
            </value>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.RadioFields">
             <summary>
             As defined by Airpcap.h
            
             NOTE: PresentPosition may not be the only position present
             as this the field can be extended if the high bit is set
             </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioFields.VersionLength">
            <summary>Length of the version field</summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioFields.PadLength">
            <summary>Length of the pad field</summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioFields.LengthLength">
            <summary>Length of the length field</summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioFields.PresentLength">
            <summary>Length of the first present field (others may follow)</summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioFields.VersionPosition">
            <summary>Position of the version field</summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioFields.PadPosition">
            <summary>Position of the padding field</summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioFields.LengthPosition">
            <summary>Position of the length field</summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioFields.PresentPosition">
            <summary>Position of the first present field</summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioFields.DefaultHeaderLength">
            <summary>Default header length, assuming one present field entry</summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.RadioTapFlags">
            <summary>
            Radio tap flags
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioTapFlags.CFP">
            <summary>
            sent/received during cfp
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioTapFlags.ShortPreamble">
            <summary>
            sent/received with short preamble
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioTapFlags.WepEncrypted">
            <summary>
            sent/received with WEP encryption
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioTapFlags.Fragmentation">
            <summary>
            sent/received with fragmentation
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioTapFlags.FcsIncludedInFrame">
            <summary>
            frame includes FCS
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioTapFlags.PostFramePadding">
            <summary>
            frame includes padding to the 32 bit boundary between the 802.11 header and the payload
            </summary>
        </member>
        <member name="F:Kavprot.Packets.Ieee80211.RadioTapFlags.FailedFcsCheck">
             <summary>
            fFrame failed the fcs check
             </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.RadioPacket">
            <summary>
            .Net analog of a ieee80211_radiotap_header from airpcap.h
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.RadioPacket.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.RadioPacket"/> class.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.RadioPacket.ToString(Kavprot.Packets.StringOutputType)">
            <summary cref="M:Kavprot.Packets.Packet.ToString(Kavprot.Packets.StringOutputType)"/>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.RadioPacket.Add(Kavprot.Packets.Ieee80211.RadioTapField)">
            <summary>
            Add the specified field to the packet.
            </summary>
            <param name='field'>
            Field to be added
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.RadioPacket.Remove(Kavprot.Packets.Ieee80211.RadioTapType)">
            <summary>
            Removes a field of the specified type if one is present in the packet.
            </summary>
            <param name='fieldType'>
            Field type.
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.RadioPacket.Contains(Kavprot.Packets.Ieee80211.RadioTapType)">
            <summary>
            Checks for the presence of a field of the specified type in the packet.
            </summary>
            <param name='fieldType'>
            The field type to check for.
            </param>
            <returns><c>true</c> if the packet contains a field of the specified type; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.RadioPacket.UpdateCalculatedValues">
            <summary>
            Called to ensure that field values are updated before
            the packet bytes are retrieved
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.RadioPacket.Version">
            <summary>
            Version 0. Only increases for drastic changes, introduction of compatible
            new fields does not count.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.RadioPacket.Length">
            <summary>
            Length of the whole header in bytes, including it_version, it_pad, it_len
            and data fields
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.RadioPacket.Present">
            <summary>
            Returns an array of UInt32 bitmap entries. Each bit in the bitmap indicates
            which fields are present. Set bit 31 (0x8000000)
            to extend the bitmap by another 32 bits. Additional extensions are made
            by setting bit 31.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.RadioPacket.Item(Kavprot.Packets.Ieee80211.RadioTapType)">
            <summary>
            Gets the <see cref="T:Kavprot.Packets.Ieee80211.RadioTapField"/> with the specified type, or null if the
            field is not in the packet.
            </summary>
            <param name="type">
            Radio Tap field type
            </param>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.RadioPacket.RadioTapFields">
            <summary>
            Array of radio tap fields
            </summary>
        </member>
        <member name="T:Kavprot.Packets.Ieee80211.QosDataFrame">
            <summary>
            Qos data frames are like regualr data frames except they contain a quality of service 
            field as deinfed in the 802.11e standard.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.QosDataFrame.#ctor(Kavprot.Packets.Utils.ByteArraySegment)">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.QosDataFrame"/> class.
            </summary>
            <param name="bas">
            A <see cref="T:Kavprot.Packets.Utils.ByteArraySegment"/>
            </param>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.QosDataFrame.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Kavprot.Packets.Ieee80211.QosDataFrame"/> class.
            </summary>
        </member>
        <member name="M:Kavprot.Packets.Ieee80211.QosDataFrame.UpdateCalculatedValues">
            <summary>
            Writes the current packet properties to the backing ByteArraySegment.
            </summary>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.QosDataFrame.QosControl">
            <summary>
            Gets or sets the qos control field.
            </summary>
            <value>
            The qos control field.
            </value>
        </member>
        <member name="P:Kavprot.Packets.Ieee80211.QosDataFrame.FrameSize">
            <summary>
            Length of the frame header.
            
            This does not include the FCS, it represents only the header bytes that would
            would preceed any payload.
            </summary>
        </member>
    </members>
</doc>
